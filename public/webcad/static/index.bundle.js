/******/ (function(modules) { // webpackBootstrap
/******/ 	var parentHotUpdateCallback = this["webpackHotUpdate"];
/******/ 	this["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
/******/ 		if(typeof XMLHttpRequest === "undefined")
/******/ 			return callback(new Error("No browser support"));
/******/ 		try {
/******/ 			var request = new XMLHttpRequest();
/******/ 			var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 			request.open("GET", requestPath, true);
/******/ 			request.timeout = 10000;
/******/ 			request.send(null);
/******/ 		} catch(err) {
/******/ 			return callback(err);
/******/ 		}
/******/ 		request.onreadystatechange = function() {
/******/ 			if(request.readyState !== 4) return;
/******/ 			if(request.status === 0) {
/******/ 				// timeout
/******/ 				callback(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 			} else if(request.status === 404) {
/******/ 				// no update available
/******/ 				callback();
/******/ 			} else if(request.status !== 200 && request.status !== 304) {
/******/ 				// other failure
/******/ 				callback(new Error("Manifest request to " + requestPath + " failed."));
/******/ 			} else {
/******/ 				// success
/******/ 				try {
/******/ 					var update = JSON.parse(request.responseText);
/******/ 				} catch(e) {
/******/ 					callback(e);
/******/ 					return;
/******/ 				}
/******/ 				callback(null, update);
/******/ 			}
/******/ 		};
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js
/******/ 	var canDefineProperty = false;
/******/ 	try {
/******/ 		Object.defineProperty({}, "x", {
/******/ 			get: function() {}
/******/ 		});
/******/ 		canDefineProperty = true;
/******/ 	} catch(x) {
/******/ 		// IE will fail on defineProperty
/******/ 	}
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "b266d736f5dbe5e1a03e"; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					if(me.children.indexOf(request) < 0)
/******/ 						me.children.push(request);
/******/ 				} else hotCurrentParents = [moduleId];
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {
/******/ 				if(canDefineProperty) {
/******/ 					Object.defineProperty(fn, name, (function(name) {
/******/ 						return {
/******/ 							configurable: true,
/******/ 							enumerable: true,
/******/ 							get: function() {
/******/ 								return __webpack_require__[name];
/******/ 							},
/******/ 							set: function(value) {
/******/ 								__webpack_require__[name] = value;
/******/ 							}
/******/ 						};
/******/ 					}(name)));
/******/ 				} else {
/******/ 					fn[name] = __webpack_require__[name];
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		function ensure(chunkId, callback) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			__webpack_require__.e(chunkId, function() {
/******/ 				try {
/******/ 					callback.call(null, fn);
/******/ 				} finally {
/******/ 					finishChunkLoading();
/******/ 				}
/******/ 	
/******/ 				function finishChunkLoading() {
/******/ 					hotChunksLoading--;
/******/ 					if(hotStatus === "prepare") {
/******/ 						if(!hotWaitingFilesMap[chunkId]) {
/******/ 							hotEnsureUpdateChunk(chunkId);
/******/ 						}
/******/ 						if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 							hotUpdateDownloaded();
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		}
/******/ 		if(canDefineProperty) {
/******/ 			Object.defineProperty(fn, "e", {
/******/ 				enumerable: true,
/******/ 				value: ensure
/******/ 			});
/******/ 		} else {
/******/ 			fn.e = ensure;
/******/ 		}
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback;
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback;
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "number")
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 				else
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailibleFilesMap = {};
/******/ 	var hotCallback;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply, callback) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		if(typeof apply === "function") {
/******/ 			hotApplyOnUpdate = false;
/******/ 			callback = apply;
/******/ 		} else {
/******/ 			hotApplyOnUpdate = apply;
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 		hotSetStatus("check");
/******/ 		hotDownloadManifest(function(err, update) {
/******/ 			if(err) return callback(err);
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				callback(null, null);
/******/ 				return;
/******/ 			}
/******/ 	
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotAvailibleFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			for(var i = 0; i < update.c.length; i++)
/******/ 				hotAvailibleFilesMap[update.c[i]] = true;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			hotCallback = callback;
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailibleFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var callback = hotCallback;
/******/ 		hotCallback = null;
/******/ 		if(!callback) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			hotApply(hotApplyOnUpdate, callback);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			callback(null, outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options, callback) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		if(typeof options === "function") {
/******/ 			callback = options;
/******/ 			options = {};
/******/ 		} else if(options && typeof options === "object") {
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		} else {
/******/ 			options = {};
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function getAffectedStuff(module) {
/******/ 			var outdatedModules = [module];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice();
/******/ 			while(queue.length > 0) {
/******/ 				var moduleId = queue.pop();
/******/ 				var module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return new Error("Aborted because of self decline: " + moduleId);
/******/ 				}
/******/ 				if(moduleId === 0) {
/******/ 					return;
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return new Error("Aborted because of declined dependency: " + moduleId + " in " + parentId);
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push(parentId);
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return [outdatedModules, outdatedDependencies];
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				var moduleId = toModuleId(id);
/******/ 				var result = getAffectedStuff(moduleId);
/******/ 				if(!result) {
/******/ 					if(options.ignoreUnaccepted)
/******/ 						continue;
/******/ 					hotSetStatus("abort");
/******/ 					return callback(new Error("Aborted because " + moduleId + " is not accepted"));
/******/ 				}
/******/ 				if(result instanceof Error) {
/******/ 					hotSetStatus("abort");
/******/ 					return callback(result);
/******/ 				}
/******/ 				appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 				addAllToSet(outdatedModules, result[0]);
/******/ 				for(var moduleId in result[1]) {
/******/ 					if(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {
/******/ 						if(!outdatedDependencies[moduleId])
/******/ 							outdatedDependencies[moduleId] = [];
/******/ 						addAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(var i = 0; i < outdatedModules.length; i++) {
/******/ 			var moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			var moduleId = queue.pop();
/******/ 			var module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(var j = 0; j < disposeHandlers.length; j++) {
/******/ 				var cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(var j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				var idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				for(var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 					var dependency = moduleOutdatedDependencies[j];
/******/ 					var idx = module.children.indexOf(dependency);
/******/ 					if(idx >= 0) module.children.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(var moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				var callbacks = [];
/******/ 				for(var i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 					var dependency = moduleOutdatedDependencies[i];
/******/ 					var cb = module.hot._acceptedDependencies[dependency];
/******/ 					if(callbacks.indexOf(cb) >= 0) continue;
/******/ 					callbacks.push(cb);
/******/ 				}
/******/ 				for(var i = 0; i < callbacks.length; i++) {
/******/ 					var cb = callbacks[i];
/******/ 					try {
/******/ 						cb(outdatedDependencies);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			var moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else if(!error)
/******/ 					error = err;
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return callback(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		callback(null, outdatedModules);
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: hotCurrentParents,
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/static/";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(0)(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(298);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	__webpack_require__(2);
	
	__webpack_require__(293);
	
	__webpack_require__(295);
	
	if (global._babelPolyfill) {
	  throw new Error("only one instance of babel-polyfill is allowed");
	}
	global._babelPolyfill = true;
	
	var DEFINE_PROPERTY = "defineProperty";
	function define(O, key, value) {
	  O[key] || Object[DEFINE_PROPERTY](O, key, {
	    writable: true,
	    configurable: true,
	    value: value
	  });
	}
	
	define(String.prototype, "padLeft", "".padStart);
	define(String.prototype, "padRight", "".padEnd);
	
	"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
	  [][key] && define(Array, key, Function.call.bind([][key]));
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(3);
	__webpack_require__(52);
	__webpack_require__(53);
	__webpack_require__(54);
	__webpack_require__(55);
	__webpack_require__(57);
	__webpack_require__(60);
	__webpack_require__(61);
	__webpack_require__(62);
	__webpack_require__(63);
	__webpack_require__(64);
	__webpack_require__(65);
	__webpack_require__(66);
	__webpack_require__(67);
	__webpack_require__(68);
	__webpack_require__(70);
	__webpack_require__(72);
	__webpack_require__(74);
	__webpack_require__(76);
	__webpack_require__(79);
	__webpack_require__(80);
	__webpack_require__(81);
	__webpack_require__(85);
	__webpack_require__(87);
	__webpack_require__(89);
	__webpack_require__(92);
	__webpack_require__(93);
	__webpack_require__(94);
	__webpack_require__(95);
	__webpack_require__(97);
	__webpack_require__(98);
	__webpack_require__(99);
	__webpack_require__(100);
	__webpack_require__(101);
	__webpack_require__(102);
	__webpack_require__(103);
	__webpack_require__(105);
	__webpack_require__(106);
	__webpack_require__(107);
	__webpack_require__(109);
	__webpack_require__(110);
	__webpack_require__(111);
	__webpack_require__(113);
	__webpack_require__(114);
	__webpack_require__(115);
	__webpack_require__(116);
	__webpack_require__(117);
	__webpack_require__(118);
	__webpack_require__(119);
	__webpack_require__(120);
	__webpack_require__(121);
	__webpack_require__(122);
	__webpack_require__(123);
	__webpack_require__(124);
	__webpack_require__(125);
	__webpack_require__(126);
	__webpack_require__(131);
	__webpack_require__(132);
	__webpack_require__(136);
	__webpack_require__(137);
	__webpack_require__(138);
	__webpack_require__(139);
	__webpack_require__(141);
	__webpack_require__(142);
	__webpack_require__(143);
	__webpack_require__(144);
	__webpack_require__(145);
	__webpack_require__(146);
	__webpack_require__(147);
	__webpack_require__(148);
	__webpack_require__(149);
	__webpack_require__(150);
	__webpack_require__(151);
	__webpack_require__(152);
	__webpack_require__(153);
	__webpack_require__(154);
	__webpack_require__(155);
	__webpack_require__(156);
	__webpack_require__(157);
	__webpack_require__(159);
	__webpack_require__(160);
	__webpack_require__(166);
	__webpack_require__(167);
	__webpack_require__(169);
	__webpack_require__(170);
	__webpack_require__(171);
	__webpack_require__(175);
	__webpack_require__(176);
	__webpack_require__(177);
	__webpack_require__(178);
	__webpack_require__(179);
	__webpack_require__(181);
	__webpack_require__(182);
	__webpack_require__(183);
	__webpack_require__(184);
	__webpack_require__(187);
	__webpack_require__(189);
	__webpack_require__(190);
	__webpack_require__(191);
	__webpack_require__(193);
	__webpack_require__(195);
	__webpack_require__(197);
	__webpack_require__(198);
	__webpack_require__(199);
	__webpack_require__(201);
	__webpack_require__(202);
	__webpack_require__(203);
	__webpack_require__(204);
	__webpack_require__(211);
	__webpack_require__(214);
	__webpack_require__(215);
	__webpack_require__(217);
	__webpack_require__(218);
	__webpack_require__(221);
	__webpack_require__(222);
	__webpack_require__(224);
	__webpack_require__(225);
	__webpack_require__(226);
	__webpack_require__(227);
	__webpack_require__(228);
	__webpack_require__(229);
	__webpack_require__(230);
	__webpack_require__(231);
	__webpack_require__(232);
	__webpack_require__(233);
	__webpack_require__(234);
	__webpack_require__(235);
	__webpack_require__(236);
	__webpack_require__(237);
	__webpack_require__(238);
	__webpack_require__(239);
	__webpack_require__(240);
	__webpack_require__(241);
	__webpack_require__(242);
	__webpack_require__(244);
	__webpack_require__(245);
	__webpack_require__(246);
	__webpack_require__(247);
	__webpack_require__(248);
	__webpack_require__(249);
	__webpack_require__(251);
	__webpack_require__(252);
	__webpack_require__(253);
	__webpack_require__(254);
	__webpack_require__(255);
	__webpack_require__(256);
	__webpack_require__(257);
	__webpack_require__(258);
	__webpack_require__(260);
	__webpack_require__(261);
	__webpack_require__(263);
	__webpack_require__(264);
	__webpack_require__(265);
	__webpack_require__(266);
	__webpack_require__(269);
	__webpack_require__(270);
	__webpack_require__(271);
	__webpack_require__(272);
	__webpack_require__(273);
	__webpack_require__(274);
	__webpack_require__(275);
	__webpack_require__(276);
	__webpack_require__(278);
	__webpack_require__(279);
	__webpack_require__(280);
	__webpack_require__(281);
	__webpack_require__(282);
	__webpack_require__(283);
	__webpack_require__(284);
	__webpack_require__(285);
	__webpack_require__(286);
	__webpack_require__(287);
	__webpack_require__(288);
	__webpack_require__(291);
	__webpack_require__(292);
	module.exports = __webpack_require__(9);

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(4)
	  , has            = __webpack_require__(5)
	  , DESCRIPTORS    = __webpack_require__(6)
	  , $export        = __webpack_require__(8)
	  , redefine       = __webpack_require__(18)
	  , META           = __webpack_require__(22).KEY
	  , $fails         = __webpack_require__(7)
	  , shared         = __webpack_require__(23)
	  , setToStringTag = __webpack_require__(24)
	  , uid            = __webpack_require__(19)
	  , wks            = __webpack_require__(25)
	  , wksExt         = __webpack_require__(26)
	  , wksDefine      = __webpack_require__(27)
	  , keyOf          = __webpack_require__(29)
	  , enumKeys       = __webpack_require__(42)
	  , isArray        = __webpack_require__(45)
	  , anObject       = __webpack_require__(12)
	  , toIObject      = __webpack_require__(32)
	  , toPrimitive    = __webpack_require__(16)
	  , createDesc     = __webpack_require__(17)
	  , _create        = __webpack_require__(46)
	  , gOPNExt        = __webpack_require__(49)
	  , $GOPD          = __webpack_require__(51)
	  , $DP            = __webpack_require__(11)
	  , $keys          = __webpack_require__(30)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(50).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(44).f  = $propertyIsEnumerable;
	  __webpack_require__(43).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(28)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(10)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 4 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 5 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(7)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(4)
	  , core      = __webpack_require__(9)
	  , hide      = __webpack_require__(10)
	  , redefine  = __webpack_require__(18)
	  , ctx       = __webpack_require__(20)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
	    , key, own, out, exp;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if(target)redefine(target, key, out, type & $export.U);
	    // export
	    if(exports[key] != out)hide(exports, key, exp);
	    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 9 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(11)
	  , createDesc = __webpack_require__(17);
	module.exports = __webpack_require__(6) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(12)
	  , IE8_DOM_DEFINE = __webpack_require__(14)
	  , toPrimitive    = __webpack_require__(16)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(6) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 13 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(6) && !__webpack_require__(7)(function(){
	  return Object.defineProperty(__webpack_require__(15)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13)
	  , document = __webpack_require__(4).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(13);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(4)
	  , hide      = __webpack_require__(10)
	  , has       = __webpack_require__(5)
	  , SRC       = __webpack_require__(19)('src')
	  , TO_STRING = 'toString'
	  , $toString = Function[TO_STRING]
	  , TPL       = ('' + $toString).split(TO_STRING);
	
	__webpack_require__(9).inspectSource = function(it){
	  return $toString.call(it);
	};
	
	(module.exports = function(O, key, val, safe){
	  var isFunction = typeof val == 'function';
	  if(isFunction)has(val, 'name') || hide(val, 'name', key);
	  if(O[key] === val)return;
	  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if(O === global){
	    O[key] = val;
	  } else {
	    if(!safe){
	      delete O[key];
	      hide(O, key, val);
	    } else {
	      if(O[key])O[key] = val;
	      else hide(O, key, val);
	    }
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString(){
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});

/***/ },
/* 19 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(21);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(19)('meta')
	  , isObject = __webpack_require__(13)
	  , has      = __webpack_require__(5)
	  , setDesc  = __webpack_require__(11).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(7)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(4)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(11).f
	  , has = __webpack_require__(5)
	  , TAG = __webpack_require__(25)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(23)('wks')
	  , uid        = __webpack_require__(19)
	  , Symbol     = __webpack_require__(4).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(25);

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(4)
	  , core           = __webpack_require__(9)
	  , LIBRARY        = __webpack_require__(28)
	  , wksExt         = __webpack_require__(26)
	  , defineProperty = __webpack_require__(11).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = false;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(30)
	  , toIObject = __webpack_require__(32);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(31)
	  , enumBugKeys = __webpack_require__(41);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(5)
	  , toIObject    = __webpack_require__(32)
	  , arrayIndexOf = __webpack_require__(36)(false)
	  , IE_PROTO     = __webpack_require__(40)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(33)
	  , defined = __webpack_require__(35);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(34);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 34 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 35 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(32)
	  , toLength  = __webpack_require__(37)
	  , toIndex   = __webpack_require__(39);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(38)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 38 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(38)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(23)('keys')
	  , uid    = __webpack_require__(19);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 41 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(30)
	  , gOPS    = __webpack_require__(43)
	  , pIE     = __webpack_require__(44);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 43 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 44 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(34);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(12)
	  , dPs         = __webpack_require__(47)
	  , enumBugKeys = __webpack_require__(41)
	  , IE_PROTO    = __webpack_require__(40)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(15)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(48).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(11)
	  , anObject = __webpack_require__(12)
	  , getKeys  = __webpack_require__(30);
	
	module.exports = __webpack_require__(6) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(4).document && document.documentElement;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(32)
	  , gOPN      = __webpack_require__(50).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(31)
	  , hiddenKeys = __webpack_require__(41).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(44)
	  , createDesc     = __webpack_require__(17)
	  , toIObject      = __webpack_require__(32)
	  , toPrimitive    = __webpack_require__(16)
	  , has            = __webpack_require__(5)
	  , IE8_DOM_DEFINE = __webpack_require__(14)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(6) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(46)});

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(6), 'Object', {defineProperty: __webpack_require__(11).f});

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	$export($export.S + $export.F * !__webpack_require__(6), 'Object', {defineProperties: __webpack_require__(47)});

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject                 = __webpack_require__(32)
	  , $getOwnPropertyDescriptor = __webpack_require__(51).f;
	
	__webpack_require__(56)('getOwnPropertyDescriptor', function(){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(8)
	  , core    = __webpack_require__(9)
	  , fails   = __webpack_require__(7);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(58)
	  , $getPrototypeOf = __webpack_require__(59);
	
	__webpack_require__(56)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(35);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(5)
	  , toObject    = __webpack_require__(58)
	  , IE_PROTO    = __webpack_require__(40)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(58)
	  , $keys    = __webpack_require__(30);
	
	__webpack_require__(56)('keys', function(){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(56)('getOwnPropertyNames', function(){
	  return __webpack_require__(49).f;
	});

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(13)
	  , meta     = __webpack_require__(22).onFreeze;
	
	__webpack_require__(56)('freeze', function($freeze){
	  return function freeze(it){
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(13)
	  , meta     = __webpack_require__(22).onFreeze;
	
	__webpack_require__(56)('seal', function($seal){
	  return function seal(it){
	    return $seal && isObject(it) ? $seal(meta(it)) : it;
	  };
	});

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.15 Object.preventExtensions(O)
	var isObject = __webpack_require__(13)
	  , meta     = __webpack_require__(22).onFreeze;
	
	__webpack_require__(56)('preventExtensions', function($preventExtensions){
	  return function preventExtensions(it){
	    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
	  };
	});

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.12 Object.isFrozen(O)
	var isObject = __webpack_require__(13);
	
	__webpack_require__(56)('isFrozen', function($isFrozen){
	  return function isFrozen(it){
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.13 Object.isSealed(O)
	var isObject = __webpack_require__(13);
	
	__webpack_require__(56)('isSealed', function($isSealed){
	  return function isSealed(it){
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.11 Object.isExtensible(O)
	var isObject = __webpack_require__(13);
	
	__webpack_require__(56)('isExtensible', function($isExtensible){
	  return function isExtensible(it){
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(8);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(69)});

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(30)
	  , gOPS     = __webpack_require__(43)
	  , pIE      = __webpack_require__(44)
	  , toObject = __webpack_require__(58)
	  , IObject  = __webpack_require__(33)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(7)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.10 Object.is(value1, value2)
	var $export = __webpack_require__(8);
	$export($export.S, 'Object', {is: __webpack_require__(71)});

/***/ },
/* 71 */
/***/ function(module, exports) {

	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y){
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(8);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(73).set});

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(13)
	  , anObject = __webpack_require__(12);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(20)(Function.call, __webpack_require__(51).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(75)
	  , test    = {};
	test[__webpack_require__(25)('toStringTag')] = 'z';
	if(test + '' != '[object z]'){
	  __webpack_require__(18)(Object.prototype, 'toString', function toString(){
	    return '[object ' + classof(this) + ']';
	  }, true);
	}

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(34)
	  , TAG = __webpack_require__(25)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
	var $export = __webpack_require__(8);
	
	$export($export.P, 'Function', {bind: __webpack_require__(77)});

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var aFunction  = __webpack_require__(21)
	  , isObject   = __webpack_require__(13)
	  , invoke     = __webpack_require__(78)
	  , arraySlice = [].slice
	  , factories  = {};
	
	var construct = function(F, len, args){
	  if(!(len in factories)){
	    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  } return factories[len](F, args);
	};
	
	module.exports = Function.bind || function bind(that /*, args... */){
	  var fn       = aFunction(this)
	    , partArgs = arraySlice.call(arguments, 1);
	  var bound = function(/* args... */){
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	  };
	  if(isObject(fn.prototype))bound.prototype = fn.prototype;
	  return bound;
	};

/***/ },
/* 78 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(11).f
	  , createDesc = __webpack_require__(17)
	  , has        = __webpack_require__(5)
	  , FProto     = Function.prototype
	  , nameRE     = /^\s*function ([^ (]*)/
	  , NAME       = 'name';
	
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	
	// 19.2.4.2 name
	NAME in FProto || __webpack_require__(6) && dP(FProto, NAME, {
	  configurable: true,
	  get: function(){
	    try {
	      var that = this
	        , name = ('' + that).match(nameRE)[1];
	      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
	      return name;
	    } catch(e){
	      return '';
	    }
	  }
	});

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var isObject       = __webpack_require__(13)
	  , getPrototypeOf = __webpack_require__(59)
	  , HAS_INSTANCE   = __webpack_require__(25)('hasInstance')
	  , FunctionProto  = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if(!(HAS_INSTANCE in FunctionProto))__webpack_require__(11).f(FunctionProto, HAS_INSTANCE, {value: function(O){
	  if(typeof this != 'function' || !isObject(O))return false;
	  if(!isObject(this.prototype))return O instanceof this;
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while(O = getPrototypeOf(O))if(this.prototype === O)return true;
	  return false;
	}});

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(8)
	  , $parseInt = __webpack_require__(82);
	// 18.2.5 parseInt(string, radix)
	$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var $parseInt = __webpack_require__(4).parseInt
	  , $trim     = __webpack_require__(83).trim
	  , ws        = __webpack_require__(84)
	  , hex       = /^[\-+]?0[xX]/;
	
	module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){
	  var string = $trim(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	  , defined = __webpack_require__(35)
	  , fails   = __webpack_require__(7)
	  , spaces  = __webpack_require__(84)
	  , space   = '[' + spaces + ']'
	  , non     = '\u200b\u0085'
	  , ltrim   = RegExp('^' + space + space + '*')
	  , rtrim   = RegExp(space + space + '*$');
	
	var exporter = function(KEY, exec, ALIAS){
	  var exp   = {};
	  var FORCE = fails(function(){
	    return !!spaces[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
	  if(ALIAS)exp[ALIAS] = fn;
	  $export($export.P + $export.F * FORCE, 'String', exp);
	};
	
	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function(string, TYPE){
	  string = String(defined(string));
	  if(TYPE & 1)string = string.replace(ltrim, '');
	  if(TYPE & 2)string = string.replace(rtrim, '');
	  return string;
	};
	
	module.exports = exporter;

/***/ },
/* 84 */
/***/ function(module, exports) {

	module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(8)
	  , $parseFloat = __webpack_require__(86);
	// 18.2.4 parseFloat(string)
	$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var $parseFloat = __webpack_require__(4).parseFloat
	  , $trim       = __webpack_require__(83).trim;
	
	module.exports = 1 / $parseFloat(__webpack_require__(84) + '-0') !== -Infinity ? function parseFloat(str){
	  var string = $trim(String(str), 3)
	    , result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(4)
	  , has               = __webpack_require__(5)
	  , cof               = __webpack_require__(34)
	  , inheritIfRequired = __webpack_require__(88)
	  , toPrimitive       = __webpack_require__(16)
	  , fails             = __webpack_require__(7)
	  , gOPN              = __webpack_require__(50).f
	  , gOPD              = __webpack_require__(51).f
	  , dP                = __webpack_require__(11).f
	  , $trim             = __webpack_require__(83).trim
	  , NUMBER            = 'Number'
	  , $Number           = global[NUMBER]
	  , Base              = $Number
	  , proto             = $Number.prototype
	  // Opera ~12 has broken Object#toString
	  , BROKEN_COF        = cof(__webpack_require__(46)(proto)) == NUMBER
	  , TRIM              = 'trim' in String.prototype;
	
	// 7.1.3 ToNumber(argument)
	var toNumber = function(argument){
	  var it = toPrimitive(argument, false);
	  if(typeof it == 'string' && it.length > 2){
	    it = TRIM ? it.trim() : $trim(it, 3);
	    var first = it.charCodeAt(0)
	      , third, radix, maxCode;
	    if(first === 43 || first === 45){
	      third = it.charCodeAt(2);
	      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if(first === 48){
	      switch(it.charCodeAt(1)){
	        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
	        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
	        default : return +it;
	      }
	      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if(code < 48 || code > maxCode)return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};
	
	if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
	  $Number = function Number(value){
	    var it = arguments.length < 1 ? 0 : value
	      , that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
	        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for(var keys = __webpack_require__(6) ? gOPN(Base) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j = 0, key; keys.length > j; j++){
	    if(has(Base, key = keys[j]) && !has($Number, key)){
	      dP($Number, key, gOPD(Base, key));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  __webpack_require__(18)(global, NUMBER, $Number);
	}

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var isObject       = __webpack_require__(13)
	  , setPrototypeOf = __webpack_require__(73).set;
	module.exports = function(that, target, C){
	  var P, S = target.constructor;
	  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
	    setPrototypeOf(that, P);
	  } return that;
	};

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(8)
	  , toInteger    = __webpack_require__(38)
	  , aNumberValue = __webpack_require__(90)
	  , repeat       = __webpack_require__(91)
	  , $toFixed     = 1..toFixed
	  , floor        = Math.floor
	  , data         = [0, 0, 0, 0, 0, 0]
	  , ERROR        = 'Number.toFixed: incorrect invocation!'
	  , ZERO         = '0';
	
	var multiply = function(n, c){
	  var i  = -1
	    , c2 = c;
	  while(++i < 6){
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor(c2 / 1e7);
	  }
	};
	var divide = function(n){
	  var i = 6
	    , c = 0;
	  while(--i >= 0){
	    c += data[i];
	    data[i] = floor(c / n);
	    c = (c % n) * 1e7;
	  }
	};
	var numToString = function(){
	  var i = 6
	    , s = '';
	  while(--i >= 0){
	    if(s !== '' || i === 0 || data[i] !== 0){
	      var t = String(data[i]);
	      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	    }
	  } return s;
	};
	var pow = function(x, n, acc){
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function(x){
	  var n  = 0
	    , x2 = x;
	  while(x2 >= 4096){
	    n += 12;
	    x2 /= 4096;
	  }
	  while(x2 >= 2){
	    n  += 1;
	    x2 /= 2;
	  } return n;
	};
	
	$export($export.P + $export.F * (!!$toFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128..toFixed(0) !== '1000000000000000128'
	) || !__webpack_require__(7)(function(){
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits){
	    var x = aNumberValue(this, ERROR)
	      , f = toInteger(fractionDigits)
	      , s = ''
	      , m = ZERO
	      , e, z, j, k;
	    if(f < 0 || f > 20)throw RangeError(ERROR);
	    if(x != x)return 'NaN';
	    if(x <= -1e21 || x >= 1e21)return String(x);
	    if(x < 0){
	      s = '-';
	      x = -x;
	    }
	    if(x > 1e-21){
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if(e > 0){
	        multiply(0, z);
	        j = f;
	        while(j >= 7){
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while(j >= 23){
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + repeat.call(ZERO, f);
	      }
	    }
	    if(f > 0){
	      k = m.length;
	      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    } return m;
	  }
	});

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var cof = __webpack_require__(34);
	module.exports = function(it, msg){
	  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);
	  return +it;
	};

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var toInteger = __webpack_require__(38)
	  , defined   = __webpack_require__(35);
	
	module.exports = function repeat(count){
	  var str = String(defined(this))
	    , res = ''
	    , n   = toInteger(count);
	  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
	  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
	  return res;
	};

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(8)
	  , $fails       = __webpack_require__(7)
	  , aNumberValue = __webpack_require__(90)
	  , $toPrecision = 1..toPrecision;
	
	$export($export.P + $export.F * ($fails(function(){
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !$fails(function(){
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision){
	    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); 
	  }
	});

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.1 Number.EPSILON
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.2 Number.isFinite(number)
	var $export   = __webpack_require__(8)
	  , _isFinite = __webpack_require__(4).isFinite;
	
	$export($export.S, 'Number', {
	  isFinite: function isFinite(it){
	    return typeof it == 'number' && _isFinite(it);
	  }
	});

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {isInteger: __webpack_require__(96)});

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(13)
	  , floor    = Math.floor;
	module.exports = function isInteger(it){
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.4 Number.isNaN(number)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {
	  isNaN: function isNaN(number){
	    return number != number;
	  }
	});

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.5 Number.isSafeInteger(number)
	var $export   = __webpack_require__(8)
	  , isInteger = __webpack_require__(96)
	  , abs       = Math.abs;
	
	$export($export.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number){
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.6 Number.MAX_SAFE_INTEGER
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.10 Number.MIN_SAFE_INTEGER
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(8)
	  , $parseFloat = __webpack_require__(86);
	// 20.1.2.12 Number.parseFloat(string)
	$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(8)
	  , $parseInt = __webpack_require__(82);
	// 20.1.2.13 Number.parseInt(string, radix)
	$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.3 Math.acosh(x)
	var $export = __webpack_require__(8)
	  , log1p   = __webpack_require__(104)
	  , sqrt    = Math.sqrt
	  , $acosh  = Math.acosh;
	
	$export($export.S + $export.F * !($acosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  && Math.floor($acosh(Number.MAX_VALUE)) == 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN 
	  && $acosh(Infinity) == Infinity
	), 'Math', {
	  acosh: function acosh(x){
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? Math.log(x) + Math.LN2
	      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

/***/ },
/* 104 */
/***/ function(module, exports) {

	// 20.2.2.20 Math.log1p(x)
	module.exports = Math.log1p || function log1p(x){
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.5 Math.asinh(x)
	var $export = __webpack_require__(8)
	  , $asinh  = Math.asinh;
	
	function asinh(x){
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}
	
	// Tor Browser bug: Math.asinh(0) -> -0 
	$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.7 Math.atanh(x)
	var $export = __webpack_require__(8)
	  , $atanh  = Math.atanh;
	
	// Tor Browser bug: Math.atanh(-0) -> 0 
	$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x){
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.9 Math.cbrt(x)
	var $export = __webpack_require__(8)
	  , sign    = __webpack_require__(108);
	
	$export($export.S, 'Math', {
	  cbrt: function cbrt(x){
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});

/***/ },
/* 108 */
/***/ function(module, exports) {

	// 20.2.2.28 Math.sign(x)
	module.exports = Math.sign || function sign(x){
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.11 Math.clz32(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  clz32: function clz32(x){
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.12 Math.cosh(x)
	var $export = __webpack_require__(8)
	  , exp     = Math.exp;
	
	$export($export.S, 'Math', {
	  cosh: function cosh(x){
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.14 Math.expm1(x)
	var $export = __webpack_require__(8)
	  , $expm1  = __webpack_require__(112);
	
	$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});

/***/ },
/* 112 */
/***/ function(module, exports) {

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	module.exports = (!$expm1
	  // Old FF bug
	  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || $expm1(-2e-17) != -2e-17
	) ? function expm1(x){
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var $export   = __webpack_require__(8)
	  , sign      = __webpack_require__(108)
	  , pow       = Math.pow
	  , EPSILON   = pow(2, -52)
	  , EPSILON32 = pow(2, -23)
	  , MAX32     = pow(2, 127) * (2 - EPSILON32)
	  , MIN32     = pow(2, -126);
	
	var roundTiesToEven = function(n){
	  return n + 1 / EPSILON - 1 / EPSILON;
	};
	
	
	$export($export.S, 'Math', {
	  fround: function fround(x){
	    var $abs  = Math.abs(x)
	      , $sign = sign(x)
	      , a, result;
	    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	    a = (1 + EPSILON32 / EPSILON) * $abs;
	    result = a - (a - $abs);
	    if(result > MAX32 || result != result)return $sign * Infinity;
	    return $sign * result;
	  }
	});

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
	var $export = __webpack_require__(8)
	  , abs     = Math.abs;
	
	$export($export.S, 'Math', {
	  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
	    var sum  = 0
	      , i    = 0
	      , aLen = arguments.length
	      , larg = 0
	      , arg, div;
	    while(i < aLen){
	      arg = abs(arguments[i++]);
	      if(larg < arg){
	        div  = larg / arg;
	        sum  = sum * div * div + 1;
	        larg = arg;
	      } else if(arg > 0){
	        div  = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.18 Math.imul(x, y)
	var $export = __webpack_require__(8)
	  , $imul   = Math.imul;
	
	// some WebKit versions fails with big numbers, some has wrong arity
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y){
	    var UINT16 = 0xffff
	      , xn = +x
	      , yn = +y
	      , xl = UINT16 & xn
	      , yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.21 Math.log10(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  log10: function log10(x){
	    return Math.log(x) / Math.LN10;
	  }
	});

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.20 Math.log1p(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {log1p: __webpack_require__(104)});

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.22 Math.log2(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  log2: function log2(x){
	    return Math.log(x) / Math.LN2;
	  }
	});

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.28 Math.sign(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {sign: __webpack_require__(108)});

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.30 Math.sinh(x)
	var $export = __webpack_require__(8)
	  , expm1   = __webpack_require__(112)
	  , exp     = Math.exp;
	
	// V8 near Chromium 38 has a problem with very small numbers
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x){
	    return Math.abs(x = +x) < 1
	      ? (expm1(x) - expm1(-x)) / 2
	      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
	  }
	});

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.33 Math.tanh(x)
	var $export = __webpack_require__(8)
	  , expm1   = __webpack_require__(112)
	  , exp     = Math.exp;
	
	$export($export.S, 'Math', {
	  tanh: function tanh(x){
	    var a = expm1(x = +x)
	      , b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.34 Math.trunc(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  trunc: function trunc(it){
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var $export        = __webpack_require__(8)
	  , toIndex        = __webpack_require__(39)
	  , fromCharCode   = String.fromCharCode
	  , $fromCodePoint = String.fromCodePoint;
	
	// length should be 1, old FF problem
	$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
	    var res  = []
	      , aLen = arguments.length
	      , i    = 0
	      , code;
	    while(aLen > i){
	      code = +arguments[i++];
	      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(8)
	  , toIObject = __webpack_require__(32)
	  , toLength  = __webpack_require__(37);
	
	$export($export.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite){
	    var tpl  = toIObject(callSite.raw)
	      , len  = toLength(tpl.length)
	      , aLen = arguments.length
	      , res  = []
	      , i    = 0;
	    while(len > i){
	      res.push(String(tpl[i++]));
	      if(i < aLen)res.push(String(arguments[i]));
	    } return res.join('');
	  }
	});

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.1.3.25 String.prototype.trim()
	__webpack_require__(83)('trim', function($trim){
	  return function trim(){
	    return $trim(this, 3);
	  };
	});

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(127)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(128)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(38)
	  , defined   = __webpack_require__(35);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(28)
	  , $export        = __webpack_require__(8)
	  , redefine       = __webpack_require__(18)
	  , hide           = __webpack_require__(10)
	  , has            = __webpack_require__(5)
	  , Iterators      = __webpack_require__(129)
	  , $iterCreate    = __webpack_require__(130)
	  , setToStringTag = __webpack_require__(24)
	  , getPrototypeOf = __webpack_require__(59)
	  , ITERATOR       = __webpack_require__(25)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 129 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(46)
	  , descriptor     = __webpack_require__(17)
	  , setToStringTag = __webpack_require__(24)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(10)(IteratorPrototype, __webpack_require__(25)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $at     = __webpack_require__(127)(false);
	$export($export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
	'use strict';
	var $export   = __webpack_require__(8)
	  , toLength  = __webpack_require__(37)
	  , context   = __webpack_require__(133)
	  , ENDS_WITH = 'endsWith'
	  , $endsWith = ''[ENDS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(135)(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /*, endPosition = @length */){
	    var that = context(this, searchString, ENDS_WITH)
	      , endPosition = arguments.length > 1 ? arguments[1] : undefined
	      , len    = toLength(that.length)
	      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
	      , search = String(searchString);
	    return $endsWith
	      ? $endsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	// helper for String#{startsWith, endsWith, includes}
	var isRegExp = __webpack_require__(134)
	  , defined  = __webpack_require__(35);
	
	module.exports = function(that, searchString, NAME){
	  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.8 IsRegExp(argument)
	var isObject = __webpack_require__(13)
	  , cof      = __webpack_require__(34)
	  , MATCH    = __webpack_require__(25)('match');
	module.exports = function(it){
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
	};

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var MATCH = __webpack_require__(25)('match');
	module.exports = function(KEY){
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch(e){
	    try {
	      re[MATCH] = false;
	      return !'/./'[KEY](re);
	    } catch(f){ /* empty */ }
	  } return true;
	};

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.7 String.prototype.includes(searchString, position = 0)
	'use strict';
	var $export  = __webpack_require__(8)
	  , context  = __webpack_require__(133)
	  , INCLUDES = 'includes';
	
	$export($export.P + $export.F * __webpack_require__(135)(INCLUDES), 'String', {
	  includes: function includes(searchString /*, position = 0 */){
	    return !!~context(this, searchString, INCLUDES)
	      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	
	$export($export.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: __webpack_require__(91)
	});

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
	'use strict';
	var $export     = __webpack_require__(8)
	  , toLength    = __webpack_require__(37)
	  , context     = __webpack_require__(133)
	  , STARTS_WITH = 'startsWith'
	  , $startsWith = ''[STARTS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(135)(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /*, position = 0 */){
	    var that   = context(this, searchString, STARTS_WITH)
	      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
	      , search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.2 String.prototype.anchor(name)
	__webpack_require__(140)('anchor', function(createHTML){
	  return function anchor(name){
	    return createHTML(this, 'a', 'name', name);
	  }
	});

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	  , fails   = __webpack_require__(7)
	  , defined = __webpack_require__(35)
	  , quot    = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function(string, tag, attribute, value) {
	  var S  = String(defined(string))
	    , p1 = '<' + tag;
	  if(attribute !== '')p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};
	module.exports = function(NAME, exec){
	  var O = {};
	  O[NAME] = exec(createHTML);
	  $export($export.P + $export.F * fails(function(){
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.3 String.prototype.big()
	__webpack_require__(140)('big', function(createHTML){
	  return function big(){
	    return createHTML(this, 'big', '', '');
	  }
	});

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.4 String.prototype.blink()
	__webpack_require__(140)('blink', function(createHTML){
	  return function blink(){
	    return createHTML(this, 'blink', '', '');
	  }
	});

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.5 String.prototype.bold()
	__webpack_require__(140)('bold', function(createHTML){
	  return function bold(){
	    return createHTML(this, 'b', '', '');
	  }
	});

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.6 String.prototype.fixed()
	__webpack_require__(140)('fixed', function(createHTML){
	  return function fixed(){
	    return createHTML(this, 'tt', '', '');
	  }
	});

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.7 String.prototype.fontcolor(color)
	__webpack_require__(140)('fontcolor', function(createHTML){
	  return function fontcolor(color){
	    return createHTML(this, 'font', 'color', color);
	  }
	});

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.8 String.prototype.fontsize(size)
	__webpack_require__(140)('fontsize', function(createHTML){
	  return function fontsize(size){
	    return createHTML(this, 'font', 'size', size);
	  }
	});

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.9 String.prototype.italics()
	__webpack_require__(140)('italics', function(createHTML){
	  return function italics(){
	    return createHTML(this, 'i', '', '');
	  }
	});

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.10 String.prototype.link(url)
	__webpack_require__(140)('link', function(createHTML){
	  return function link(url){
	    return createHTML(this, 'a', 'href', url);
	  }
	});

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.11 String.prototype.small()
	__webpack_require__(140)('small', function(createHTML){
	  return function small(){
	    return createHTML(this, 'small', '', '');
	  }
	});

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.12 String.prototype.strike()
	__webpack_require__(140)('strike', function(createHTML){
	  return function strike(){
	    return createHTML(this, 'strike', '', '');
	  }
	});

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.13 String.prototype.sub()
	__webpack_require__(140)('sub', function(createHTML){
	  return function sub(){
	    return createHTML(this, 'sub', '', '');
	  }
	});

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.14 String.prototype.sup()
	__webpack_require__(140)('sup', function(createHTML){
	  return function sup(){
	    return createHTML(this, 'sup', '', '');
	  }
	});

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	// 20.3.3.1 / 15.9.4.4 Date.now()
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export     = __webpack_require__(8)
	  , toObject    = __webpack_require__(58)
	  , toPrimitive = __webpack_require__(16);
	
	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	var $export = __webpack_require__(8)
	  , fails   = __webpack_require__(7)
	  , getTime = Date.prototype.getTime;
	
	var lz = function(num){
	  return num > 9 ? num : '0' + num;
	};
	
	// PhantomJS / old WebKit has a broken implementations
	$export($export.P + $export.F * (fails(function(){
	  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
	}) || !fails(function(){
	  new Date(NaN).toISOString();
	})), 'Date', {
	  toISOString: function toISOString(){
	    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');
	    var d = this
	      , y = d.getUTCFullYear()
	      , m = d.getUTCMilliseconds()
	      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
	    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	  }
	});

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var DateProto    = Date.prototype
	  , INVALID_DATE = 'Invalid Date'
	  , TO_STRING    = 'toString'
	  , $toString    = DateProto[TO_STRING]
	  , getTime      = DateProto.getTime;
	if(new Date(NaN) + '' != INVALID_DATE){
	  __webpack_require__(18)(DateProto, TO_STRING, function toString(){
	    var value = getTime.call(this);
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var TO_PRIMITIVE = __webpack_require__(25)('toPrimitive')
	  , proto        = Date.prototype;
	
	if(!(TO_PRIMITIVE in proto))__webpack_require__(10)(proto, TO_PRIMITIVE, __webpack_require__(158));

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var anObject    = __webpack_require__(12)
	  , toPrimitive = __webpack_require__(16)
	  , NUMBER      = 'number';
	
	module.exports = function(hint){
	  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');
	  return toPrimitive(anObject(this), hint != NUMBER);
	};

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Array', {isArray: __webpack_require__(45)});

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(20)
	  , $export        = __webpack_require__(8)
	  , toObject       = __webpack_require__(58)
	  , call           = __webpack_require__(161)
	  , isArrayIter    = __webpack_require__(162)
	  , toLength       = __webpack_require__(37)
	  , createProperty = __webpack_require__(163)
	  , getIterFn      = __webpack_require__(164);
	
	$export($export.S + $export.F * !__webpack_require__(165)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(12);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(129)
	  , ITERATOR   = __webpack_require__(25)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(11)
	  , createDesc      = __webpack_require__(17);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(75)
	  , ITERATOR  = __webpack_require__(25)('iterator')
	  , Iterators = __webpack_require__(129);
	module.exports = __webpack_require__(9).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(25)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export        = __webpack_require__(8)
	  , createProperty = __webpack_require__(163);
	
	// WebKit Array.of isn't generic
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  function F(){}
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */){
	    var index  = 0
	      , aLen   = arguments.length
	      , result = new (typeof this == 'function' ? this : Array)(aLen);
	    while(aLen > index)createProperty(result, index, arguments[index++]);
	    result.length = aLen;
	    return result;
	  }
	});

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.13 Array.prototype.join(separator)
	var $export   = __webpack_require__(8)
	  , toIObject = __webpack_require__(32)
	  , arrayJoin = [].join;
	
	// fallback for not array-like strings
	$export($export.P + $export.F * (__webpack_require__(33) != Object || !__webpack_require__(168)(arrayJoin)), 'Array', {
	  join: function join(separator){
	    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
	  }
	});

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	var fails = __webpack_require__(7);
	
	module.exports = function(method, arg){
	  return !!method && fails(function(){
	    arg ? method.call(null, function(){}, 1) : method.call(null);
	  });
	};

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export    = __webpack_require__(8)
	  , html       = __webpack_require__(48)
	  , cof        = __webpack_require__(34)
	  , toIndex    = __webpack_require__(39)
	  , toLength   = __webpack_require__(37)
	  , arraySlice = [].slice;
	
	// fallback for not array-like ES3 strings and DOM objects
	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  if(html)arraySlice.call(html);
	}), 'Array', {
	  slice: function slice(begin, end){
	    var len   = toLength(this.length)
	      , klass = cof(this);
	    end = end === undefined ? len : end;
	    if(klass == 'Array')return arraySlice.call(this, begin, end);
	    var start  = toIndex(begin, len)
	      , upTo   = toIndex(end, len)
	      , size   = toLength(upTo - start)
	      , cloned = Array(size)
	      , i      = 0;
	    for(; i < size; i++)cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i];
	    return cloned;
	  }
	});

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export   = __webpack_require__(8)
	  , aFunction = __webpack_require__(21)
	  , toObject  = __webpack_require__(58)
	  , fails     = __webpack_require__(7)
	  , $sort     = [].sort
	  , test      = [1, 2, 3];
	
	$export($export.P + $export.F * (fails(function(){
	  // IE8-
	  test.sort(undefined);
	}) || !fails(function(){
	  // V8 bug
	  test.sort(null);
	  // Old WebKit
	}) || !__webpack_require__(168)($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn){
	    return comparefn === undefined
	      ? $sort.call(toObject(this))
	      : $sort.call(toObject(this), aFunction(comparefn));
	  }
	});

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export  = __webpack_require__(8)
	  , $forEach = __webpack_require__(172)(0)
	  , STRICT   = __webpack_require__(168)([].forEach, true);
	
	$export($export.P + $export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */){
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(20)
	  , IObject  = __webpack_require__(33)
	  , toObject = __webpack_require__(58)
	  , toLength = __webpack_require__(37)
	  , asc      = __webpack_require__(173);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(174);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13)
	  , isArray  = __webpack_require__(45)
	  , SPECIES  = __webpack_require__(25)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $map    = __webpack_require__(172)(1);
	
	$export($export.P + $export.F * !__webpack_require__(168)([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */){
	    return $map(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $filter = __webpack_require__(172)(2);
	
	$export($export.P + $export.F * !__webpack_require__(168)([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */){
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $some   = __webpack_require__(172)(3);
	
	$export($export.P + $export.F * !__webpack_require__(168)([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */){
	    return $some(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $every  = __webpack_require__(172)(4);
	
	$export($export.P + $export.F * !__webpack_require__(168)([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */){
	    return $every(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $reduce = __webpack_require__(180);
	
	$export($export.P + $export.F * !__webpack_require__(168)([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	var aFunction = __webpack_require__(21)
	  , toObject  = __webpack_require__(58)
	  , IObject   = __webpack_require__(33)
	  , toLength  = __webpack_require__(37);
	
	module.exports = function(that, callbackfn, aLen, memo, isRight){
	  aFunction(callbackfn);
	  var O      = toObject(that)
	    , self   = IObject(O)
	    , length = toLength(O.length)
	    , index  = isRight ? length - 1 : 0
	    , i      = isRight ? -1 : 1;
	  if(aLen < 2)for(;;){
	    if(index in self){
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if(isRight ? index < 0 : length <= index){
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
	    memo = callbackfn(memo, self[index], index, O);
	  }
	  return memo;
	};

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $reduce = __webpack_require__(180);
	
	$export($export.P + $export.F * !__webpack_require__(168)([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(8)
	  , $indexOf      = __webpack_require__(36)(false)
	  , $native       = [].indexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(168)($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? $native.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments[1]);
	  }
	});

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(8)
	  , toIObject     = __webpack_require__(32)
	  , toInteger     = __webpack_require__(38)
	  , toLength      = __webpack_require__(37)
	  , $native       = [].lastIndexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(168)($native)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){
	    // convert -0 to +0
	    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;
	    var O      = toIObject(this)
	      , length = toLength(O.length)
	      , index  = length - 1;
	    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));
	    if(index < 0)index = length + index;
	    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;
	    return -1;
	  }
	});

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	var $export = __webpack_require__(8);
	
	$export($export.P, 'Array', {copyWithin: __webpack_require__(185)});
	
	__webpack_require__(186)('copyWithin');

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	'use strict';
	var toObject = __webpack_require__(58)
	  , toIndex  = __webpack_require__(39)
	  , toLength = __webpack_require__(37);
	
	module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
	  var O     = toObject(this)
	    , len   = toLength(O.length)
	    , to    = toIndex(target, len)
	    , from  = toIndex(start, len)
	    , end   = arguments.length > 2 ? arguments[2] : undefined
	    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
	    , inc   = 1;
	  if(from < to && to < from + count){
	    inc  = -1;
	    from += count - 1;
	    to   += count - 1;
	  }
	  while(count-- > 0){
	    if(from in O)O[to] = O[from];
	    else delete O[to];
	    to   += inc;
	    from += inc;
	  } return O;
	};

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(25)('unscopables')
	  , ArrayProto  = Array.prototype;
	if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(10)(ArrayProto, UNSCOPABLES, {});
	module.exports = function(key){
	  ArrayProto[UNSCOPABLES][key] = true;
	};

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	var $export = __webpack_require__(8);
	
	$export($export.P, 'Array', {fill: __webpack_require__(188)});
	
	__webpack_require__(186)('fill');

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	'use strict';
	var toObject = __webpack_require__(58)
	  , toIndex  = __webpack_require__(39)
	  , toLength = __webpack_require__(37);
	module.exports = function fill(value /*, start = 0, end = @length */){
	  var O      = toObject(this)
	    , length = toLength(O.length)
	    , aLen   = arguments.length
	    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
	    , end    = aLen > 2 ? arguments[2] : undefined
	    , endPos = end === undefined ? length : toIndex(end, length);
	  while(endPos > index)O[index++] = value;
	  return O;
	};

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
	var $export = __webpack_require__(8)
	  , $find   = __webpack_require__(172)(5)
	  , KEY     = 'find'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  find: function find(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(186)(KEY);

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
	var $export = __webpack_require__(8)
	  , $find   = __webpack_require__(172)(6)
	  , KEY     = 'findIndex'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  findIndex: function findIndex(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(186)(KEY);

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(192)('Array');

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(4)
	  , dP          = __webpack_require__(11)
	  , DESCRIPTORS = __webpack_require__(6)
	  , SPECIES     = __webpack_require__(25)('species');
	
	module.exports = function(KEY){
	  var C = global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(186)
	  , step             = __webpack_require__(194)
	  , Iterators        = __webpack_require__(129)
	  , toIObject        = __webpack_require__(32);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(128)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 194 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	var global            = __webpack_require__(4)
	  , inheritIfRequired = __webpack_require__(88)
	  , dP                = __webpack_require__(11).f
	  , gOPN              = __webpack_require__(50).f
	  , isRegExp          = __webpack_require__(134)
	  , $flags            = __webpack_require__(196)
	  , $RegExp           = global.RegExp
	  , Base              = $RegExp
	  , proto             = $RegExp.prototype
	  , re1               = /a/g
	  , re2               = /a/g
	  // "new" creates a new object, old webkit buggy here
	  , CORRECT_NEW       = new $RegExp(re1) !== re1;
	
	if(__webpack_require__(6) && (!CORRECT_NEW || __webpack_require__(7)(function(){
	  re2[__webpack_require__(25)('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))){
	  $RegExp = function RegExp(p, f){
	    var tiRE = this instanceof $RegExp
	      , piRE = isRegExp(p)
	      , fiU  = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
	      : inheritIfRequired(CORRECT_NEW
	        ? new Base(piRE && !fiU ? p.source : p, f)
	        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
	      , tiRE ? this : proto, $RegExp);
	  };
	  var proxy = function(key){
	    key in $RegExp || dP($RegExp, key, {
	      configurable: true,
	      get: function(){ return Base[key]; },
	      set: function(it){ Base[key] = it; }
	    });
	  };
	  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);
	  proto.constructor = $RegExp;
	  $RegExp.prototype = proto;
	  __webpack_require__(18)(global, 'RegExp', $RegExp);
	}
	
	__webpack_require__(192)('RegExp');

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.2.5.3 get RegExp.prototype.flags
	var anObject = __webpack_require__(12);
	module.exports = function(){
	  var that   = anObject(this)
	    , result = '';
	  if(that.global)     result += 'g';
	  if(that.ignoreCase) result += 'i';
	  if(that.multiline)  result += 'm';
	  if(that.unicode)    result += 'u';
	  if(that.sticky)     result += 'y';
	  return result;
	};

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	__webpack_require__(198);
	var anObject    = __webpack_require__(12)
	  , $flags      = __webpack_require__(196)
	  , DESCRIPTORS = __webpack_require__(6)
	  , TO_STRING   = 'toString'
	  , $toString   = /./[TO_STRING];
	
	var define = function(fn){
	  __webpack_require__(18)(RegExp.prototype, TO_STRING, fn, true);
	};
	
	// 21.2.5.14 RegExp.prototype.toString()
	if(__webpack_require__(7)(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){
	  define(function toString(){
	    var R = anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if($toString.name != TO_STRING){
	  define(function toString(){
	    return $toString.call(this);
	  });
	}

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	// 21.2.5.3 get RegExp.prototype.flags()
	if(__webpack_require__(6) && /./g.flags != 'g')__webpack_require__(11).f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: __webpack_require__(196)
	});

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	// @@match logic
	__webpack_require__(200)('match', 1, function(defined, MATCH, $match){
	  // 21.1.3.11 String.prototype.match(regexp)
	  return [function match(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  }, $match];
	});

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var hide     = __webpack_require__(10)
	  , redefine = __webpack_require__(18)
	  , fails    = __webpack_require__(7)
	  , defined  = __webpack_require__(35)
	  , wks      = __webpack_require__(25);
	
	module.exports = function(KEY, length, exec){
	  var SYMBOL   = wks(KEY)
	    , fns      = exec(defined, SYMBOL, ''[KEY])
	    , strfn    = fns[0]
	    , rxfn     = fns[1];
	  if(fails(function(){
	    var O = {};
	    O[SYMBOL] = function(){ return 7; };
	    return ''[KEY](O) != 7;
	  })){
	    redefine(String.prototype, KEY, strfn);
	    hide(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function(string, arg){ return rxfn.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function(string){ return rxfn.call(string, this); }
	    );
	  }
	};

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	// @@replace logic
	__webpack_require__(200)('replace', 2, function(defined, REPLACE, $replace){
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return [function replace(searchValue, replaceValue){
	    'use strict';
	    var O  = defined(this)
	      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined
	      ? fn.call(searchValue, O, replaceValue)
	      : $replace.call(String(O), searchValue, replaceValue);
	  }, $replace];
	});

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	// @@search logic
	__webpack_require__(200)('search', 1, function(defined, SEARCH, $search){
	  // 21.1.3.15 String.prototype.search(regexp)
	  return [function search(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  }, $search];
	});

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	// @@split logic
	__webpack_require__(200)('split', 2, function(defined, SPLIT, $split){
	  'use strict';
	  var isRegExp   = __webpack_require__(134)
	    , _split     = $split
	    , $push      = [].push
	    , $SPLIT     = 'split'
	    , LENGTH     = 'length'
	    , LAST_INDEX = 'lastIndex';
	  if(
	    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
	    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
	    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
	    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
	    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
	    ''[$SPLIT](/.?/)[LENGTH]
	  ){
	    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	    // based on es5-shim implementation, need to rework it
	    $split = function(separator, limit){
	      var string = String(this);
	      if(separator === undefined && limit === 0)return [];
	      // If `separator` is not a regex, use native split
	      if(!isRegExp(separator))return _split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var separator2, match, lastIndex, lastLength, i;
	      // Doesn't need flags gy, but they don't hurt
	      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	      while(match = separatorCopy.exec(string)){
	        // `separatorCopy.lastIndex` is not reliable cross-browser
	        lastIndex = match.index + match[0][LENGTH];
	        if(lastIndex > lastLastIndex){
	          output.push(string.slice(lastLastIndex, match.index));
	          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
	          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){
	            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;
	          });
	          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if(output[LENGTH] >= splitLimit)break;
	        }
	        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if(lastLastIndex === string[LENGTH]){
	        if(lastLength || !separatorCopy.test(''))output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	  // Chakra, V8
	  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){
	    $split = function(separator, limit){
	      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	    };
	  }
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return [function split(separator, limit){
	    var O  = defined(this)
	      , fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
	  }, $split];
	});

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(28)
	  , global             = __webpack_require__(4)
	  , ctx                = __webpack_require__(20)
	  , classof            = __webpack_require__(75)
	  , $export            = __webpack_require__(8)
	  , isObject           = __webpack_require__(13)
	  , aFunction          = __webpack_require__(21)
	  , anInstance         = __webpack_require__(205)
	  , forOf              = __webpack_require__(206)
	  , speciesConstructor = __webpack_require__(207)
	  , task               = __webpack_require__(208).set
	  , microtask          = __webpack_require__(209)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(25)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(210)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(24)($Promise, PROMISE);
	__webpack_require__(192)(PROMISE);
	Wrapper = __webpack_require__(9)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(165)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 205 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(20)
	  , call        = __webpack_require__(161)
	  , isArrayIter = __webpack_require__(162)
	  , anObject    = __webpack_require__(12)
	  , toLength    = __webpack_require__(37)
	  , getIterFn   = __webpack_require__(164)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(12)
	  , aFunction = __webpack_require__(21)
	  , SPECIES   = __webpack_require__(25)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(20)
	  , invoke             = __webpack_require__(78)
	  , html               = __webpack_require__(48)
	  , cel                = __webpack_require__(15)
	  , global             = __webpack_require__(4)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(34)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(4)
	  , macrotask = __webpack_require__(208).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(34)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(18);
	module.exports = function(target, src, safe){
	  for(var key in src)redefine(target, key, src[key], safe);
	  return target;
	};

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(212);
	
	// 23.1 Map Objects
	module.exports = __webpack_require__(213)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(11).f
	  , create      = __webpack_require__(46)
	  , redefineAll = __webpack_require__(210)
	  , ctx         = __webpack_require__(20)
	  , anInstance  = __webpack_require__(205)
	  , defined     = __webpack_require__(35)
	  , forOf       = __webpack_require__(206)
	  , $iterDefine = __webpack_require__(128)
	  , step        = __webpack_require__(194)
	  , setSpecies  = __webpack_require__(192)
	  , DESCRIPTORS = __webpack_require__(6)
	  , fastKey     = __webpack_require__(22).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(4)
	  , $export           = __webpack_require__(8)
	  , redefine          = __webpack_require__(18)
	  , redefineAll       = __webpack_require__(210)
	  , meta              = __webpack_require__(22)
	  , forOf             = __webpack_require__(206)
	  , anInstance        = __webpack_require__(205)
	  , isObject          = __webpack_require__(13)
	  , fails             = __webpack_require__(7)
	  , $iterDetect       = __webpack_require__(165)
	  , setToStringTag    = __webpack_require__(24)
	  , inheritIfRequired = __webpack_require__(88);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  var fixMethod = function(KEY){
	    var fn = proto[KEY];
	    redefine(proto, KEY,
	      KEY == 'delete' ? function(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a){
	        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    var instance             = new C
	      // early implementations not supports chaining
	      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
	      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
	      // most early implementations doesn't supports iterables, most modern - not close it correctly
	      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
	      // for early implementations -0 and +0 not the same
	      , BUGGY_ZERO = !IS_WEAK && fails(function(){
	        // V8 ~ Chromium 42- fails only with 5+ elements
	        var $instance = new C()
	          , index     = 5;
	        while(index--)$instance[ADDER](index, index);
	        return !$instance.has(-0);
	      });
	    if(!ACCEPT_ITERABLES){ 
	      C = wrapper(function(target, iterable){
	        anInstance(target, C, NAME);
	        var that = inheritIfRequired(new Base, target, C);
	        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if(IS_WEAK && proto.clear)delete proto.clear;
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F * (C != Base), O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(212);
	
	// 23.2 Set Objects
	module.exports = __webpack_require__(213)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var each         = __webpack_require__(172)(0)
	  , redefine     = __webpack_require__(18)
	  , meta         = __webpack_require__(22)
	  , assign       = __webpack_require__(69)
	  , weak         = __webpack_require__(216)
	  , isObject     = __webpack_require__(13)
	  , getWeak      = meta.getWeak
	  , isExtensible = Object.isExtensible
	  , uncaughtFrozenStore = weak.ufstore
	  , tmp          = {}
	  , InternalMap;
	
	var wrapper = function(get){
	  return function WeakMap(){
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};
	
	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key){
	    if(isObject(key)){
	      var data = getWeak(key);
	      if(data === true)return uncaughtFrozenStore(this).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value){
	    return weak.def(this, key, value);
	  }
	};
	
	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = __webpack_require__(213)('WeakMap', wrapper, methods, weak, true, true);
	
	// IE11 WeakMap frozen keys fix
	if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
	  InternalMap = weak.getConstructor(wrapper);
	  assign(InternalMap.prototype, methods);
	  meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function(key){
	    var proto  = $WeakMap.prototype
	      , method = proto[key];
	    redefine(proto, key, function(a, b){
	      // store frozen objects on internal weakmap shim
	      if(isObject(a) && !isExtensible(a)){
	        if(!this._f)this._f = new InternalMap;
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var redefineAll       = __webpack_require__(210)
	  , getWeak           = __webpack_require__(22).getWeak
	  , anObject          = __webpack_require__(12)
	  , isObject          = __webpack_require__(13)
	  , anInstance        = __webpack_require__(205)
	  , forOf             = __webpack_require__(206)
	  , createArrayMethod = __webpack_require__(172)
	  , $has              = __webpack_require__(5)
	  , arrayFind         = createArrayMethod(5)
	  , arrayFindIndex    = createArrayMethod(6)
	  , id                = 0;
	
	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function(that){
	  return that._l || (that._l = new UncaughtFrozenStore);
	};
	var UncaughtFrozenStore = function(){
	  this.a = [];
	};
	var findUncaughtFrozen = function(store, key){
	  return arrayFind(store.a, function(it){
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function(key){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)return entry[1];
	  },
	  has: function(key){
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function(key, value){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function(key){
	    var index = arrayFindIndex(this.a, function(it){
	      return it[0] === key;
	    });
	    if(~index)this.a.splice(index, 1);
	    return !!~index;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
	        return data && $has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this).has(key);
	        return data && $has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var data = getWeak(anObject(key), true);
	    if(data === true)uncaughtFrozenStore(that).set(key, value);
	    else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var weak = __webpack_require__(216);
	
	// 23.4 WeakSet Objects
	__webpack_require__(213)('WeakSet', function(get){
	  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value){
	    return weak.def(this, value, true);
	  }
	}, weak, false, true);

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(8)
	  , $typed       = __webpack_require__(219)
	  , buffer       = __webpack_require__(220)
	  , anObject     = __webpack_require__(12)
	  , toIndex      = __webpack_require__(39)
	  , toLength     = __webpack_require__(37)
	  , isObject     = __webpack_require__(13)
	  , ArrayBuffer  = __webpack_require__(4).ArrayBuffer
	  , speciesConstructor = __webpack_require__(207)
	  , $ArrayBuffer = buffer.ArrayBuffer
	  , $DataView    = buffer.DataView
	  , $isView      = $typed.ABV && ArrayBuffer.isView
	  , $slice       = $ArrayBuffer.prototype.slice
	  , VIEW         = $typed.VIEW
	  , ARRAY_BUFFER = 'ArrayBuffer';
	
	$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});
	
	$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it){
	    return $isView && $isView(it) || isObject(it) && VIEW in it;
	  }
	});
	
	$export($export.P + $export.U + $export.F * __webpack_require__(7)(function(){
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end){
	    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix
	    var len    = anObject(this).byteLength
	      , first  = toIndex(start, len)
	      , final  = toIndex(end === undefined ? len : end, len)
	      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
	      , viewS  = new $DataView(this)
	      , viewT  = new $DataView(result)
	      , index  = 0;
	    while(first < final){
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    } return result;
	  }
	});
	
	__webpack_require__(192)(ARRAY_BUFFER);

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(4)
	  , hide   = __webpack_require__(10)
	  , uid    = __webpack_require__(19)
	  , TYPED  = uid('typed_array')
	  , VIEW   = uid('view')
	  , ABV    = !!(global.ArrayBuffer && global.DataView)
	  , CONSTR = ABV
	  , i = 0, l = 9, Typed;
	
	var TypedArrayConstructors = (
	  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
	).split(',');
	
	while(i < l){
	  if(Typed = global[TypedArrayConstructors[i++]]){
	    hide(Typed.prototype, TYPED, true);
	    hide(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}
	
	module.exports = {
	  ABV:    ABV,
	  CONSTR: CONSTR,
	  TYPED:  TYPED,
	  VIEW:   VIEW
	};

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(4)
	  , DESCRIPTORS    = __webpack_require__(6)
	  , LIBRARY        = __webpack_require__(28)
	  , $typed         = __webpack_require__(219)
	  , hide           = __webpack_require__(10)
	  , redefineAll    = __webpack_require__(210)
	  , fails          = __webpack_require__(7)
	  , anInstance     = __webpack_require__(205)
	  , toInteger      = __webpack_require__(38)
	  , toLength       = __webpack_require__(37)
	  , gOPN           = __webpack_require__(50).f
	  , dP             = __webpack_require__(11).f
	  , arrayFill      = __webpack_require__(188)
	  , setToStringTag = __webpack_require__(24)
	  , ARRAY_BUFFER   = 'ArrayBuffer'
	  , DATA_VIEW      = 'DataView'
	  , PROTOTYPE      = 'prototype'
	  , WRONG_LENGTH   = 'Wrong length!'
	  , WRONG_INDEX    = 'Wrong index!'
	  , $ArrayBuffer   = global[ARRAY_BUFFER]
	  , $DataView      = global[DATA_VIEW]
	  , Math           = global.Math
	  , RangeError     = global.RangeError
	  , Infinity       = global.Infinity
	  , BaseBuffer     = $ArrayBuffer
	  , abs            = Math.abs
	  , pow            = Math.pow
	  , floor          = Math.floor
	  , log            = Math.log
	  , LN2            = Math.LN2
	  , BUFFER         = 'buffer'
	  , BYTE_LENGTH    = 'byteLength'
	  , BYTE_OFFSET    = 'byteOffset'
	  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER
	  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH
	  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;
	
	// IEEE754 conversions based on https://github.com/feross/ieee754
	var packIEEE754 = function(value, mLen, nBytes){
	  var buffer = Array(nBytes)
	    , eLen   = nBytes * 8 - mLen - 1
	    , eMax   = (1 << eLen) - 1
	    , eBias  = eMax >> 1
	    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
	    , i      = 0
	    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
	    , e, m, c;
	  value = abs(value)
	  if(value != value || value === Infinity){
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);
	    if(value * (c = pow(2, -e)) < 1){
	      e--;
	      c *= 2;
	    }
	    if(e + eBias >= 1){
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }
	    if(value * c >= 2){
	      e++;
	      c /= 2;
	    }
	    if(e + eBias >= eMax){
	      m = 0;
	      e = eMax;
	    } else if(e + eBias >= 1){
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }
	  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
	  e = e << mLen | m;
	  eLen += mLen;
	  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
	  buffer[--i] |= s * 128;
	  return buffer;
	};
	var unpackIEEE754 = function(buffer, mLen, nBytes){
	  var eLen  = nBytes * 8 - mLen - 1
	    , eMax  = (1 << eLen) - 1
	    , eBias = eMax >> 1
	    , nBits = eLen - 7
	    , i     = nBytes - 1
	    , s     = buffer[i--]
	    , e     = s & 127
	    , m;
	  s >>= 7;
	  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
	  if(e === 0){
	    e = 1 - eBias;
	  } else if(e === eMax){
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  } return (s ? -1 : 1) * m * pow(2, e - mLen);
	};
	
	var unpackI32 = function(bytes){
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	};
	var packI8 = function(it){
	  return [it & 0xff];
	};
	var packI16 = function(it){
	  return [it & 0xff, it >> 8 & 0xff];
	};
	var packI32 = function(it){
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	};
	var packF64 = function(it){
	  return packIEEE754(it, 52, 8);
	};
	var packF32 = function(it){
	  return packIEEE754(it, 23, 4);
	};
	
	var addGetter = function(C, key, internal){
	  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});
	};
	
	var get = function(view, bytes, index, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	};
	var set = function(view, bytes, index, conversion, value, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = conversion(+value);
	  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	};
	
	var validateArrayBufferArguments = function(that, length){
	  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
	  var numberLength = +length
	    , byteLength   = toLength(numberLength);
	  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);
	  return byteLength;
	};
	
	if(!$typed.ABV){
	  $ArrayBuffer = function ArrayBuffer(length){
	    var byteLength = validateArrayBufferArguments(this, length);
	    this._b       = arrayFill.call(Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };
	
	  $DataView = function DataView(buffer, byteOffset, byteLength){
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH]
	      , offset       = toInteger(byteOffset);
	    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };
	
	  if(DESCRIPTORS){
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }
	
	  redefineAll($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset){
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset){
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if(!fails(function(){
	    new $ArrayBuffer;     // eslint-disable-line no-new
	  }) || !fails(function(){
	    new $ArrayBuffer(.5); // eslint-disable-line no-new
	  })){
	    $ArrayBuffer = function ArrayBuffer(length){
	      return new BaseBuffer(validateArrayBufferArguments(this, length));
	    };
	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){
	      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);
	    };
	    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;
	  }
	  // iOS Safari 7.x bug
	  var view = new $DataView(new $ArrayBuffer(2))
	    , $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true);
	}
	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	hide($DataView[PROTOTYPE], $typed.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	$export($export.G + $export.W + $export.F * !__webpack_require__(219).ABV, {
	  DataView: __webpack_require__(220).DataView
	});

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Int8', 1, function(init){
	  return function Int8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	if(__webpack_require__(6)){
	  var LIBRARY             = __webpack_require__(28)
	    , global              = __webpack_require__(4)
	    , fails               = __webpack_require__(7)
	    , $export             = __webpack_require__(8)
	    , $typed              = __webpack_require__(219)
	    , $buffer             = __webpack_require__(220)
	    , ctx                 = __webpack_require__(20)
	    , anInstance          = __webpack_require__(205)
	    , propertyDesc        = __webpack_require__(17)
	    , hide                = __webpack_require__(10)
	    , redefineAll         = __webpack_require__(210)
	    , toInteger           = __webpack_require__(38)
	    , toLength            = __webpack_require__(37)
	    , toIndex             = __webpack_require__(39)
	    , toPrimitive         = __webpack_require__(16)
	    , has                 = __webpack_require__(5)
	    , same                = __webpack_require__(71)
	    , classof             = __webpack_require__(75)
	    , isObject            = __webpack_require__(13)
	    , toObject            = __webpack_require__(58)
	    , isArrayIter         = __webpack_require__(162)
	    , create              = __webpack_require__(46)
	    , getPrototypeOf      = __webpack_require__(59)
	    , gOPN                = __webpack_require__(50).f
	    , getIterFn           = __webpack_require__(164)
	    , uid                 = __webpack_require__(19)
	    , wks                 = __webpack_require__(25)
	    , createArrayMethod   = __webpack_require__(172)
	    , createArrayIncludes = __webpack_require__(36)
	    , speciesConstructor  = __webpack_require__(207)
	    , ArrayIterators      = __webpack_require__(193)
	    , Iterators           = __webpack_require__(129)
	    , $iterDetect         = __webpack_require__(165)
	    , setSpecies          = __webpack_require__(192)
	    , arrayFill           = __webpack_require__(188)
	    , arrayCopyWithin     = __webpack_require__(185)
	    , $DP                 = __webpack_require__(11)
	    , $GOPD               = __webpack_require__(51)
	    , dP                  = $DP.f
	    , gOPD                = $GOPD.f
	    , RangeError          = global.RangeError
	    , TypeError           = global.TypeError
	    , Uint8Array          = global.Uint8Array
	    , ARRAY_BUFFER        = 'ArrayBuffer'
	    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER
	    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'
	    , PROTOTYPE           = 'prototype'
	    , ArrayProto          = Array[PROTOTYPE]
	    , $ArrayBuffer        = $buffer.ArrayBuffer
	    , $DataView           = $buffer.DataView
	    , arrayForEach        = createArrayMethod(0)
	    , arrayFilter         = createArrayMethod(2)
	    , arraySome           = createArrayMethod(3)
	    , arrayEvery          = createArrayMethod(4)
	    , arrayFind           = createArrayMethod(5)
	    , arrayFindIndex      = createArrayMethod(6)
	    , arrayIncludes       = createArrayIncludes(true)
	    , arrayIndexOf        = createArrayIncludes(false)
	    , arrayValues         = ArrayIterators.values
	    , arrayKeys           = ArrayIterators.keys
	    , arrayEntries        = ArrayIterators.entries
	    , arrayLastIndexOf    = ArrayProto.lastIndexOf
	    , arrayReduce         = ArrayProto.reduce
	    , arrayReduceRight    = ArrayProto.reduceRight
	    , arrayJoin           = ArrayProto.join
	    , arraySort           = ArrayProto.sort
	    , arraySlice          = ArrayProto.slice
	    , arrayToString       = ArrayProto.toString
	    , arrayToLocaleString = ArrayProto.toLocaleString
	    , ITERATOR            = wks('iterator')
	    , TAG                 = wks('toStringTag')
	    , TYPED_CONSTRUCTOR   = uid('typed_constructor')
	    , DEF_CONSTRUCTOR     = uid('def_constructor')
	    , ALL_CONSTRUCTORS    = $typed.CONSTR
	    , TYPED_ARRAY         = $typed.TYPED
	    , VIEW                = $typed.VIEW
	    , WRONG_LENGTH        = 'Wrong length!';
	
	  var $map = createArrayMethod(1, function(O, length){
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });
	
	  var LITTLE_ENDIAN = fails(function(){
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });
	
	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){
	    new Uint8Array(1).set({});
	  });
	
	  var strictToLength = function(it, SAME){
	    if(it === undefined)throw TypeError(WRONG_LENGTH);
	    var number = +it
	      , length = toLength(it);
	    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);
	    return length;
	  };
	
	  var toOffset = function(it, BYTES){
	    var offset = toInteger(it);
	    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');
	    return offset;
	  };
	
	  var validate = function(it){
	    if(isObject(it) && TYPED_ARRAY in it)return it;
	    throw TypeError(it + ' is not a typed array!');
	  };
	
	  var allocate = function(C, length){
	    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){
	      throw TypeError('It is not a typed array constructor!');
	    } return new C(length);
	  };
	
	  var speciesFromList = function(O, list){
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };
	
	  var fromList = function(C, list){
	    var index  = 0
	      , length = list.length
	      , result = allocate(C, length);
	    while(length > index)result[index] = list[index++];
	    return result;
	  };
	
	  var addGetter = function(it, key, internal){
	    dP(it, key, {get: function(){ return this._d[internal]; }});
	  };
	
	  var $from = function from(source /*, mapfn, thisArg */){
	    var O       = toObject(source)
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , iterFn  = getIterFn(O)
	      , i, length, values, result, step, iterator;
	    if(iterFn != undefined && !isArrayIter(iterFn)){
	      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){
	        values.push(step.value);
	      } O = values;
	    }
	    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);
	    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }
	    return result;
	  };
	
	  var $of = function of(/*...items*/){
	    var index  = 0
	      , length = arguments.length
	      , result = allocate(this, length);
	    while(length > index)result[index] = arguments[index++];
	    return result;
	  };
	
	  // iOS Safari 6.x fails here
	  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });
	
	  var $toLocaleString = function toLocaleString(){
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };
	
	  var proto = {
	    copyWithin: function copyWithin(target, start /*, end */){
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn /*, thisArg */){
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn /*, thisArg */){
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
	        arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate /*, thisArg */){
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate /*, thisArg */){
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn /*, thisArg */){
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement /*, fromIndex */){
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement /*, fromIndex */){
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator){ // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn /*, thisArg */){
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse(){
	      var that   = this
	        , length = validate(that).length
	        , middle = Math.floor(length / 2)
	        , index  = 0
	        , value;
	      while(index < middle){
	        value         = that[index];
	        that[index++] = that[--length];
	        that[length]  = value;
	      } return that;
	    },
	    some: function some(callbackfn /*, thisArg */){
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn){
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end){
	      var O      = validate(this)
	        , length = O.length
	        , $begin = toIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
	        O.buffer,
	        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
	        toLength((end === undefined ? length : toIndex(end, length)) - $begin)
	      );
	    }
	  };
	
	  var $slice = function slice(start, end){
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };
	
	  var $set = function set(arrayLike /*, offset */){
	    validate(this);
	    var offset = toOffset(arguments[1], 1)
	      , length = this.length
	      , src    = toObject(arrayLike)
	      , len    = toLength(src.length)
	      , index  = 0;
	    if(len + offset > length)throw RangeError(WRONG_LENGTH);
	    while(index < len)this[offset + index] = src[index++];
	  };
	
	  var $iterators = {
	    entries: function entries(){
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys(){
	      return arrayKeys.call(validate(this));
	    },
	    values: function values(){
	      return arrayValues.call(validate(this));
	    }
	  };
	
	  var isTAIndex = function(target, key){
	    return isObject(target)
	      && target[TYPED_ARRAY]
	      && typeof key != 'symbol'
	      && key in target
	      && String(+key) == String(key);
	  };
	  var $getDesc = function getOwnPropertyDescriptor(target, key){
	    return isTAIndex(target, key = toPrimitive(key, true))
	      ? propertyDesc(2, target[key])
	      : gOPD(target, key);
	  };
	  var $setDesc = function defineProperty(target, key, desc){
	    if(isTAIndex(target, key = toPrimitive(key, true))
	      && isObject(desc)
	      && has(desc, 'value')
	      && !has(desc, 'get')
	      && !has(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable
	      && (!has(desc, 'writable') || desc.writable)
	      && (!has(desc, 'enumerable') || desc.enumerable)
	    ){
	      target[key] = desc.value;
	      return target;
	    } else return dP(target, key, desc);
	  };
	
	  if(!ALL_CONSTRUCTORS){
	    $GOPD.f = $getDesc;
	    $DP.f   = $setDesc;
	  }
	
	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty:           $setDesc
	  });
	
	  if(fails(function(){ arrayToString.call({}); })){
	    arrayToString = arrayToLocaleString = function toString(){
	      return arrayJoin.call(this);
	    }
	  }
	
	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice:          $slice,
	    set:            $set,
	    constructor:    function(){ /* noop */ },
	    toString:       arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function(){ return this[TYPED_ARRAY]; }
	  });
	
	  module.exports = function(KEY, BYTES, wrapper, CLAMPED){
	    CLAMPED = !!CLAMPED;
	    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
	      , ISNT_UINT8 = NAME != 'Uint8Array'
	      , GETTER     = 'get' + KEY
	      , SETTER     = 'set' + KEY
	      , TypedArray = global[NAME]
	      , Base       = TypedArray || {}
	      , TAC        = TypedArray && getPrototypeOf(TypedArray)
	      , FORCED     = !TypedArray || !$typed.ABV
	      , O          = {}
	      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	    var getter = function(that, index){
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };
	    var setter = function(that, index, value){
	      var data = that._d;
	      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };
	    var addElement = function(that, index){
	      dP(that, index, {
	        get: function(){
	          return getter(this, index);
	        },
	        set: function(value){
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if(FORCED){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME, '_d');
	        var index  = 0
	          , offset = 0
	          , buffer, byteLength, length, klass;
	        if(!isObject(data)){
	          length     = strictToLength(data, true)
	          byteLength = length * BYTES;
	          buffer     = new $ArrayBuffer(byteLength);
	        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;
	          if($length === undefined){
	            if($len % BYTES)throw RangeError(WRONG_LENGTH);
	            byteLength = $len - offset;
	            if(byteLength < 0)throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if(TYPED_ARRAY in data){
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }
	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });
	        while(index < length)addElement(that, index++);
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if(!$iterDetect(function(iter){
	      // V8 works with iterators, but fails in many other cases
	      // https://code.google.com/p/v8/issues/detail?id=4552
	      new TypedArray(null); // eslint-disable-line no-new
	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME);
	        var klass;
	        // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645
	        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));
	        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          return $length !== undefined
	            ? new Base(data, toOffset($offset, BYTES), $length)
	            : $offset !== undefined
	              ? new Base(data, toOffset($offset, BYTES))
	              : new Base(data);
	        }
	        if(TYPED_ARRAY in data)return fromList(TypedArray, data);
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){
	        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;
	    }
	    var $nativeIterator   = TypedArrayPrototype[ITERATOR]
	      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
	      , $iterator         = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);
	
	    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){
	      dP(TypedArrayPrototype, TAG, {
	        get: function(){ return NAME; }
	      });
	    }
	
	    O[NAME] = TypedArray;
	
	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
	
	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES,
	      from: $from,
	      of: $of
	    });
	
	    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
	
	    $export($export.P, NAME, proto);
	
	    setSpecies(NAME);
	
	    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});
	
	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
	
	    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});
	
	    $export($export.P + $export.F * fails(function(){
	      new TypedArray(1).slice();
	    }), NAME, {slice: $slice});
	
	    $export($export.P + $export.F * (fails(function(){
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
	    }) || !fails(function(){
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, {toLocaleString: $toLocaleString});
	
	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);
	  };
	} else module.exports = function(){ /* empty */ };

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint8', 1, function(init){
	  return function Uint8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint8', 1, function(init){
	  return function Uint8ClampedArray(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	}, true);

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Int16', 2, function(init){
	  return function Int16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint16', 2, function(init){
	  return function Uint16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Int32', 4, function(init){
	  return function Int32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint32', 4, function(init){
	  return function Uint32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Float32', 4, function(init){
	  return function Float32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Float64', 8, function(init){
	  return function Float64Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
	var $export   = __webpack_require__(8)
	  , aFunction = __webpack_require__(21)
	  , anObject  = __webpack_require__(12)
	  , rApply    = (__webpack_require__(4).Reflect || {}).apply
	  , fApply    = Function.apply;
	// MS Edge argumentsList argument is optional
	$export($export.S + $export.F * !__webpack_require__(7)(function(){
	  rApply(function(){});
	}), 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList){
	    var T = aFunction(target)
	      , L = anObject(argumentsList);
	    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
	  }
	});

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
	var $export    = __webpack_require__(8)
	  , create     = __webpack_require__(46)
	  , aFunction  = __webpack_require__(21)
	  , anObject   = __webpack_require__(12)
	  , isObject   = __webpack_require__(13)
	  , fails      = __webpack_require__(7)
	  , bind       = __webpack_require__(77)
	  , rConstruct = (__webpack_require__(4).Reflect || {}).construct;
	
	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = fails(function(){
	  function F(){}
	  return !(rConstruct(function(){}, [], F) instanceof F);
	});
	var ARGS_BUG = !fails(function(){
	  rConstruct(function(){});
	});
	
	$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
	  construct: function construct(Target, args /*, newTarget*/){
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);
	    if(Target == newTarget){
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch(args.length){
	        case 0: return new Target;
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args));
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto    = newTarget.prototype
	      , instance = create(isObject(proto) ? proto : Object.prototype)
	      , result   = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
	var dP          = __webpack_require__(11)
	  , $export     = __webpack_require__(8)
	  , anObject    = __webpack_require__(12)
	  , toPrimitive = __webpack_require__(16);
	
	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes){
	    anObject(target);
	    propertyKey = toPrimitive(propertyKey, true);
	    anObject(attributes);
	    try {
	      dP.f(target, propertyKey, attributes);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)
	var $export  = __webpack_require__(8)
	  , gOPD     = __webpack_require__(51).f
	  , anObject = __webpack_require__(12);
	
	$export($export.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey){
	    var desc = gOPD(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 26.1.5 Reflect.enumerate(target)
	var $export  = __webpack_require__(8)
	  , anObject = __webpack_require__(12);
	var Enumerate = function(iterated){
	  this._t = anObject(iterated); // target
	  this._i = 0;                  // next index
	  var keys = this._k = []       // keys
	    , key;
	  for(key in iterated)keys.push(key);
	};
	__webpack_require__(130)(Enumerate, 'Object', function(){
	  var that = this
	    , keys = that._k
	    , key;
	  do {
	    if(that._i >= keys.length)return {value: undefined, done: true};
	  } while(!((key = keys[that._i++]) in that._t));
	  return {value: key, done: false};
	});
	
	$export($export.S, 'Reflect', {
	  enumerate: function enumerate(target){
	    return new Enumerate(target);
	  }
	});

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])
	var gOPD           = __webpack_require__(51)
	  , getPrototypeOf = __webpack_require__(59)
	  , has            = __webpack_require__(5)
	  , $export        = __webpack_require__(8)
	  , isObject       = __webpack_require__(13)
	  , anObject       = __webpack_require__(12);
	
	function get(target, propertyKey/*, receiver*/){
	  var receiver = arguments.length < 3 ? target : arguments[2]
	    , desc, proto;
	  if(anObject(target) === receiver)return target[propertyKey];
	  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')
	    ? desc.value
	    : desc.get !== undefined
	      ? desc.get.call(receiver)
	      : undefined;
	  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);
	}
	
	$export($export.S, 'Reflect', {get: get});

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
	var gOPD     = __webpack_require__(51)
	  , $export  = __webpack_require__(8)
	  , anObject = __webpack_require__(12);
	
	$export($export.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
	    return gOPD.f(anObject(target), propertyKey);
	  }
	});

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.8 Reflect.getPrototypeOf(target)
	var $export  = __webpack_require__(8)
	  , getProto = __webpack_require__(59)
	  , anObject = __webpack_require__(12);
	
	$export($export.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target){
	    return getProto(anObject(target));
	  }
	});

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.9 Reflect.has(target, propertyKey)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Reflect', {
	  has: function has(target, propertyKey){
	    return propertyKey in target;
	  }
	});

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.10 Reflect.isExtensible(target)
	var $export       = __webpack_require__(8)
	  , anObject      = __webpack_require__(12)
	  , $isExtensible = Object.isExtensible;
	
	$export($export.S, 'Reflect', {
	  isExtensible: function isExtensible(target){
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.11 Reflect.ownKeys(target)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Reflect', {ownKeys: __webpack_require__(243)});

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	// all object keys, includes non-enumerable and symbols
	var gOPN     = __webpack_require__(50)
	  , gOPS     = __webpack_require__(43)
	  , anObject = __webpack_require__(12)
	  , Reflect  = __webpack_require__(4).Reflect;
	module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
	  var keys       = gOPN.f(anObject(it))
	    , getSymbols = gOPS.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.12 Reflect.preventExtensions(target)
	var $export            = __webpack_require__(8)
	  , anObject           = __webpack_require__(12)
	  , $preventExtensions = Object.preventExtensions;
	
	$export($export.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target){
	    anObject(target);
	    try {
	      if($preventExtensions)$preventExtensions(target);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
	var dP             = __webpack_require__(11)
	  , gOPD           = __webpack_require__(51)
	  , getPrototypeOf = __webpack_require__(59)
	  , has            = __webpack_require__(5)
	  , $export        = __webpack_require__(8)
	  , createDesc     = __webpack_require__(17)
	  , anObject       = __webpack_require__(12)
	  , isObject       = __webpack_require__(13);
	
	function set(target, propertyKey, V/*, receiver*/){
	  var receiver = arguments.length < 4 ? target : arguments[3]
	    , ownDesc  = gOPD.f(anObject(target), propertyKey)
	    , existingDescriptor, proto;
	  if(!ownDesc){
	    if(isObject(proto = getPrototypeOf(target))){
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = createDesc(0);
	  }
	  if(has(ownDesc, 'value')){
	    if(ownDesc.writable === false || !isObject(receiver))return false;
	    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
	    existingDescriptor.value = V;
	    dP.f(receiver, propertyKey, existingDescriptor);
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}
	
	$export($export.S, 'Reflect', {set: set});

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.14 Reflect.setPrototypeOf(target, proto)
	var $export  = __webpack_require__(8)
	  , setProto = __webpack_require__(73);
	
	if(setProto)$export($export.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto){
	    setProto.check(target, proto);
	    try {
	      setProto.set(target, proto);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/Array.prototype.includes
	var $export   = __webpack_require__(8)
	  , $includes = __webpack_require__(36)(true);
	
	$export($export.P, 'Array', {
	  includes: function includes(el /*, fromIndex = 0 */){
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	
	__webpack_require__(186)('includes');

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/mathiasbynens/String.prototype.at
	var $export = __webpack_require__(8)
	  , $at     = __webpack_require__(127)(true);
	
	$export($export.P, 'String', {
	  at: function at(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(8)
	  , $pad    = __webpack_require__(250);
	
	$export($export.P, 'String', {
	  padStart: function padStart(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-string-pad-start-end
	var toLength = __webpack_require__(37)
	  , repeat   = __webpack_require__(91)
	  , defined  = __webpack_require__(35);
	
	module.exports = function(that, maxLength, fillString, left){
	  var S            = String(defined(that))
	    , stringLength = S.length
	    , fillStr      = fillString === undefined ? ' ' : String(fillString)
	    , intMaxLength = toLength(maxLength);
	  if(intMaxLength <= stringLength || fillStr == '')return S;
	  var fillLen = intMaxLength - stringLength
	    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};


/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(8)
	  , $pad    = __webpack_require__(250);
	
	$export($export.P, 'String', {
	  padEnd: function padEnd(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(83)('trimLeft', function($trim){
	  return function trimLeft(){
	    return $trim(this, 1);
	  };
	}, 'trimStart');

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(83)('trimRight', function($trim){
	  return function trimRight(){
	    return $trim(this, 2);
	  };
	}, 'trimEnd');

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/String.prototype.matchAll/
	var $export     = __webpack_require__(8)
	  , defined     = __webpack_require__(35)
	  , toLength    = __webpack_require__(37)
	  , isRegExp    = __webpack_require__(134)
	  , getFlags    = __webpack_require__(196)
	  , RegExpProto = RegExp.prototype;
	
	var $RegExpStringIterator = function(regexp, string){
	  this._r = regexp;
	  this._s = string;
	};
	
	__webpack_require__(130)($RegExpStringIterator, 'RegExp String', function next(){
	  var match = this._r.exec(this._s);
	  return {value: match, done: match === null};
	});
	
	$export($export.P, 'String', {
	  matchAll: function matchAll(regexp){
	    defined(this);
	    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');
	    var S     = String(this)
	      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
	      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
	    rx.lastIndex = toLength(regexp.lastIndex);
	    return new $RegExpStringIterator(rx, S);
	  }
	});

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(27)('asyncIterator');

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(27)('observable');

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-getownpropertydescriptors
	var $export        = __webpack_require__(8)
	  , ownKeys        = __webpack_require__(243)
	  , toIObject      = __webpack_require__(32)
	  , gOPD           = __webpack_require__(51)
	  , createProperty = __webpack_require__(163);
	
	$export($export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
	    var O       = toIObject(object)
	      , getDesc = gOPD.f
	      , keys    = ownKeys(O)
	      , result  = {}
	      , i       = 0
	      , key;
	    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));
	    return result;
	  }
	});

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(8)
	  , $values = __webpack_require__(259)(false);
	
	$export($export.S, 'Object', {
	  values: function values(it){
	    return $values(it);
	  }
	});

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(30)
	  , toIObject = __webpack_require__(32)
	  , isEnum    = __webpack_require__(44).f;
	module.exports = function(isEntries){
	  return function(it){
	    var O      = toIObject(it)
	      , keys   = getKeys(O)
	      , length = keys.length
	      , i      = 0
	      , result = []
	      , key;
	    while(length > i)if(isEnum.call(O, key = keys[i++])){
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export  = __webpack_require__(8)
	  , $entries = __webpack_require__(259)(true);
	
	$export($export.S, 'Object', {
	  entries: function entries(it){
	    return $entries(it);
	  }
	});

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(8)
	  , toObject        = __webpack_require__(58)
	  , aFunction       = __webpack_require__(21)
	  , $defineProperty = __webpack_require__(11);
	
	// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
	__webpack_require__(6) && $export($export.P + __webpack_require__(262), 'Object', {
	  __defineGetter__: function __defineGetter__(P, getter){
	    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	// Forced replacement prototype accessors methods
	module.exports = __webpack_require__(28)|| !__webpack_require__(7)(function(){
	  var K = Math.random();
	  // In FF throws only define methods
	  __defineSetter__.call(null, K, function(){ /* empty */});
	  delete __webpack_require__(4)[K];
	});

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(8)
	  , toObject        = __webpack_require__(58)
	  , aFunction       = __webpack_require__(21)
	  , $defineProperty = __webpack_require__(11);
	
	// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
	__webpack_require__(6) && $export($export.P + __webpack_require__(262), 'Object', {
	  __defineSetter__: function __defineSetter__(P, setter){
	    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(8)
	  , toObject                 = __webpack_require__(58)
	  , toPrimitive              = __webpack_require__(16)
	  , getPrototypeOf           = __webpack_require__(59)
	  , getOwnPropertyDescriptor = __webpack_require__(51).f;
	
	// B.2.2.4 Object.prototype.__lookupGetter__(P)
	__webpack_require__(6) && $export($export.P + __webpack_require__(262), 'Object', {
	  __lookupGetter__: function __lookupGetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.get;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(8)
	  , toObject                 = __webpack_require__(58)
	  , toPrimitive              = __webpack_require__(16)
	  , getPrototypeOf           = __webpack_require__(59)
	  , getOwnPropertyDescriptor = __webpack_require__(51).f;
	
	// B.2.2.5 Object.prototype.__lookupSetter__(P)
	__webpack_require__(6) && $export($export.P + __webpack_require__(262), 'Object', {
	  __lookupSetter__: function __lookupSetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.set;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(8);
	
	$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(267)('Map')});

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(75)
	  , from    = __webpack_require__(268);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(206);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(8);
	
	$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(267)('Set')});

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-global
	var $export = __webpack_require__(8);
	
	$export($export.S, 'System', {global: __webpack_require__(4)});

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-is-error
	var $export = __webpack_require__(8)
	  , cof     = __webpack_require__(34);
	
	$export($export.S, 'Error', {
	  isError: function isError(it){
	    return cof(it) === 'Error';
	  }
	});

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  iaddh: function iaddh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  isubh: function isubh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  imulh: function imulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >> 16
	      , v1 = $v >> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  umulh: function umulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >>> 16
	      , v1 = $v >>> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(277)
	  , anObject                  = __webpack_require__(12)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
	  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
	}});

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	var Map     = __webpack_require__(211)
	  , $export = __webpack_require__(8)
	  , shared  = __webpack_require__(23)('metadata')
	  , store   = shared.store || (shared.store = new (__webpack_require__(215)));
	
	var getOrCreateMetadataMap = function(target, targetKey, create){
	  var targetMetadata = store.get(target);
	  if(!targetMetadata){
	    if(!create)return undefined;
	    store.set(target, targetMetadata = new Map);
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if(!keyMetadata){
	    if(!create)return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new Map);
	  } return keyMetadata;
	};
	var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};
	var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};
	var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};
	var ordinaryOwnMetadataKeys = function(target, targetKey){
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
	    , keys        = [];
	  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
	  return keys;
	};
	var toMetaKey = function(it){
	  return it === undefined || typeof it == 'symbol' ? it : String(it);
	};
	var exp = function(O){
	  $export($export.S, 'Reflect', O);
	};
	
	module.exports = {
	  store: store,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp
	};

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(277)
	  , anObject               = __webpack_require__(12)
	  , toMetaKey              = metadata.key
	  , getOrCreateMetadataMap = metadata.map
	  , store                  = metadata.store;
	
	metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
	  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
	    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
	  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
	  if(metadataMap.size)return true;
	  var targetMetadata = store.get(target);
	  targetMetadata['delete'](targetKey);
	  return !!targetMetadata.size || store['delete'](target);
	}});

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(277)
	  , anObject               = __webpack_require__(12)
	  , getPrototypeOf         = __webpack_require__(59)
	  , ordinaryHasOwnMetadata = metadata.has
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;
	
	var ordinaryGetMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};
	
	metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	var Set                     = __webpack_require__(214)
	  , from                    = __webpack_require__(268)
	  , metadata                = __webpack_require__(277)
	  , anObject                = __webpack_require__(12)
	  , getPrototypeOf          = __webpack_require__(59)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;
	
	var ordinaryMetadataKeys = function(O, P){
	  var oKeys  = ordinaryOwnMetadataKeys(O, P)
	    , parent = getPrototypeOf(O);
	  if(parent === null)return oKeys;
	  var pKeys  = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
	};
	
	metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
	  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(277)
	  , anObject               = __webpack_require__(12)
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;
	
	metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                = __webpack_require__(277)
	  , anObject                = __webpack_require__(12)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;
	
	metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
	  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(277)
	  , anObject               = __webpack_require__(12)
	  , getPrototypeOf         = __webpack_require__(59)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;
	
	var ordinaryHasMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return true;
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};
	
	metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(277)
	  , anObject               = __webpack_require__(12)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;
	
	metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(277)
	  , anObject                  = __webpack_require__(12)
	  , aFunction                 = __webpack_require__(21)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({metadata: function metadata(metadataKey, metadataValue){
	  return function decorator(target, targetKey){
	    ordinaryDefineOwnMetadata(
	      metadataKey, metadataValue,
	      (targetKey !== undefined ? anObject : aFunction)(target),
	      toMetaKey(targetKey)
	    );
	  };
	}});

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
	var $export   = __webpack_require__(8)
	  , microtask = __webpack_require__(209)()
	  , process   = __webpack_require__(4).process
	  , isNode    = __webpack_require__(34)(process) == 'process';
	
	$export($export.G, {
	  asap: function asap(fn){
	    var domain = isNode && process.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/zenparsing/es-observable
	var $export     = __webpack_require__(8)
	  , global      = __webpack_require__(4)
	  , core        = __webpack_require__(9)
	  , microtask   = __webpack_require__(209)()
	  , OBSERVABLE  = __webpack_require__(25)('observable')
	  , aFunction   = __webpack_require__(21)
	  , anObject    = __webpack_require__(12)
	  , anInstance  = __webpack_require__(205)
	  , redefineAll = __webpack_require__(210)
	  , hide        = __webpack_require__(10)
	  , forOf       = __webpack_require__(206)
	  , RETURN      = forOf.RETURN;
	
	var getMethod = function(fn){
	  return fn == null ? undefined : aFunction(fn);
	};
	
	var cleanupSubscription = function(subscription){
	  var cleanup = subscription._c;
	  if(cleanup){
	    subscription._c = undefined;
	    cleanup();
	  }
	};
	
	var subscriptionClosed = function(subscription){
	  return subscription._o === undefined;
	};
	
	var closeSubscription = function(subscription){
	  if(!subscriptionClosed(subscription)){
	    subscription._o = undefined;
	    cleanupSubscription(subscription);
	  }
	};
	
	var Subscription = function(observer, subscriber){
	  anObject(observer);
	  this._c = undefined;
	  this._o = observer;
	  observer = new SubscriptionObserver(this);
	  try {
	    var cleanup      = subscriber(observer)
	      , subscription = cleanup;
	    if(cleanup != null){
	      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };
	      else aFunction(cleanup);
	      this._c = cleanup;
	    }
	  } catch(e){
	    observer.error(e);
	    return;
	  } if(subscriptionClosed(this))cleanupSubscription(this);
	};
	
	Subscription.prototype = redefineAll({}, {
	  unsubscribe: function unsubscribe(){ closeSubscription(this); }
	});
	
	var SubscriptionObserver = function(subscription){
	  this._s = subscription;
	};
	
	SubscriptionObserver.prototype = redefineAll({}, {
	  next: function next(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      try {
	        var m = getMethod(observer.next);
	        if(m)return m.call(observer, value);
	      } catch(e){
	        try {
	          closeSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }
	    }
	  },
	  error: function error(value){
	    var subscription = this._s;
	    if(subscriptionClosed(subscription))throw value;
	    var observer = subscription._o;
	    subscription._o = undefined;
	    try {
	      var m = getMethod(observer.error);
	      if(!m)throw value;
	      value = m.call(observer, value);
	    } catch(e){
	      try {
	        cleanupSubscription(subscription);
	      } finally {
	        throw e;
	      }
	    } cleanupSubscription(subscription);
	    return value;
	  },
	  complete: function complete(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      subscription._o = undefined;
	      try {
	        var m = getMethod(observer.complete);
	        value = m ? m.call(observer, value) : undefined;
	      } catch(e){
	        try {
	          cleanupSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      } cleanupSubscription(subscription);
	      return value;
	    }
	  }
	});
	
	var $Observable = function Observable(subscriber){
	  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
	};
	
	redefineAll($Observable.prototype, {
	  subscribe: function subscribe(observer){
	    return new Subscription(observer, this._f);
	  },
	  forEach: function forEach(fn){
	    var that = this;
	    return new (core.Promise || global.Promise)(function(resolve, reject){
	      aFunction(fn);
	      var subscription = that.subscribe({
	        next : function(value){
	          try {
	            return fn(value);
	          } catch(e){
	            reject(e);
	            subscription.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	    });
	  }
	});
	
	redefineAll($Observable, {
	  from: function from(x){
	    var C = typeof this === 'function' ? this : $Observable;
	    var method = getMethod(anObject(x)[OBSERVABLE]);
	    if(method){
	      var observable = anObject(method.call(x));
	      return observable.constructor === C ? observable : new C(function(observer){
	        return observable.subscribe(observer);
	      });
	    }
	    return new C(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          try {
	            if(forOf(x, false, function(it){
	              observer.next(it);
	              if(done)return RETURN;
	            }) === RETURN)return;
	          } catch(e){
	            if(done)throw e;
	            observer.error(e);
	            return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  },
	  of: function of(){
	    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];
	    return new (typeof this === 'function' ? this : $Observable)(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          for(var i = 0; i < items.length; ++i){
	            observer.next(items[i]);
	            if(done)return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  }
	});
	
	hide($Observable.prototype, OBSERVABLE, function(){ return this; });
	
	$export($export.G, {Observable: $Observable});
	
	__webpack_require__(192)('Observable');

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	// ie9- setTimeout & setInterval additional parameters fix
	var global     = __webpack_require__(4)
	  , $export    = __webpack_require__(8)
	  , invoke     = __webpack_require__(78)
	  , partial    = __webpack_require__(289)
	  , navigator  = global.navigator
	  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
	var wrap = function(set){
	  return MSIE ? function(fn, time /*, ...args */){
	    return set(invoke(
	      partial,
	      [].slice.call(arguments, 2),
	      typeof fn == 'function' ? fn : Function(fn)
	    ), time);
	  } : set;
	};
	$export($export.G + $export.B + $export.F * MSIE, {
	  setTimeout:  wrap(global.setTimeout),
	  setInterval: wrap(global.setInterval)
	});

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var path      = __webpack_require__(290)
	  , invoke    = __webpack_require__(78)
	  , aFunction = __webpack_require__(21);
	module.exports = function(/* ...pargs */){
	  var fn     = aFunction(this)
	    , length = arguments.length
	    , pargs  = Array(length)
	    , i      = 0
	    , _      = path._
	    , holder = false;
	  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
	  return function(/* ...args */){
	    var that = this
	      , aLen = arguments.length
	      , j = 0, k = 0, args;
	    if(!holder && !aLen)return invoke(fn, pargs, that);
	    args = pargs.slice();
	    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
	    while(aLen > k)args.push(arguments[k++]);
	    return invoke(fn, args, that);
	  };
	};

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(4);

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	  , $task   = __webpack_require__(208);
	$export($export.G + $export.B, {
	  setImmediate:   $task.set,
	  clearImmediate: $task.clear
	});

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	var $iterators    = __webpack_require__(193)
	  , redefine      = __webpack_require__(18)
	  , global        = __webpack_require__(4)
	  , hide          = __webpack_require__(10)
	  , Iterators     = __webpack_require__(129)
	  , wks           = __webpack_require__(25)
	  , ITERATOR      = wks('iterator')
	  , TO_STRING_TAG = wks('toStringTag')
	  , ArrayValues   = Iterators.Array;
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype
	    , key;
	  if(proto){
	    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
	    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	    Iterators[NAME] = ArrayValues;
	    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
	  }
	}

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };
	
	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }
	
	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  runtime.awrap = function(arg) {
	    return { __await: arg };
	  };
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	  runtime.AsyncIterator = AsyncIterator;
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      context.method = method;
	      context.arg = arg;
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }
	
	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;
	
	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }
	
	          context.dispatchException(context.arg);
	
	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          if (record.arg === ContinueSentinel) {
	            continue;
	          }
	
	          return {
	            value: record.arg,
	            done: context.done
	          };
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;
	
	      if (context.method === "throw") {
	        if (delegate.iterator.return) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined;
	          maybeInvokeDelegate(delegate, context);
	
	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }
	
	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }
	
	      return ContinueSentinel;
	    }
	
	    var record = tryCatch(method, delegate.iterator, context.arg);
	
	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }
	
	    var info = record.arg;
	
	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }
	
	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;
	
	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;
	
	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined;
	      }
	
	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }
	
	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.method = "next";
	      this.arg = undefined;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	
	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined;
	        }
	
	        return !! caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }
	
	      return this.complete(record);
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	
	      return ContinueSentinel;
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined;
	      }
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(294)))

/***/ },
/* 294 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(296);
	module.exports = __webpack_require__(9).RegExp.escape;

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/benjamingr/RexExp.escape
	var $export = __webpack_require__(8)
	  , $re     = __webpack_require__(297)(/[\\^$*+?.()|[\]{}]/g, '\\$&');
	
	$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});


/***/ },
/* 297 */
/***/ function(module, exports) {

	module.exports = function(regExp, replace){
	  var replacer = replace === Object(replace) ? function(part){
	    return replace[part];
	  } : replace;
	  return function(it){
	    return String(it).replace(regExp, replacer);
	  };
	};

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _modelerApp = __webpack_require__(299);
	
	var _modelerApp2 = _interopRequireDefault(_modelerApp);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	window.onload = function () {
	  window._TCAD_APP = new _modelerApp2.default();
	}; //import './utils/jqueryfy'
	//import './utils/three-loader'

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _toolkit = __webpack_require__(300);
	
	var _viewer = __webpack_require__(301);
	
	var _ctrl = __webpack_require__(331);
	
	var _tabSwitcher = __webpack_require__(398);
	
	var _tabSwitcher2 = _interopRequireDefault(_tabSwitcher);
	
	var _controlBar = __webpack_require__(399);
	
	var _controlBar2 = _interopRequireDefault(_controlBar);
	
	var _inputManager = __webpack_require__(400);
	
	var _actions = __webpack_require__(404);
	
	var _allActions = __webpack_require__(405);
	
	var AllActions = _interopRequireWildcard(_allActions);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _l3space = __webpack_require__(308);
	
	var _craft = __webpack_require__(410);
	
	var _sketchReader = __webpack_require__(376);
	
	var _workbench = __webpack_require__(311);
	
	var workbench = _interopRequireWildcard(_workbench);
	
	var _cadUtils = __webpack_require__(302);
	
	var cad_utils = _interopRequireWildcard(_cadUtils);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	var _io = __webpack_require__(411);
	
	var _debug = __webpack_require__(448);
	
	var _sample = __webpack_require__(449);
	
	__webpack_require__(450);
	
	var _brepBuilder = __webpack_require__(360);
	
	var BREPBuilder = _interopRequireWildcard(_brepBuilder);
	
	var _brepPrimitives = __webpack_require__(382);
	
	var BREPPrimitives = _interopRequireWildcard(_brepPrimitives);
	
	var _boolean = __webpack_require__(374);
	
	var BREPBool = _interopRequireWildcard(_boolean);
	
	var _brepValidator = __webpack_require__(375);
	
	var _brepSceneObject = __webpack_require__(379);
	
	var _tpi = __webpack_require__(454);
	
	var _tpi2 = _interopRequireDefault(_tpi);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function App() {
	  var _this = this;
	
	  this.id = this.processHints();
	  this.bus = new _toolkit.Bus();
	  this.actionManager = new _actions.ActionManager(this);
	  this.inputManager = new _inputManager.InputManager(this);
	  this.state = this.createState();
	  this.viewer = new _viewer.Viewer(this.bus, document.getElementById('viewer-container'));
	  this.actionManager.registerActions(AllActions);
	  this.tabSwitcher = new _tabSwitcher2.default($('#tab-switcher'), $('#view-3d'));
	  this.controlBar = new _controlBar2.default(this, $('#control-bar'));
	  this.TPI = _tpi2.default;
	
	  this.craft = new _craft.Craft(this);
	  this.ui = new _ctrl.UI(this);
	
	  (0, _debug.AddDebugSupport)(this);
	
	  if (this.id.startsWith('$scratch$')) {
	    setTimeout(function () {
	      return _this.scratchCode();
	    }, 0);
	  } else {
	    this.load();
	  }
	
	  this._refreshSketches();
	  this.viewer.render();
	
	  var viewer = this.viewer;
	  var app = this;
	  function storage_handler(evt) {
	    var prefix = "TCAD.projects." + app.id + ".sketch.";
	    if (evt.key.indexOf(prefix) < 0) return;
	    var sketchFaceId = evt.key.substring(prefix.length);
	    var sketchFace = app.findFace(sketchFaceId);
	    if (sketchFace != null) {
	      app.refreshSketchOnFace(sketchFace);
	      app.bus.notify('refreshSketch');
	      app.viewer.render();
	    }
	  }
	  window.addEventListener('storage', storage_handler, false);
	
	  this.bus.subscribe("craft", function () {
	    var historyEditMode = app.craft.historyPointer != app.craft.history.length;
	    if (!historyEditMode) {
	      app.viewer.selectionMgr.clear();
	    }
	    app._refreshSketches();
	  });
	}
	
	App.prototype.addShellOnScene = function (shell, skin) {
	  var sceneSolid = new _brepSceneObject.BREPSceneSolid(shell, undefined, skin);
	  this.viewer.workGroup.add(sceneSolid.cadGroup);
	  this.viewer.render();
	  return sceneSolid;
	};
	
	App.prototype.scratchCode = function () {
	  var _this2 = this;
	
	  var a = BREPBuilder.createPrism(ap.map(function (p) {
	    return new _this2.TPI.brep.geom.Point().set3(p);
	  }), 500);
	  var b = BREPBuilder.createPrism(bp.map(function (p) {
	    return new _this2.TPI.brep.geom.Point().set3(p);
	  }), 500);
	
	  this.addShellOnScene(a, {
	    color: 0x800080,
	    transparent: true,
	    opacity: 0.5
	  });
	  this.addShellOnScene(b, {
	    color: 0xfff44f,
	    transparent: true,
	    opacity: 0.5
	  });
	  //this.addShellOnScene(a);
	  //this.addShellOnScene(b);
	  var result = BREPBool.subtract(a, b);
	  this.addShellOnScene(result);
	
	  this.viewer.render();
	};
	
	App.prototype.processHints = function () {
	  var id = window.location.hash.substring(1);
	  if (!id) {
	    id = window.location.search.substring(1);
	  }
	  if (!id) {
	    id = "DEFAULT";
	  }
	  if (id == "sample") {
	    (0, _sample.init)();
	  }
	  return id;
	};
	
	App.prototype.lookAtSolid = function (solidId) {
	  this.viewer.lookAt(this.findSolidById(solidId).mesh);
	};
	
	App.prototype.createState = function () {
	  var state = {};
	  this.bus.defineObservable(state, 'showSketches', true);
	  return state;
	};
	
	App.prototype.findAllSolidsOnScene = function () {
	  return this.viewer.workGroup.children.filter(function (obj) {
	    return obj.__tcad_solid !== undefined;
	  }).map(function (obj) {
	    return obj.__tcad_solid;
	  });
	};
	
	App.prototype.findFace = function (faceId) {
	  var solids = this.craft.solids;
	  for (var i = 0; i < solids.length; i++) {
	    var solid = solids[i];
	    for (var j = 0; j < solid.sceneFaces.length; j++) {
	      var face = solid.sceneFaces[j];
	      if (face.id == faceId) {
	        return face;
	      }
	    }
	  }
	  return null;
	};
	
	App.prototype.findSolidByCadId = function (cadId) {
	  var solids = this.craft.solids;
	  for (var i = 0; i < solids.length; i++) {
	    var solid = solids[i];
	    if (solid.tCadId == cadId) {
	      return solid;
	    }
	  }
	  return null;
	};
	
	App.prototype.findSolidById = function (solidId) {
	  var solids = this.craft.solids;
	  for (var i = 0; i < solids.length; i++) {
	    var solid = solids[i];
	    if (solid.id == solidId) {
	      return solid;
	    }
	  }
	  return null;
	};
	
	App.prototype.indexEntities = function () {
	  var out = { solids: {}, faces: {} };
	  var solids = this.craft.solids;
	  for (var i = 0; i < solids.length; i++) {
	    var solid = solids[i];
	    out.solids[solid.tCadId] = solid;
	    for (var j = 0; j < solid.sceneFaces.length; j++) {
	      var face = solid.sceneFaces[j];
	      out.faces[face.id] = face;
	    }
	  }
	  return out;
	};
	
	App.STORAGE_PREFIX = "TCAD.projects.";
	
	App.prototype.faceStorageKey = function (polyFaceId) {
	  return App.STORAGE_PREFIX + this.id + ".sketch." + polyFaceId;
	};
	
	App.prototype.projectStorageKey = function (polyFaceId) {
	  return App.STORAGE_PREFIX + this.id;
	};
	
	App.prototype.editFace = function () {
	  if (this.viewer.selectionMgr.selection.length == 0) {
	    return;
	  }
	  var polyFace = this.viewer.selectionMgr.selection[0];
	  this.sketchFace(polyFace);
	};
	
	App.prototype.sketchFace = function (sceneFace) {
	  var faceStorageKey = this.faceStorageKey(sceneFace.id);
	
	  var savedFace = localStorage.getItem(faceStorageKey);
	  var data;
	  if (savedFace == null) {
	    data = {};
	  } else {
	    data = JSON.parse(savedFace);
	  }
	  data.boundary = { lines: [], arcs: [], circles: [] };
	  function sameSketchObject(a, b) {
	    if (a.sketchConnectionObject === undefined || b.sketchConnectionObject === undefined) {
	      return false;
	    }
	    return a.sketchConnectionObject.id === b.sketchConnectionObject.id;
	  }
	
	  var paths = sceneFace.getBounds();
	
	  //sceneFace.polygon.collectPaths(paths);
	  var _3dTransformation = new _l3space.Matrix3().setBasis(sceneFace.basis());
	  var _2dTr = _3dTransformation.invert();
	
	  function addSegment(a, b) {
	    data.boundary.lines.push({
	      a: { x: a.x, y: a.y },
	      b: { x: b.x, y: b.y }
	    });
	  }
	
	  function addArc(arc) {
	    function addArcAsSegments(arc) {
	      for (var i = 1; i < arc.length; i++) {
	        addSegment(arc[i - 1], arc[i]);
	      }
	    }
	    if (arc.length < 5) {
	      addArcAsSegments(arc);
	      return;
	    }
	    var a = arc[1],
	        b = arc[arc.length - 2];
	
	    var mid = arc.length / 2 >> 0;
	    var c = math.circleFromPoints(a, arc[mid], b);
	    if (c == null) {
	      addArcAsSegments(arc);
	      return;
	    }
	
	    var dist = math.distanceAB;
	
	    var rad = dist(a, c);
	
	    if (Math.abs(rad - dist(b, c)) > math.TOLERANCE) {
	      addArcAsSegments(arc);
	      return;
	    }
	
	    var firstPoint = arc[0];
	    var lastPoint = arc[arc.length - 1];
	    if (Math.abs(rad - dist(firstPoint, c)) < math.TOLERANCE) {
	      a = firstPoint;
	    } else {
	      addSegment(firstPoint, a);
	    }
	
	    if (Math.abs(rad - dist(lastPoint, c)) < math.TOLERANCE) {
	      b = lastPoint;
	    } else {
	      addSegment(b, lastPoint);
	    }
	
	    if (!cad_utils.isCCW([a, arc[mid], b])) {
	      var t = a;
	      a = b;
	      b = t;
	    }
	    data.boundary.arcs.push({
	      a: { x: a.x, y: a.y },
	      b: { x: b.x, y: b.y },
	      c: { x: c.x, y: c.y }
	    });
	  }
	  function addCircle(circle) {
	    var n = circle.length;
	    //var c = math.circleFromPoints(circle[0], circle[((n / 3) >> 0) % n], circle[((2 * n / 3) >> 0) % n]);
	    var c = math.circleFromPoints(circle[0], circle[1], circle[2]);
	    if (c === null) return;
	    var r = math.distanceAB(circle[0], c);
	    data.boundary.circles.push({
	      c: { x: c.x, y: c.y },
	      r: r
	    });
	  }
	  function isCircle(path) {
	    for (var i = 0; i < path.length; i++) {
	      var p = path[i];
	      if (p.sketchConnectionObject === undefined || p.sketchConnectionObject._class !== 'TCAD.TWO.Circle' || p.sketchConnectionObject.id !== path[0].sketchConnectionObject.id) {
	        return false;
	      }
	    }
	    return true;
	  }
	
	  function trPath(path) {
	    var out = [];
	    for (var i = 0; i < path.length; i++) {
	      out.push(_2dTr.apply(path[i]));
	    }
	    return out;
	  }
	
	  for (var i = 0; i < paths.length; i++) {
	    var path = paths[i];
	    if (path.length < 3) continue;
	    var shift = 0;
	    if (isCircle(path)) {
	      addCircle(trPath(path));
	      continue;
	    }
	    cad_utils.iteratePath(path, 0, function (a, b, ai, bi) {
	      shift = bi;
	      return sameSketchObject(a, b);
	    });
	    var currSko = null;
	    var arc = null;
	    cad_utils.iteratePath(path, shift + 1, function (a, b, ai, bi, iterNumber, path) {
	      var isArc = a.sketchConnectionObject !== undefined && (a.sketchConnectionObject._class == 'TCAD.TWO.Arc' || a.sketchConnectionObject._class == 'TCAD.TWO.Circle'); //if circle gets splitted
	      var a2d = _2dTr.apply(a);
	      if (isArc) {
	        if (currSko !== a.sketchConnectionObject.id) {
	          currSko = a.sketchConnectionObject.id;
	          if (arc != null) {
	            arc.push(a2d);
	            addArc(arc);
	          }
	          arc = [];
	        }
	        arc.push(a2d);
	        if (iterNumber === path.length - 1) {
	          arc.push(_2dTr.apply(b));
	          addArc(arc);
	        }
	      } else {
	        if (arc != null) {
	          arc.push(a2d);
	          addArc(arc);
	          arc = null;
	        }
	        currSko = null;
	        addSegment(a2d, _2dTr.apply(b));
	      }
	      return true;
	    });
	  }
	
	  localStorage.setItem(faceStorageKey, JSON.stringify(data));
	  var sketchURL = faceStorageKey.substring(App.STORAGE_PREFIX.length);
	  this.tabSwitcher.showSketch(sketchURL, sceneFace.id);
	};
	
	App.prototype.extrude = function () {
	
	  if (this.viewer.selectionMgr.selection.length == 0) {
	    return;
	  }
	  var polyFace = this.viewer.selectionMgr.selection[0];
	  var height = prompt("Height", "50");
	  if (!height) return;
	
	  var app = this;
	  var solids = [polyFace.solid];
	  this.craft.modify({
	    type: 'EXTRUDE',
	    solids: solids,
	    face: polyFace,
	    height: height
	  });
	};
	
	App.prototype.cut = function () {
	
	  if (this.viewer.selectionMgr.selection.length == 0) {
	    return;
	  }
	  var polyFace = this.viewer.selectionMgr.selection[0];
	  var depth = prompt("Depth", "50");
	  if (!depth) return;
	
	  var app = this;
	  var solids = [polyFace.solid];
	  this.craft.modify({
	    type: 'CUT',
	    solids: solids,
	    face: polyFace,
	    depth: depth
	  });
	};
	
	App.prototype.refreshSketches = function () {
	  this._refreshSketches();
	  this.bus.notify('refreshSketch');
	  this.viewer.render();
	};
	
	App.prototype._refreshSketches = function () {
	  var allSolids = this.craft.solids;
	  for (var oi = 0; oi < allSolids.length; ++oi) {
	    var obj = allSolids[oi];
	    for (var i = 0; i < obj.sceneFaces.length; i++) {
	      var sketchFace = obj.sceneFaces[i];
	      this.refreshSketchOnFace(sketchFace);
	    }
	  }
	};
	
	App.prototype.findSketches = function (solid) {
	  var _this3 = this;
	
	  return solid.sceneFaces.filter(function (f) {
	    return _this3.faceStorageKey(f.id) in localStorage;
	  }).map(function (f) {
	    return f.id;
	  });
	};
	
	App.prototype.refreshSketchOnFace = function (sketchFace) {
	  var faceStorageKey = this.faceStorageKey(sketchFace.id);
	  var savedFace = localStorage.getItem(faceStorageKey);
	  if (savedFace != null) {
	    var geom = (0, _sketchReader.ReadSketch)(JSON.parse(savedFace), sketchFace.id, true);
	    sketchFace.syncSketches(geom);
	  }
	};
	
	App.prototype.save = function () {
	  var data = {};
	  data.history = this.craft.history;
	  localStorage.setItem(this.projectStorageKey(), JSON.stringify(data));
	};
	
	App.prototype.load = function () {
	  var project = localStorage.getItem(this.projectStorageKey());
	  if (!!project) {
	    var data = JSON.parse(project);
	    if (!!data.history) {
	      this.craft.loadHistory(data.history);
	    }
	  }
	};
	
	App.prototype.stlExport = function () {
	  var allPolygons = cad_utils.arrFlatten1L(this.craft.solids.map(function (s) {
	    return s.csg.toPolygons();
	  }));
	  var stl = CSG.fromPolygons(allPolygons).toStlString();
	  _io.IO.exportTextData(stl.data[0], this.id + ".stl");
	};
	
	App.prototype.showInfo = function () {
	  alert('men at work');
	};
	
	exports.default = App;

/***/ },
/* 300 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.add = add;
	exports.methodRef = methodRef;
	exports.Box = Box;
	exports.Panel = Panel;
	exports.Folder = Folder;
	exports.Button = Button;
	exports.CheckBox = CheckBox;
	exports.InlineRadio = InlineRadio;
	exports.propLayout = propLayout;
	exports.Text = Text;
	exports.Combo = Combo;
	exports.ButtonRow = ButtonRow;
	exports.List = List;
	exports.Tree = Tree;
	exports.Parameters = Parameters;
	exports.Bus = Bus;
	exports.config = config;
	function add(parent, child) {
	  parent.content.append(child.root);
	}
	
	function methodRef(_this, methodName, args) {
	  return function () {
	    _this[methodName].apply(_this, args);
	  };
	}
	
	function Box(parent) {
	  this.root = this.content = $('<div class="tc-box" />');
	  this.root.addClass('tc-box tc-scroll');
	  this.root.appendTo(parent ? parent : 'body');
	}
	
	Box.prototype.close = function () {
	  this.root.remove();
	};
	
	function Panel() {
	  this.root = this.content = $('<div />');
	  this.root.addClass('tc-panel tc-scroll');
	}
	
	Panel.prototype.close = function () {
	  this.root.remove();
	};
	
	function Folder(title) {
	  this.root = $('<div/>', { 'class': 'tc-folder' });
	  this.content = $('<div/>');
	  this.root.append($('<div/>', { text: title, 'class': 'tc-row tc-title' }));
	  this.root.append(this.content);
	}
	
	function Button(title) {
	  this.root = $('<div/>', { 'class': 'tc-row tc-ctrl tc-ctrl-btn', text: title });
	}
	
	function CheckBox(title, checked) {
	  this.root = $('<div/>', { 'class': 'tc-row tc-ctrl' });
	  this.root.append('<label><input type="checkbox">' + title + '</label>');
	  this.input = this.root.find("input");
	  this.input.prop('checked', !!checked);
	}
	
	function InlineRadio(choiceLabels, choiceValues, checkedIndex) {
	  var name = 'TCAD.toolkit.InlineRadio_' + InlineRadio.COUNTER++;
	  this.root = $('<div/>', { 'class': 'tc-row tc-ctrl tc-inline-radio' });
	  this.inputs = [];
	  for (var i = 0; i < choiceLabels.length; i++) {
	    var checked = checkedIndex === i ? "checked" : '';
	    var label = $('<label><input type="radio" name="' + name + '" value="' + choiceValues[i] + '"><span>' + choiceLabels[i] + '</span></label>');
	    this.inputs.push(label.find("input"));
	    this.root.append(label);
	  }
	  this.inputs[checkedIndex].prop('checked', true);
	}
	
	InlineRadio.prototype.getValue = function () {
	  for (var i = 0; i < this.inputs.length; i++) {
	    if (this.inputs[i].prop('checked')) {
	      return this.inputs[i].attr('value');
	    }
	  }
	  return null;
	};
	
	InlineRadio.prototype.setValue = function (v) {
	  this.root.find('input[value=' + v + ']').prop('checked', true);
	};
	
	InlineRadio.COUNTER = 0;
	
	function propLayout(root, name, valueEl) {
	  root.append($('<span/>', { 'class': 'tc-prop-name', text: name })).append($('<div/>', { 'class': 'tc-prop-value' }).append(valueEl));
	}
	
	function NumberWidget(name, initValue, baseStep, round) {
	  this.root = $('<div/>', { 'class': 'tc-row tc-ctrl tc-ctrl-number' });
	  this.input = $("<input type='text' value='" + initValue + "' />");
	  this.slide = false;
	  baseStep = baseStep || 1;
	  round = round || 0;
	  this.min = null;
	  this.max = null;
	  this.accelerator = 100;
	  var scope = this;
	  var lastValue = null;
	  function trigger() {
	    if ($(this).val() !== lastValue) {
	      $(this).trigger('t-change');
	      lastValue = $(this).val();
	    }
	  }
	
	  this.input.on('input', function (e) {
	    var val = $(this).val();
	    //var floatRegex = /[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/;
	    //if (!floatRegex.test(val)) {
	    //  $(this).val(val.replace(/[^0-9\.-]/g, ''));
	    //}
	    trigger.call(this);
	  });
	  this.input.get(0).addEventListener('mousewheel', function (e) {
	    var delta = 0;
	    if (e.wheelDelta) {
	      // WebKit / Opera / Explorer 9
	      delta = e.wheelDelta;
	    } else if (e.detail) {
	      // Firefox
	      delta = -e.detail;
	    }
	    var val = $(this).val();
	    if (!val) val = 0;
	    var step = baseStep * (e.shiftKey ? scope.accelerator : 1);
	    val = parseFloat(val) + (delta < 0 ? -step : step);
	    if (scope.min != null && val < scope.min) {
	      val = scope.min;
	    }
	    if (scope.max != null && val > scope.max) {
	      val = scope.max;
	    }
	    if (round !== 0) {
	      val = val.toFixed(round);
	    }
	    $(this).val(val);
	    e.preventDefault();
	    e.stopPropagation();
	    trigger.call(this);
	  }, false);
	  propLayout(this.root, name, this.input);
	}
	
	NumberWidget.prototype.val = function () {
	  return Number(this.input.val());
	};
	
	function Text(name, initValue) {
	  this.root = $('<div/>', { 'class': 'tc-row tc-ctrl' });
	  this.input = $("<input type='text' value='" + initValue + "' />");
	  propLayout(this.root, name, this.input);
	}
	
	function Combo(id, labelText) {
	  this.root = $('<div/>', { 'class': 'tc-row tc-ctrl tc-ctrl-combo' });
	  var label = $('<span/>', { 'class': 'tc-prop-name', text: labelText });
	  this.select = $('<select>', { id: id });
	  this.root.append(label).append($('<div/>', { 'class': 'tc-prop-value' }).append(this.select));
	}
	
	function ButtonRow(captions, actions) {
	
	  this.root = $('<div/>', { 'class': 'tc-row tc-ctrl tc-buttons-block' });
	
	  function withAction(btn, action) {
	    return btn.click(function () {
	      action.call();
	    });
	  }
	  for (var i = 0; i < captions.length; i++) {
	    var caption = captions[i];
	    var btn = $('<span/>', {
	      text: caption,
	      'class': 'tc-block-btn active-btn'
	    });
	    withAction(btn, actions[i]);
	    this.root.append(btn);
	  }
	}
	
	function List() {
	  this.root = $('<div/>', { 'class': 'tc-list' });
	}
	
	List.prototype.addRow = function (name) {
	  var row = $('<div/>', {
	    text: name, 'class': 'tc-row tc-pseudo-btn'
	  });
	  this.root.append(row);
	  return row;
	};
	
	List.setIconForRow = function (row, icon) {
	  row.css({
	    'background-image': 'url(' + icon + ')'
	  });
	};
	
	function Tree() {
	  this.root = $('<div/>', { 'class': 'tc-tree' });
	}
	
	Tree.prototype.set = function (data) {
	  this.root.empty();
	  this._fill(data, 0);
	};
	
	Tree.prototype._fill = function (data, level) {
	  var notLeaf = data.children !== undefined && data.children.length !== 0;
	  if (data.name !== undefined) {
	    this.root.append($('<div/>', {
	      text: data.name, 'class': 'tc-row' + (notLeaf ? ' tc-chevron-open' : ''),
	      css: { 'margin-left': level * (notLeaf ? 10 : 16) + 'px' }
	    }));
	  }
	  if (notLeaf) {
	    for (var i = 0; i < data.children.length; i++) {
	      var child = data.children[i];
	      this._fill(child, level + 1);
	    }
	  }
	};
	
	function Parameters() {
	  this.listeners = {};
	}
	
	Parameters.prototype.define = function (name, initValue) {
	  function fn(name) {
	    return '___' + name;
	  }
	  this[fn(name)] = initValue;
	  return Object.defineProperty(this, name, {
	    get: function get() {
	      return this[fn(name)];
	    },
	    set: function set(value) {
	      var oldValue = this[fn(name)];
	      this[fn(name)] = value;
	      this.notify(name, value, oldValue);
	    }
	  });
	};
	
	Parameters.prototype.subscribe = function (name, listenerId, callback, scope) {
	  var listenerList = this.listeners[name];
	  if (listenerList === undefined) {
	    listenerList = [];
	    this.listeners[name] = listenerList;
	  }
	  var callbackFunc = scope === undefined ? callback : function () {
	    callback.apply(scope, arguments);
	  };
	  listenerList.push([listenerId, callbackFunc]);
	  var params = this;
	  return function () {
	    callbackFunc(params[name], undefined, null);
	  }; // return init function
	};
	
	Parameters.prototype.notify = function (name, newValue, oldValue) {
	  var listenerList = this.listeners[name];
	  if (listenerList !== undefined) {
	    for (var i = 0; i < listenerList.length; i++) {
	      var listenerId = listenerList[i][0];
	      var callback = listenerList[i][1];
	      if (listenerId == null || this.__currentSender == null || listenerId != this.__currentSender) {
	        callback(newValue, oldValue, this.__currentSender);
	      }
	    }
	  }
	  this.__currentSender = null;
	};
	
	Parameters.prototype.set = function (name, value, sender) {
	  this.__currentSender = sender;
	  this[name] = value;
	};
	
	function Bus() {
	  this.listeners = {};
	}
	
	Bus.prototype.subscribe = function (event, callback, listenerId) {
	  var listenerList = this.listeners[event];
	  if (listenerList === undefined) {
	    listenerList = [];
	    this.listeners[event] = listenerList;
	  }
	  if (listenerId == undefined) listenerId = null;
	  listenerList.push([callback, listenerId]);
	  return callback;
	};
	
	Bus.prototype.unsubscribe = function (event, callback) {
	  var listenerList = this.listeners[event];
	  for (var i = 0; i < listenerList.length; i++) {
	    if (listenerList[i][0] === callback) {
	      listenerList.splice(i, 1);
	      return;
	    }
	  }
	};
	
	Bus.prototype.notify = function (event, data, sender) {
	  var listenerList = this.listeners[event];
	  if (listenerList !== undefined) {
	    for (var i = 0; i < listenerList.length; i++) {
	      var callback = listenerList[i][0];
	      var listenerId = listenerList[i][1];
	      if (sender == undefined || listenerId == null || listenerId != sender) {
	        try {
	          callback(data);
	        } catch (e) {
	          console.error(e);
	        }
	      }
	    }
	  }
	};
	
	Bus.Observable = function (initValue) {
	  this.value = initValue;
	};
	
	Bus.prototype.defineObservable = function (scope, name, initValue, eventName) {
	  if (eventName == undefined) eventName = name;
	  var observable = new Bus.Observable(initValue);
	  var bus = this;
	  return Object.defineProperty(scope, name, {
	    get: function get() {
	      return observable.value;
	    },
	    set: function set(value) {
	      observable.value = value;
	      bus.notify(eventName, value);
	    }
	  });
	};
	
	function config(obj, props) {
	  for (var key in props) {
	    obj[key] = props[key];
	  }
	  return obj;
	}
	
	exports.Number = NumberWidget;

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Viewer = exports.PICK_KIND = undefined;
	
	var _cadUtils = __webpack_require__(302);
	
	var cad_utils = _interopRequireWildcard(_cadUtils);
	
	var _l3space = __webpack_require__(308);
	
	var _dpr = __webpack_require__(325);
	
	var _dpr2 = _interopRequireDefault(_dpr);
	
	var _mask = __webpack_require__(327);
	
	var mask = _interopRequireWildcard(_mask);
	
	var _selection = __webpack_require__(328);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function Viewer(bus, container) {
	  var _this = this;
	
	  this.bus = bus;
	  function aspect() {
	    return container.clientWidth / container.clientHeight;
	  }
	  this.scene = new THREE.Scene();
	  var scene = this.scene;
	  this.camera = new THREE.PerspectiveCamera(500 * 75, aspect(), 0.1, 10000);
	  this.camera.position.z = 1000;
	  this.camera.position.x = -1000;
	  this.camera.position.y = 300;
	  var light = new THREE.PointLight(0xffffff);
	  light.position.set(10, 10, 10);
	  scene.add(light);
	
	  this.renderer = new THREE.WebGLRenderer();
	  this.renderer.setPixelRatio(_dpr2.default);
	  this.renderer.setClearColor(0x808080, 1);
	  this.renderer.setSize(container.clientWidth, container.clientHeight);
	  container.appendChild(this.renderer.domElement);
	
	  this.render = function () {
	    light.position.set(this.camera.position.x, this.camera.position.y, this.camera.position.z);
	    this.renderer.render(scene, this.camera);
	  };
	
	  window.addEventListener('resize', function () {
	    _this.camera.aspect = aspect();
	    _this.camera.updateProjectionMatrix();
	    _this.renderer.setSize(container.clientWidth, container.clientHeight);
	    _this.render();
	  }, false);
	
	  //  controls = new THREE.OrbitControls( camera , renderer.domElement);
	  var trackballControls = new THREE.TrackballControls(this.camera, this.renderer.domElement);
	
	  // document.addEventListener( 'mousemove', function(){
	
	  //   controls.update();
	
	  // }, false );
	  trackballControls.rotateSpeed = 3.8;
	  trackballControls.zoomSpeed = 1.2;
	  trackballControls.panSpeed = 0.8;
	
	  trackballControls.noZoom = false;
	  trackballControls.noPan = false;
	
	  trackballControls.staticMoving = true;
	  trackballControls.dynamicDampingFactor = 0.3;
	
	  trackballControls.keys = [65, 83, 68];
	  trackballControls.addEventListener('change', function () {
	    return _this.render();
	  });
	  this.trackballControls = trackballControls;
	
	  var transformControls = new THREE.TransformControls(this.camera, this.renderer.domElement);
	  transformControls.addEventListener('change', function () {
	    return _this.render();
	  });
	  scene.add(transformControls);
	  this.transformControls = transformControls;
	
	  this.updateTransformControls = function () {
	    if (transformControls.object !== undefined) {
	      if (transformControls.object.parent === undefined) {
	        transformControls.detach();
	        this.render();
	      }
	      transformControls.update();
	    }
	  };
	
	  function addAxis(axis, color) {
	    var lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 1 / _dpr2.default });
	    var axisGeom = new THREE.Geometry();
	    axisGeom.vertices.push(axis.multiply(-1000).three());
	    axisGeom.vertices.push(axis.multiply(1000).three());
	    scene.add(new THREE.Line(axisGeom, lineMaterial));
	  }
	  addAxis(_l3space.AXIS.X, 0xFF0000);
	  addAxis(_l3space.AXIS.Y, 0x00FF00);
	  addAxis(_l3space.AXIS.Z, 0x0000FF);
	
	  this.updateControlsAndHelpers = function () {
	    trackballControls.update();
	    this.updateTransformControls();
	  };
	
	  this.workGroup = new THREE.Object3D();
	  this.scene.add(this.workGroup);
	  this.createBasisGroup();
	  this.selectionMgr = new _selection.SelectionManager(this, 0xFAFAD2, 0xFF0000, null);
	  this.sketchSelectionMgr = new _selection.SketchSelectionManager(this, new THREE.LineBasicMaterial({ color: 0xFF0000, linewidth: 6 / _dpr2.default }));
	  this.edgeSelectionMgr = new _selection.EdgeSelectionManager(this, new THREE.LineBasicMaterial({ color: 0xFA8072, linewidth: 12 / _dpr2.default }));
	  var viewer = this;
	
	  var raycaster = new THREE.Raycaster();
	
	  this.raycast = function (event) {
	    raycaster.linePrecision = 12 * (this.zoomMeasure() * 0.8);
	    var x = event.offsetX / container.clientWidth * 2 - 1;
	    var y = -(event.offsetY / container.clientHeight) * 2 + 1;
	
	    var mouse = new THREE.Vector3(x, y, 1);
	    raycaster.setFromCamera(mouse, this.camera);
	    return raycaster.intersectObjects(viewer.workGroup.children, true);
	  };
	
	  function onClick(e) {
	    if (e.button != 0) {
	      viewer.handleSolidPick(e);
	    } else {
	      viewer.handlePick(e);
	    }
	  }
	
	  var mouseState = {
	    startX: 0,
	    startY: 0
	  };
	
	  //fix for FireFox
	  function fixOffsetAPI(event) {
	    if (event.offsetX == undefined) {
	      event.offsetX = event.layerX;
	      event.offsetY = event.layerY;
	    }
	  }
	
	  this.renderer.domElement.addEventListener('mousedown', function (e) {
	    fixOffsetAPI(e);
	    mouseState.startX = e.offsetX;
	    mouseState.startY = e.offsetY;
	  }, false);
	
	  this.renderer.domElement.addEventListener('mouseup', function (e) {
	    fixOffsetAPI(e);
	    var dx = Math.abs(mouseState.startX - e.offsetX);
	    var dy = Math.abs(mouseState.startY - e.offsetY);
	    var TOL = 1;
	    if (dx < TOL && dy < TOL) {
	      onClick(e);
	    }
	  }, false);
	
	  this.animate = function () {
	    var _this2 = this;
	
	    requestAnimationFrame(function () {
	      return _this2.animate();
	    });
	    this.updateControlsAndHelpers();
	  };
	
	  this.render();
	  this.animate();
	}
	
	Viewer.prototype.updateZoomLineThickness = function () {
	  var _this3 = this;
	
	  this.workGroup.traverse(function (object) {
	    if (object instanceof THREE.Mesh && object.__TCAD_EDGE) {
	      var zoomMeasure = _this3.zoomMeasure();
	      object.scale.set(zoomMeasure, zoomMeasure, object.scale.z);
	    }
	  });
	};
	
	Viewer.prototype.zoomMeasure = function () {
	  return this.trackballControls.object.position.length() / 1e3;
	};
	
	Viewer.prototype.createBasisGroup = function () {
	  this.basisGroup = new THREE.Object3D();
	  var length = 200;
	  var arrowLength = length * 0.2;
	  var arrowHead = arrowLength * 0.4;
	
	  function createArrow(axis, color) {
	    var arrow = new THREE.ArrowHelper(axis, new THREE.Vector3(0, 0, 0), length, color, arrowLength, arrowHead);
	    arrow.updateMatrix();
	    arrow.matrixAutoUpdate = false;
	    arrow.line.renderOrder = 1e11;
	    arrow.cone.renderOrder = 1e11;
	    arrow.line.material.linewidth = 1 / _dpr2.default;
	    arrow.line.material.depthWrite = false;
	    arrow.line.material.depthTest = false;
	    arrow.cone.material.depthWrite = false;
	    arrow.cone.material.depthTest = false;
	    return arrow;
	  }
	
	  var xAxis = createArrow(new THREE.Vector3(1, 0, 0), 0xFF0000);
	  var yAxis = createArrow(new THREE.Vector3(0, 1, 0), 0x00FF00);
	  this.basisGroup.add(xAxis);
	  this.basisGroup.add(yAxis);
	};
	
	Viewer.prototype.updateBasis = function (basis, depth) {
	  this.basisGroup.matrix.identity();
	  var mx = new THREE.Matrix4();
	  mx.makeBasis(basis[0].three(), basis[1].three(), basis[2].three());
	  var depthOff = new THREE.Vector3(0, 0, depth);
	  depthOff.applyMatrix4(mx);
	  mx.setPosition(depthOff);
	  this.basisGroup.applyMatrix(mx);
	};
	
	Viewer.prototype.showBasis = function () {
	  this.workGroup.add(this.basisGroup);
	};
	
	Viewer.prototype.hideBasis = function () {
	  if (this.basisGroup.parent !== null) {
	    this.basisGroup.parent.remove(this.basisGroup);
	  }
	};
	
	Viewer.prototype.lookAt = function (obj) {
	  var box = new THREE.Box3();
	  box.setFromObject(obj);
	  var size = box.size();
	  //this.camera.position.set(0,0,0);
	  box.center(this.camera.position);
	  var maxSize = Math.max(size.x, size.z);
	  var dist = maxSize / 2 / Math.tan(Math.PI * this.camera.fov / 360);
	  this.camera.position.addScaledVector(this.camera.position.normalize(), 5000);
	
	  //this.camera.position.sub(new THREE.Vector3(0, 0, dist));
	  this.camera.up = new THREE.Vector3(0, 1, 0);
	
	  this.render();
	};
	
	Viewer.prototype.handleSolidPick = function (e) {
	  var _this4 = this;
	
	  this.raycastObjects(event, PICK_KIND.FACE, function (sketchFace) {
	    _this4.selectionMgr.clear();
	    _this4.bus.notify("solid-pick", sketchFace.solid);
	    _this4.render();
	    return false;
	  });
	};
	
	var PICK_KIND = exports.PICK_KIND = {
	  FACE: mask.type(1),
	  SKETCH: mask.type(2),
	  EDGE: mask.type(3),
	  VERTEX: mask.type(4)
	};
	
	Viewer.prototype.raycastObjects = function (event, kind, visitor) {
	  var pickResults = this.raycast(event);
	  var pickers = [function (pickResult) {
	    if (mask.is(kind, PICK_KIND.SKETCH) && pickResult.object instanceof THREE.Line && pickResult.object.__TCAD_SketchObject !== undefined) {
	      return !visitor(pickResult.object, PICK_KIND.SKETCH);
	    }
	    return false;
	  }, function (pickResult) {
	    if (mask.is(kind, PICK_KIND.EDGE) && pickResult.object.__TCAD_EDGE !== undefined) {
	      return !visitor(pickResult.object, PICK_KIND.EDGE);
	    }
	    return false;
	  }, function (pickResult) {
	    if (mask.is(kind, PICK_KIND.FACE) && !!pickResult.face && pickResult.face.__TCAD_SceneFace !== undefined) {
	      var sketchFace = pickResult.face.__TCAD_SceneFace;
	      return !visitor(sketchFace, PICK_KIND.FACE);
	    }
	    return false;
	  }];
	  for (var i = 0; i < pickResults.length; i++) {
	    var pickResult = pickResults[i];
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = pickers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var picker = _step.value;
	
	        if (picker(pickResult)) {
	          return;
	        }
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	  }
	};
	
	Viewer.prototype.handlePick = function (event) {
	  var _this5 = this;
	
	  this.raycastObjects(event, PICK_KIND.FACE | PICK_KIND.SKETCH | PICK_KIND.EDGE, function (object, kind) {
	    if (kind == PICK_KIND.FACE) {
	      if (_this5.selectionMgr.pick(object)) {
	        return false;
	      }
	    } else if (kind == PICK_KIND.SKETCH) {
	      if (_this5.sketchSelectionMgr.pick(object)) {
	        return false;
	      }
	    } else if (kind == PICK_KIND.EDGE) {
	      if (_this5.edgeSelectionMgr.pick(object)) {
	        return false;
	      }
	    }
	    return true;
	  });
	};
	
	exports.Viewer = Viewer;

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.CURVE_CLASSES = exports.isCCW = exports.area = exports.isPointInsidePolygon = exports.FACE_COLOR = undefined;
	exports.createSquare = createSquare;
	exports.csgVec = csgVec;
	exports.vec = vec;
	exports.createBox = createBox;
	exports.createCSGBox = createCSGBox;
	exports.createSphere = createSphere;
	exports.checkPolygon = checkPolygon;
	exports.createPoint0 = createPoint0;
	exports.createPoint1 = createPoint1;
	exports.createLine = createLine;
	exports.createSolidMaterial = createSolidMaterial;
	exports.createSolid = createSolid;
	exports.intercept = intercept;
	exports.createPlane = createPlane;
	exports.fixCCW = fixCCW;
	exports.someBasis2 = someBasis2;
	exports.someBasis = someBasis;
	exports.normalOfCCWSeq = normalOfCCWSeq;
	exports.normalOfCCWSeqTHREE = normalOfCCWSeqTHREE;
	exports.calculateExtrudedLid = calculateExtrudedLid;
	exports.extrude = extrude;
	exports.triangulate = triangulate;
	exports.createShared = createShared;
	exports.isCurveClass = isCurveClass;
	exports.isSmoothPiece = isSmoothPiece;
	exports.Polygon = Polygon;
	exports.Sketch = Sketch;
	exports.iteratePath = iteratePath;
	exports.addAll = addAll;
	exports.arrFlatten1L = arrFlatten1L;
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _bbox = __webpack_require__(305);
	
	var _bbox2 = _interopRequireDefault(_bbox);
	
	var _hashmap = __webpack_require__(306);
	
	var _graph = __webpack_require__(307);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	var _l3space = __webpack_require__(308);
	
	var _counters = __webpack_require__(309);
	
	var _counters2 = _interopRequireDefault(_counters);
	
	var _meshSceneObject = __webpack_require__(310);
	
	var _dpr = __webpack_require__(325);
	
	var _dpr2 = _interopRequireDefault(_dpr);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var FACE_COLOR = exports.FACE_COLOR = 0xB0C4DE;
	
	function createSquare(w, h) {
	
	  w /= 2;
	  h /= 2;
	
	  return [new _vector2.default(-w, -h, 0), new _vector2.default(w, -h, 0), new _vector2.default(w, h, 0), new _vector2.default(-w, h, 0)];
	}
	
	function csgVec(v) {
	  return new CSG.Vector3D(v.x, v.y, v.z);
	}
	
	function vec(v) {
	  return new _vector2.default(v.x, v.y, v.z);
	}
	
	function createBox(w, h, d) {
	  var square = createSquare(w, h);
	  //var rot = Matrix3.rotateMatrix(3/4, AXIS.Z, ORIGIN);
	  var halfDepth = d / 2;
	  square.forEach(function (v) {
	    v.z -= halfDepth;
	  });
	  var normal = normalOfCCWSeq(square);
	  return extrude(square, normal, normal.multiply(d), 1);
	}
	
	function createCSGBox(w, h, d) {
	  var csg = CSG.fromPolygons(createBox(w, h, d));
	  return createSolid(csg);
	}
	
	function createSphere(radius) {
	  var csg = CSG.sphere({ radius: radius, resolution: 48 });
	  var shared = createShared();
	  shared.__tcad.csgInfo = {
	    derivedFrom: {
	      id: 0,
	      _class: 'TCAD.TWO.Circle'
	    }
	  };
	  for (var i = 0; i < csg.polygons.length; i++) {
	    var poly = csg.polygons[i];
	    poly.shared = shared;
	  }
	  var solid = createSolid(csg);
	  solid.cadGroup.remove(solid.wireframeGroup);
	  return solid;
	}
	
	function checkPolygon(poly) {
	  if (poly.length < 3) {
	    throw new Error('Polygon should contain at least 3 point');
	  }
	}
	
	function createPoint0(x, y, z) {
	  //  var g = new THREE.PlaneGeometry(0.05, 0.05);
	  //  var m = new THREE.MeshBasicMaterial({color: 0x0000ff, side: THREE.DoubleSide});
	  //  return new THREE.Mesh(g, m);
	
	  var material = new THREE.ShaderMaterial({
	    //    color: 0xff0000,
	    //    linewidth: 5
	    vertexShader: 'void main() {\n\t' + 'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );' + 'gl_PointSize =10.0;\n\t' + '\n}',
	
	    fragmentShader: 'void main() {\n\t' + "vec2 coord = gl_PointCoord - vec2(0.5);  //from [0,1] to [-0.5,0.5]\n" + "if(length(coord) > 0.5)                  //outside of circle radius?\n" + "    discard;\n" + "else\n" + "    gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n" + '\n}'
	  });
	
	  var geometry = new THREE.Geometry();
	  geometry.vertices.push(new THREE.Vector3(x, y, z));
	  //  geometry.vertices.push(new THREE.Vector3(x+.001, y+.001, z+.001));
	
	  //  var line = new THREE.PointCloud(geometry, material);
	  //  line.position.x = x;
	  //  line.position.y = y;
	  //  line.position.z = z;
	  //  return line;
	
	  material = new THREE.SpriteMaterial({ color: 0xffffff, fog: false });
	  var sprite = new THREE.Sprite(material);
	  sprite.position.set(x, y, z);
	  return sprite;
	}
	
	function createPoint1(x, y, z) {
	  var geometry = new THREE.SphereGeometry(5, 16, 16);
	  var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
	  var sphere = new THREE.Mesh(geometry, material);
	  sphere.position.x = x;
	  sphere.position.y = y;
	  sphere.position.z = z;
	  return sphere;
	}
	
	function createLine(a, b, color) {
	  var material = new THREE.LineBasicMaterial({
	    color: color,
	    linewidth: 1
	  });
	  var geometry = new THREE.Geometry();
	  geometry.vertices.push(new THREE.Vector3(a.x, a.y, a.z));
	  geometry.vertices.push(new THREE.Vector3(b.x, b.y, b.z));
	  return new THREE.Line(geometry, material);
	}
	
	function createSolidMaterial() {
	  return new THREE.MeshPhongMaterial({
	    vertexColors: THREE.FaceColors,
	    color: FACE_COLOR,
	    shininess: 0,
	    polygonOffset: true,
	    polygonOffsetFactor: 1,
	    polygonOffsetUnits: 2,
	    side: THREE.DoubleSide
	  });
	}
	
	function createSolid(csg, id) {
	  return new _meshSceneObject.MeshSceneSolid(csg, undefined, id);
	}
	
	function intercept(obj, methodName, aspect) {
	  var originFunc = obj[methodName];
	  obj[methodName] = function () {
	    var $this = this;
	    aspect(function () {
	      originFunc.apply($this, arguments);
	    }, arguments);
	  };
	}
	
	function createPlane(basis, depth) {
	  var initWidth = 1;
	  var boundingPolygon = [new _vector2.default(0, 0, 0), new _vector2.default(initWidth, 0, 0), new _vector2.default(initWidth, initWidth, 0), new _vector2.default(0, initWidth, 0)];
	  var shared = createShared();
	
	  var material = createSolidMaterial();
	  material.transparent = true;
	  material.opacity = 0.5;
	  material.side = THREE.DoubleSide;
	
	  var tr = new _l3space.Matrix3().setBasis(basis);
	  var currentBounds = new _bbox2.default();
	  var points = boundingPolygon.map(function (p) {
	    p.z = depth;return tr._apply(p);
	  });
	  var polygon = new CSG.Polygon(points.map(function (p) {
	    return new CSG.Vertex(csgVec(p));
	  }), shared);
	  var plane = new _meshSceneObject.MeshSceneSolid(CSG.fromPolygons([polygon]), 'PLANE');
	  plane.wireframeGroup.visible = false;
	  plane.mergeable = false;
	
	  function setBounds(bbox) {
	    currentBounds = bbox;
	    var poly = new CSG.Polygon(bbox.toPolygon().map(function (p) {
	      p.z = depth;return new CSG.Vertex(csgVec(tr._apply(p)));
	    }), shared);
	    plane.csg = CSG.fromPolygons([poly]);
	    plane.dropGeometry();
	    plane.createGeometry();
	  }
	  var bb = new _bbox2.default();
	  bb.checkBounds(-400, -400);
	  bb.checkBounds(400, 400);
	  setBounds(bb);
	
	  var sketchFace = plane.sceneFaces[0];
	  intercept(sketchFace, 'syncSketches', function (invocation, args) {
	    var geom = args[0];
	    invocation(geom);
	    var bbox = new _bbox2.default();
	    var connections = geom.connections.concat(arrFlatten1L(geom.loops));
	    for (var i = 0; i < connections.length; ++i) {
	      var l = connections[i];
	      bbox.checkBounds(l.a.x, l.a.y);
	      bbox.checkBounds(l.b.x, l.b.y);
	    }
	    if (bbox.maxX > currentBounds.maxX || bbox.maxY > currentBounds.maxY || bbox.minX < currentBounds.minX || bbox.minY < currentBounds.minY) {
	      bbox.expand(50);
	      setBounds(bbox);
	    }
	  });
	
	  return plane;
	}
	
	function fixCCW(path, normal) {
	  var _2DTransformation = new _l3space.Matrix3().setBasis(someBasis(path, normal)).invert();
	  var path2D = [];
	  for (var i = 0; i < path.length; ++i) {
	    path2D[i] = _2DTransformation.apply(path[i]);
	  }
	
	  if (!isCCW(path2D)) {
	    path = path.slice(0);
	    path.reverse();
	  }
	  return path;
	}
	
	var isPointInsidePolygon = exports.isPointInsidePolygon = math.isPointInsidePolygon;
	
	function someBasis2(normal) {
	  var x = normal.cross(normal.randomNonParallelVector());
	  var y = normal.cross(x).unit();
	  return [x, y, normal];
	}
	
	function someBasis(twoPointsOnPlane, normal) {
	  var a = twoPointsOnPlane[0];
	  var b = twoPointsOnPlane[1];
	
	  var x = b.minus(a).normalize();
	  var y = normal.cross(x).normalize();
	
	  return [x, y, normal];
	}
	
	function normalOfCCWSeq(ccwSequence) {
	  var a = ccwSequence[0];
	  var b = ccwSequence[1];
	  var c = ccwSequence[2];
	
	  return b.minus(a).cross(c.minus(a)).normalize();
	}
	
	function normalOfCCWSeqTHREE(ccwSequence) {
	  var a = ccwSequence[0];
	  var b = ccwSequence[1].clone();
	  var c = ccwSequence[2].clone();
	
	  return b.sub(a).cross(c.sub(a)).normalize();
	}
	
	var area = exports.area = math.area;
	var isCCW = exports.isCCW = math.isCCW;
	
	function calculateExtrudedLid(sourcePolygon, normal, direction, expansionFactor) {
	  var lid = [];
	  var length = sourcePolygon.length;
	  var work;
	  var si;
	  if (!!expansionFactor && expansionFactor != 1) {
	    if (expansionFactor < 0.001) expansionFactor = 0.0001;
	    var source2d = [];
	    work = [];
	
	    var _3dTr = new _l3space.Matrix3().setBasis(someBasis2(new CSG.Vector3D(normal))); // use passed basis
	    var _2dTr = _3dTr.invert();
	    var sourceBBox = new _bbox2.default();
	    var workBBox = new _bbox2.default();
	    for (si = 0; si < length; ++si) {
	      var sourcePoint = _2dTr.apply(sourcePolygon[si]);
	      source2d[si] = sourcePoint;
	      work[si] = sourcePoint.multiply(expansionFactor);
	      work[si].z = source2d[si].z = 0;
	      sourceBBox.checkBounds(sourcePoint.x, sourcePoint.y);
	      workBBox.checkBounds(work[si].x, work[si].y);
	    }
	    var alignVector = workBBox.center().minus(sourceBBox.center());
	    var depth = normal.dot(sourcePolygon[0]);
	    for (si = 0; si < length; ++si) {
	      work[si] = work[si].minus(alignVector);
	      work[si].z = depth;
	      work[si] = _3dTr.apply(work[si]);
	    }
	  } else {
	    work = sourcePolygon;
	  }
	
	  for (si = 0; si < length; ++si) {
	    lid[si] = work[si].plus(direction);
	  }
	
	  return lid;
	}
	
	function extrude(source, sourceNormal, target, expansionFactor) {
	
	  var extrudeDistance = target.normalize().dot(sourceNormal);
	  if (extrudeDistance == 0) {
	    return [];
	  }
	  var negate = extrudeDistance < 0;
	
	  var poly = [null, null];
	  var lid = calculateExtrudedLid(source, sourceNormal, target, expansionFactor);
	
	  var bottom, top;
	  if (negate) {
	    bottom = lid;
	    top = source;
	  } else {
	    bottom = source;
	    top = lid;
	  }
	
	  var n = source.length;
	  for (var p = n - 1, i = 0; i < n; p = i++) {
	    var shared = createShared();
	    shared.__tcad.csgInfo = { derivedFrom: source[p].sketchConnectionObject };
	    var face = new CSG.Polygon([new CSG.Vertex(csgVec(bottom[p])), new CSG.Vertex(csgVec(bottom[i])), new CSG.Vertex(csgVec(top[i])), new CSG.Vertex(csgVec(top[p]))], shared);
	    poly.push(face);
	  }
	
	  var bottomNormal, topNormal;
	  if (negate) {
	    lid.reverse();
	    bottomNormal = sourceNormal;
	    topNormal = sourceNormal.negate();
	  } else {
	    source = source.slice(0);
	    source.reverse();
	    bottomNormal = sourceNormal.negate();
	    topNormal = sourceNormal;
	  }
	
	  function vecToVertex(v) {
	    return new CSG.Vertex(csgVec(v));
	  }
	
	  var sourcePlane = new CSG.Plane(bottomNormal.csg(), bottomNormal.dot(source[0]));
	  var lidPlane = new CSG.Plane(topNormal.csg(), topNormal.dot(lid[0]));
	
	  poly[0] = new CSG.Polygon(source.map(vecToVertex), createShared(), sourcePlane);
	  poly[1] = new CSG.Polygon(lid.map(vecToVertex), createShared(), lidPlane);
	  return poly;
	}
	
	function triangulate(path, normal) {
	  var _3dTransformation = new _l3space.Matrix3().setBasis(someBasis2(normal));
	  var _2dTransformation = _3dTransformation.invert();
	  var i;
	  var shell = [];
	  for (i = 0; i < path.length; ++i) {
	    shell[i] = _2dTransformation.apply(path[i].pos);
	  }
	  var myTriangulator = new PNLTRI.Triangulator();
	  return myTriangulator.triangulate_polygon([shell]);
	  //  return THREE.Shape.utils.triangulateShape( f2d.shell, f2d.holes );
	}
	
	function createShared() {
	  var id = _counters2.default.shared++;
	  var shared = new CSG.Polygon.Shared([id, id, id, id]);
	  shared.__tcad = {};
	  return shared;
	}
	
	var CURVE_CLASSES = exports.CURVE_CLASSES = new Set();
	CURVE_CLASSES.add('TCAD.TWO.Arc');
	CURVE_CLASSES.add('TCAD.TWO.Circle');
	CURVE_CLASSES.add('TCAD.TWO.Ellipse');
	CURVE_CLASSES.add('TCAD.TWO.EllipticalArc');
	CURVE_CLASSES.add('TCAD.TWO.BezierCurve');
	
	function isCurveClass(className) {
	  return CURVE_CLASSES.has(className);
	}
	
	function isSmoothPiece(shared) {
	  return shared.__tcad && !!shared.__tcad.csgInfo && !!shared.__tcad.csgInfo.derivedFrom && isCurveClass(shared.__tcad.csgInfo.derivedFrom._class);
	}
	
	var POLYGON_COUNTER = 0;
	/** @constructor */
	function Polygon(shell, holes, normal) {
	  this.id = POLYGON_COUNTER++;
	  if (!holes) {
	    holes = [];
	  }
	  var h;
	  checkPolygon(shell);
	  for (h = 0; h < holes.length; ++h) {
	    checkPolygon(holes[h]);
	  }
	
	  if (normal === undefined) {
	    normal = normalOfCCWSeq(shell);
	  } else {
	    shell = fixCCW(shell, normal);
	    if (holes.length > 0) {
	      var neg = normal.negate();
	      for (h = 0; h < holes.length; ++h) {
	        holes[h] = fixCCW(holes[h], neg);
	      }
	    }
	  }
	
	  this.normal = normal;
	  this.shell = shell;
	  this.holes = holes;
	}
	
	Polygon.prototype.reverse = function (triangle) {
	  var first = triangle[0];
	  triangle[0] = triangle[2];
	  triangle[2] = first;
	};
	
	Polygon.prototype.flip = function () {
	  return new Polygon(this.shell, this.holes, this.normal.negate());
	};
	
	Polygon.prototype.shift = function (target) {
	  var shell = [];
	  var i;
	  for (i = 0; i < this.shell.length; ++i) {
	    shell[i] = this.shell[i].plus(target);
	  }
	  var holes = [];
	  for (var h = 0; h < this.holes.length; ++h) {
	    holes[h] = [];
	    for (i = 0; i < this.holes[h].length; ++i) {
	      holes[h][i] = this.holes[h][i].plus(target);
	    }
	  }
	  return new Polygon(shell, holes, this.normal);
	};
	
	Polygon.prototype.get2DTransformation = function () {
	  var _3dTransformation = new _l3space.Matrix3().setBasis(someBasis(this.shell, this.normal));
	  var _2dTransformation = _3dTransformation.invert();
	  return _2dTransformation;
	};
	
	Polygon.prototype.to2D = function () {
	
	  var _2dTransformation = this.get2DTransformation();
	
	  var i, h;
	  var shell = [];
	  var holes = [];
	  for (i = 0; i < this.shell.length; ++i) {
	    shell[i] = _2dTransformation.apply(this.shell[i]);
	  }
	  for (h = 0; h < this.holes.length; ++h) {
	    holes[h] = [];
	    for (i = 0; i < this.holes[h].length; ++i) {
	      holes[h][i] = _2dTransformation.apply(this.holes[h][i]);
	    }
	  }
	  return { shell: shell, holes: holes };
	};
	
	Polygon.prototype.collectPaths = function (paths) {
	  paths.push(this.shell);
	  paths.push.apply(paths, this.holes);
	};
	
	Polygon.prototype.triangulate = function () {
	
	  function triangulateShape(contour, holes) {
	    var myTriangulator = new PNLTRI.Triangulator();
	    return myTriangulator.triangulate_polygon([contour].concat(holes));
	  }
	
	  var i, h;
	  var f2d = this.to2D();
	
	  for (i = 0; i < f2d.shell.length; ++i) {
	    f2d.shell[i] = f2d.shell[i].three();
	  }
	  for (h = 0; h < f2d.holes.length; ++h) {
	    for (i = 0; i < f2d.holes[h].length; ++i) {
	      f2d.holes[h][i] = f2d.holes[h][i].three();
	    }
	  }
	  return triangulateShape(f2d.shell, f2d.holes);
	  //  return THREE.Shape.utils.triangulateShape( f2d.shell, f2d.holes );
	};
	
	Polygon.prototype.eachVertex = function (handler) {
	  var i, h;
	  for (i = 0; i < this.shell.length; ++i) {
	    if (handler(this.shell, i) === true) return;
	  }
	  for (h = 0; h < this.holes.length; ++h) {
	    for (i = 0; i < this.holes[h].length; ++i) {
	      if (handler(this.holes[h], i) === true) return;
	    }
	  }
	};
	
	/** @constructor */
	function Sketch() {
	  this.group = new THREE.Object3D();
	}
	
	function iteratePath(path, shift, callback) {
	  var p,
	      q,
	      n = path.length;
	  for (p = n - 1, q = 0; q < n; p = q++) {
	    var ai = (p + shift) % n;
	    var bi = (q + shift) % n;
	    if (!callback(path[ai], path[bi], ai, bi, q, path)) {
	      break;
	    }
	  }
	}
	
	function addAll(arr, arrToAdd) {
	  for (var i = 0; i < arrToAdd.length; i++) {
	    arr.push(arrToAdd[i]);
	  }
	}
	
	function arrFlatten1L(arr) {
	  var result = [];
	  for (var i = 0; i < arr.length; i++) {
	    addAll(result, arr[i]);
	  }
	  return result;
	}

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _math = __webpack_require__(304);
	
	/** @constructor */
	function Vector(x, y, z) {
	  this.x = x || 0;
	  this.y = y || 0;
	  this.z = z || 0;
	}
	
	Vector.prototype.set = function (x, y, z) {
	  this.x = x || 0;
	  this.y = y || 0;
	  this.z = z || 0;
	  return this;
	};
	
	Vector.prototype.set3 = function (data) {
	  this.x = data[0] || 0;
	  this.y = data[1] || 0;
	  this.z = data[2] || 0;
	  return this;
	};
	
	Vector.prototype.setV = function (data) {
	  this.x = data.x;
	  this.y = data.y;
	  this.z = data.z;
	  return this;
	};
	
	Vector.prototype.multiply = function (scalar) {
	  return new Vector(this.x * scalar, this.y * scalar, this.z * scalar);
	};
	
	Vector.prototype._multiply = function (scalar) {
	  return this.set(this.x * scalar, this.y * scalar, this.z * scalar);
	};
	
	Vector.prototype.dot = function (vector) {
	  return this.x * vector.x + this.y * vector.y + this.z * vector.z;
	};
	
	Vector.prototype.copy = function () {
	  return new Vector(this.x, this.y, this.z);
	};
	
	Vector.prototype.length = function () {
	  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	};
	
	Vector.prototype.lengthSquared = function () {
	  return this.dot(this);
	};
	
	Vector.prototype.distanceToSquared = function (a) {
	  return this.minus(a).lengthSquared();
	};
	
	Vector.prototype.minus = function (vector) {
	  return new Vector(this.x - vector.x, this.y - vector.y, this.z - vector.z);
	};
	
	Vector.prototype._minus = function (vector) {
	  this.x -= vector.x;
	  this.y -= vector.y;
	  this.z -= vector.z;
	  return this;
	};
	
	Vector.prototype._minusXYZ = function (x, y, z) {
	  this.x -= x;
	  this.y -= y;
	  this.z -= z;
	  return this;
	};
	
	Vector.prototype.plusXYZ = function (x, y, z) {
	  return new Vector(this.x + x, this.y + y, this.z + z);
	};
	
	Vector.prototype.plus = function (vector) {
	  return new Vector(this.x + vector.x, this.y + vector.y, this.z + vector.z);
	};
	
	Vector.prototype._plus = function (vector) {
	  this.x += vector.x;
	  this.y += vector.y;
	  this.z += vector.z;
	  return this;
	};
	
	Vector.prototype.normalize = function () {
	  var mag = this.length();
	  if (mag == 0.0) {
	    return new Vector(0.0, 0.0, 0.0);
	  }
	  return new Vector(this.x / mag, this.y / mag, this.z / mag);
	};
	
	Vector.prototype._normalize = function () {
	  var mag = this.length();
	  if (mag == 0.0) {
	    return this.set(0, 0, 0);
	  }
	  return this.set(this.x / mag, this.y / mag, this.z / mag);
	};
	
	Vector.prototype.cross = function (a) {
	  return new Vector(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x);
	};
	
	Vector.prototype.negate = function () {
	  return this.multiply(-1);
	};
	
	Vector.prototype._negate = function () {
	  return this._multiply(-1);
	};
	
	Vector.prototype.equals = function (vector) {
	  return (0, _math.vectorsEqual)(this, vector);
	};
	
	Vector.prototype.toArray = function () {
	  return [this.x, this.y, this.z];
	};
	
	Vector.prototype.data = Vector.prototype.toArray;
	
	Vector.prototype.three = function () {
	  return new THREE.Vector3(this.x, this.y, this.z);
	};
	
	exports.default = Vector;

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.sq = exports.TOLERANCE = undefined;
	exports.distanceAB = distanceAB;
	exports.distance = distance;
	exports.distanceAB3 = distanceAB3;
	exports.distance3 = distance3;
	exports.circleFromPoints = circleFromPoints;
	exports.norm2 = norm2;
	exports.areEqual = areEqual;
	exports.areVectorsEqual = areVectorsEqual;
	exports.vectorsEqual = vectorsEqual;
	exports.equal = equal;
	exports.strictEqual = strictEqual;
	exports.strictEqual2D = strictEqual2D;
	exports._vec = _vec;
	exports._matrix = _matrix;
	exports.rotate = rotate;
	exports.rotateInPlace = rotateInPlace;
	exports.polygonOffsetXY = polygonOffsetXY;
	exports.polygonOffset = polygonOffset;
	exports.polygonOffsetByDelta = polygonOffsetByDelta;
	exports.isPointInsidePolygon = isPointInsidePolygon;
	exports.area = area;
	exports.isCCW = isCCW;
	exports.findLowestLeftPoint = findLowestLeftPoint;
	exports.makeAngle0_360 = makeAngle0_360;
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _bbox = __webpack_require__(305);
	
	var _bbox2 = _interopRequireDefault(_bbox);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var TOLERANCE = exports.TOLERANCE = 1E-6;
	
	function distanceAB(a, b) {
	  return distance(a.x, a.y, b.x, b.y);
	}
	
	function distance(x1, y1, x2, y2) {
	  var dx = x1 - x2;
	  var dy = y1 - y2;
	  return Math.sqrt(dx * dx + dy * dy);
	}
	
	function distanceAB3(a, b) {
	  return distance3(a.x, a.y, a.z, b.x, b.y, b.z);
	}
	
	function distance3(x1, y1, z1, x2, y2, z2) {
	  var dx = x1 - x2;
	  var dy = y1 - y2;
	  var dz = z1 - z2;
	  return Math.sqrt(dx * dx + dy * dy + dz * dz);
	}
	
	function circleFromPoints(p1, p2, p3) {
	  var center = new _vector2.default();
	  var offset = p2.x * p2.x + p2.y * p2.y;
	  var bc = (p1.x * p1.x + p1.y * p1.y - offset) / 2.0;
	  var cd = (offset - p3.x * p3.x - p3.y * p3.y) / 2.0;
	  var det = (p1.x - p2.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p2.y);
	
	  if (Math.abs(det) < TOLERANCE) {
	    return null;
	  }
	
	  var idet = 1 / det;
	
	  center.x = (bc * (p2.y - p3.y) - cd * (p1.y - p2.y)) * idet;
	  center.y = (cd * (p1.x - p2.x) - bc * (p2.x - p3.x)) * idet;
	  return center;
	}
	
	function norm2(vec) {
	  var sq = 0;
	  for (var i = 0; i < vec.length; i++) {
	    sq += vec[i] * vec[i];
	  }
	  return Math.sqrt(sq);
	}
	
	function areEqual(v1, v2, tolerance) {
	  return Math.abs(v1 - v2) < tolerance;
	}
	
	function areVectorsEqual(v1, v2, tolerance) {
	  return areEqual(v1.x, v2.x, tolerance) && areEqual(v1.y, v2.y, tolerance) && areEqual(v1.z, v2.z, tolerance);
	}
	
	function vectorsEqual(v1, v2) {
	  return areVectorsEqual(v1, v2, TOLERANCE);
	}
	
	function equal(v1, v2) {
	  return areEqual(v1, v2, TOLERANCE);
	}
	
	function strictEqual(a, b) {
	  return a.x == b.x && a.y == b.y && a.z == b.z;
	}
	
	function strictEqual2D(a, b) {
	  return a.x == b.x && a.y == b.y;
	}
	
	function _vec(size) {
	  var out = [];
	  out.length = size;
	  for (var i = 0; i < size; ++i) {
	    out[i] = 0;
	  }
	  return out;
	}
	
	function _matrix(m, n) {
	  var out = [];
	  out.length = m;
	  for (var i = 0; i < m; ++i) {
	    out[i] = _vec(n);
	  }
	  return out;
	}
	
	function rotate(px, py, angle) {
	  return rotateInPlace(px, py, angle, new _vector2.default());
	}
	
	function rotateInPlace(px, py, angle, out) {
	  out.x = px * Math.cos(angle) - py * Math.sin(angle);
	  out.y = px * Math.sin(angle) + py * Math.cos(angle);
	  return out;
	}
	
	function polygonOffsetXY(polygon, scaleX, scaleY) {
	  var origBBox = new _bbox2.default();
	  var scaledBBox = new _bbox2.default();
	  var result = [];
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = polygon[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var point = _step.value;
	
	      var scaledPoint = new _vector2.default(point.x * scaleX, point.y * scaleY);
	      result.push(scaledPoint);
	      origBBox.checkPoint(point);
	      scaledBBox.checkPoint(scaledPoint);
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  var alignVector = scaledBBox.center()._minus(origBBox.center());
	  var _iteratorNormalCompletion2 = true;
	  var _didIteratorError2 = false;
	  var _iteratorError2 = undefined;
	
	  try {
	    for (var _iterator2 = result[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	      var _point = _step2.value;
	
	      _point._minus(alignVector);
	    }
	  } catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion2 && _iterator2.return) {
	        _iterator2.return();
	      }
	    } finally {
	      if (_didIteratorError2) {
	        throw _iteratorError2;
	      }
	    }
	  }
	
	  return result;
	}
	
	function polygonOffset(polygon, scale) {
	  return polygonOffsetXY(polygon, scale, scale);
	}
	
	function polygonOffsetByDelta(polygon, delta) {
	  var origBBox = new _bbox2.default();
	  var _iteratorNormalCompletion3 = true;
	  var _didIteratorError3 = false;
	  var _iteratorError3 = undefined;
	
	  try {
	    for (var _iterator3 = polygon[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	      var point = _step3.value;
	
	      origBBox.checkPoint(point);
	    }
	  } catch (err) {
	    _didIteratorError3 = true;
	    _iteratorError3 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion3 && _iterator3.return) {
	        _iterator3.return();
	      }
	    } finally {
	      if (_didIteratorError3) {
	        throw _iteratorError3;
	      }
	    }
	  }
	
	  var width = origBBox.width();
	  var height = origBBox.height();
	  return polygonOffsetXY(polygon, (width + delta) / width, (height + delta) / height);
	}
	
	function isPointInsidePolygon(inPt, inPolygon) {
	  var EPSILON = TOLERANCE;
	
	  var polyLen = inPolygon.length;
	
	  // inPt on polygon contour => immediate success    or
	  // toggling of inside/outside at every single! intersection point of an edge
	  //  with the horizontal line through inPt, left of inPt
	  //  not counting lowerY endpoints of edges and whole edges on that line
	  var inside = false;
	  for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
	    var edgeLowPt = inPolygon[p];
	    var edgeHighPt = inPolygon[q];
	
	    var edgeDx = edgeHighPt.x - edgeLowPt.x;
	    var edgeDy = edgeHighPt.y - edgeLowPt.y;
	
	    if (Math.abs(edgeDy) > EPSILON) {
	      // not parallel
	      if (edgeDy < 0) {
	        edgeLowPt = inPolygon[q];edgeDx = -edgeDx;
	        edgeHighPt = inPolygon[p];edgeDy = -edgeDy;
	      }
	      if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
	
	      if (inPt.y == edgeLowPt.y) {
	        if (inPt.x == edgeLowPt.x) return true; // inPt is on contour ?
	        // continue;				// no intersection or edgeLowPt => doesn't count !!!
	      } else {
	        var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
	        if (perpEdge == 0) return true; // inPt is on contour ?
	        if (perpEdge < 0) continue;
	        inside = !inside; // true intersection left of inPt
	      }
	    } else {
	      // parallel or colinear
	      if (inPt.y != edgeLowPt.y) continue; // parallel
	      // egde lies on the same horizontal line as inPt
	      if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
	      // continue;
	    }
	  }
	
	  return inside;
	}
	
	// http://en.wikipedia.org/wiki/Shoelace_formula
	function area(contour) {
	  var n = contour.length;
	  var a = 0.0;
	  for (var p = n - 1, q = 0; q < n; p = q++) {
	    a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
	  }
	  return a * 0.5;
	}
	
	function isCCW(path2D) {
	  return area(path2D) >= 0;
	}
	
	function findLowestLeftPoint(poly) {
	  var heroIdx = 0;
	  for (var i = 1; i < poly.length; ++i) {
	    var point = poly[i];
	    var hero = poly[heroIdx];
	    if (point.y < hero.y) {
	      heroIdx = i;
	    } else if (hero.y == point.y) {
	      if (point.x < hero.x) {
	        heroIdx = i;
	      }
	    }
	  }
	  return heroIdx;
	}
	
	function makeAngle0_360(angle) {
	  angle %= 2 * Math.PI;
	  if (angle < 0) {
	    angle = 2 * Math.PI + angle;
	  }
	  return angle;
	}
	
	var sq = exports.sq = function sq(a) {
	  return a * a;
	};

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var BBox = function () {
	  function BBox() {
	    _classCallCheck(this, BBox);
	
	    this.minX = Number.MAX_VALUE;
	    this.minY = Number.MAX_VALUE;
	    this.minZ = Number.MAX_VALUE;
	    this.maxX = -Number.MAX_VALUE;
	    this.maxY = -Number.MAX_VALUE;
	    this.maxZ = -Number.MAX_VALUE;
	  }
	
	  _createClass(BBox, [{
	    key: 'checkBounds',
	    value: function checkBounds(x, y, z) {
	      z = z || 0;
	      this.minX = Math.min(this.minX, x);
	      this.minY = Math.min(this.minY, y);
	      this.minZ = Math.min(this.minZ, z);
	      this.maxX = Math.max(this.maxX, x);
	      this.maxY = Math.max(this.maxY, y);
	      this.maxZ = Math.max(this.maxZ, z);
	    }
	  }, {
	    key: 'checkPoint',
	    value: function checkPoint(p) {
	      this.checkBounds(p.x, p.y, p.z);
	    }
	  }, {
	    key: 'center',
	    value: function center() {
	      return new _vector2.default(this.minX + (this.maxX - this.minX) / 2, this.minY + (this.maxY - this.minY) / 2, this.minZ + (this.maxZ - this.minZ) / 2);
	    }
	  }, {
	    key: 'min',
	    value: function min() {
	      return new _vector2.default(this.minX, this.minY, this.minZ);
	    }
	  }, {
	    key: 'max',
	    value: function max() {
	      return new _vector2.default(this.maxX, this.maxY, this.maxZ);
	    }
	  }, {
	    key: 'width',
	    value: function width() {
	      return this.maxX - this.minX;
	    }
	  }, {
	    key: 'height',
	    value: function height() {
	      return this.maxY - this.minY;
	    }
	  }, {
	    key: 'depth',
	    value: function depth() {
	      return this.maxZ - this.minZ;
	    }
	  }, {
	    key: 'expand',
	    value: function expand(delta) {
	      this.minX -= delta;
	      this.minY -= delta;
	      this.minZ -= delta;
	      this.maxX += delta;
	      this.maxY += delta;
	      this.maxZ += delta;
	    }
	  }, {
	    key: 'toPolygon',
	    value: function toPolygon() {
	      return [new _vector2.default(this.minX, this.minY, 0), new _vector2.default(this.maxX, this.minY, 0), new _vector2.default(this.maxX, this.maxY, 0), new _vector2.default(this.minX, this.maxY, 0)];
	    }
	  }]);
	
	  return BBox;
	}();
	
	exports.default = BBox;

/***/ },
/* 306 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function HashTable(hashCodeF, equalsF) {
	  this.hashCodeF = hashCodeF;
	  this.equalsF = equalsF;
	  this.setTableSize(8);
	  this.size = 0;
	}
	
	HashTable.prototype.hash = function (key) {
	  return Math.abs(this.hashCodeF(key) % this.table.length);
	};
	
	HashTable.prototype.get = function (key) {
	  var entry = this._findEntry(key, this._findBucket(key));
	  if (entry == null) return null;
	  return entry[1];
	};
	
	HashTable.prototype.put = function (key, value) {
	  if (this.size >= 0.75 * this.table.length) {
	    this.rebuild();
	  }
	  this._put(key, value);
	};
	
	HashTable.prototype._findBucket = function (key) {
	  var hash = this.hash(key);
	  var bucket = this.table[hash];
	  if (bucket === null) {
	    bucket = [];
	    this.table[hash] = bucket;
	  }
	  return bucket;
	};
	
	HashTable.prototype._findEntry = function (key, bucket) {
	  for (var i = 0; i < bucket.length; i++) {
	    if (this.equalsF(bucket[i][0], key)) {
	      return bucket[i];
	    }
	  }
	  return null;
	};
	
	HashTable.prototype._put = function (key, value) {
	  var bucket = this._findBucket(key);
	  var entry = this._findEntry(key, bucket);
	  if (entry == null) {
	    bucket.push([key, value]);
	  } else {
	    entry[1] = value;
	  }
	  this.size++;
	};
	
	HashTable.prototype.rebuild = function () {
	  this.size = 0;
	  var oldTable = this.table;
	  this.setTableSize(this.table.length * 2);
	  for (var i = 0; i < oldTable.length; i++) {
	    var e = oldTable[i];
	    if (e != null) {
	      for (var j = 0; j < e.length; j++) {
	        var bucket = e[j];
	        this._put(bucket[0], bucket[1]);
	      }
	    }
	  }
	};
	
	HashTable.prototype.getKeys = function () {
	  var keys = [];
	  this.entries(function (k) {
	    keys.push(k);
	  });
	  return keys;
	};
	
	HashTable.prototype.entries = function (callback) {
	  for (var i = 0; i < this.table.length; i++) {
	    var e = this.table[i];
	    if (e != null) {
	      for (var j = 0; j < e.length; j++) {
	        var bucket = e[j];
	        callback(bucket[0], bucket[1]);
	      }
	    }
	  }
	};
	
	HashTable.prototype.setTableSize = function (newSize) {
	  this.table = [];
	  for (var i = 0; i < newSize; i++) {
	    this.table[i] = null;
	  }
	};
	
	function DoubleHelper() {
	  this.dv = new DataView(new ArrayBuffer(8));
	}
	
	DoubleHelper.prototype.hash = function (v) {
	  this.dv.setFloat64(0, v);
	  return this.dv.getInt32(0) ^ this.dv.getInt32(4);
	};
	
	HashTable.forVector3d = function () {
	  var doubleHelper = new DoubleHelper();
	  function hash(v) {
	    return doubleHelper.hash(v.x) ^ doubleHelper.hash(v.y) ^ doubleHelper.hash(v.z);
	  }
	  function eq(a, b) {
	    return a.x === b.x && a.y === b.y && a.z === b.z;
	  }
	  return new HashTable(hash, eq);
	};
	
	HashTable.forEdge = function () {
	  var doubleHelper = new DoubleHelper();
	  function hash(v) {
	    return doubleHelper.hash(v[0].x) ^ doubleHelper.hash(v[0].y) ^ doubleHelper.hash(v[0].z) ^ doubleHelper.hash(v[1].x) ^ doubleHelper.hash(v[1].y) ^ doubleHelper.hash(v[1].z);
	  }
	  function veq(a, b) {
	    return a.x === b.x && a.y === b.y && a.z === b.z;
	  }
	  function eq(e1, e2) {
	    var a1 = e1[0];
	    var b1 = e1[1];
	    var a2 = e2[0];
	    var b2 = e2[1];
	    return veq(a1, a2) && veq(b1, b2) || veq(a1, b2) && veq(b1, a2);
	  }
	  return new HashTable(hash, eq);
	};
	
	HashTable.forVector2d = function () {
	  var doubleHelper = new DoubleHelper();
	  function hash(v) {
	    return doubleHelper.hash(v.x) ^ doubleHelper.hash(v.y);
	  }
	  function eq(a, b) {
	    return a.x === b.x && a.y === b.y;
	  }
	  return new HashTable(hash, eq);
	};
	
	HashTable.forDoubleArray = function () {
	  var doubleHelper = new DoubleHelper();
	  function hash(v) {
	    var hash = 0;
	    for (var i = 0; i < v.length; i++) {
	      hash ^= v[i];
	    }
	    return hash;
	  }
	  function eq(a, b) {
	    for (var i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  return new HashTable(hash, eq);
	};
	
	exports.HashTable = HashTable;
	exports.DoubleHelper = DoubleHelper;

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Graph = undefined;
	
	var _hashmap = __webpack_require__(306);
	
	/** @constructor */
	function Graph(data) {
	
	  this.connections = function (e) {
	    return data[e];
	  };
	
	  this.at = function (index) {
	    return index;
	  };
	
	  this.size = function () {
	    return data.length;
	  };
	}
	
	Graph.findAllLoops = function (graph, hashCode, equals) {
	
	  var loops = [];
	  var visited = new _hashmap.HashTable(hashCode, equals);
	  function step(vertex, comesFrom, path) {
	    var i;
	    visited.put(vertex, true);
	    for (i = path.length - 1; i >= 0; --i) {
	      if (equals(vertex, path[i])) {
	        loops.push(path.slice(i));
	        return;
	      }
	    }
	
	    var next = graph.connections(vertex);
	
	    path.push(vertex);
	    var needClone = false;
	
	    for (i = 0; i < next.length; i++) {
	      var v = next[i];
	      if (equals(v, comesFrom)) {
	        continue;
	      }
	
	      var p = needClone ? path.slice(0) : path;
	      needClone = true;
	      step(v, vertex, p);
	    }
	    path.pop();
	  }
	
	  for (i = 0; i < graph.size(); i++) {
	    var vertex = graph.at(i);
	    if (visited.get(vertex) !== true) {
	      step(vertex, -1, []);
	    }
	  }
	
	  //filter duplicates
	
	  function sameLoop(a, b) {
	    var first = a[0];
	    for (var bShift = 0; bShift < a.length; bShift++) {
	      if (equals(b[bShift], first)) {
	        break;
	      }
	    }
	    if (bShift == a.length) {
	      return false;
	    }
	    for (var i = 0; i < a.length; i++) {
	      var bUp = (bShift + i) % a.length;
	      var bDown = bShift - i;
	      if (bDown < 0) {
	        bDown = a.length + bDown;
	      }
	      //      console.log("up: " + bUp + "; down: " + bDown);
	      var curr = a[i];
	      if (!equals(curr, b[bUp]) && !equals(curr, b[bDown])) {
	        return false;
	      }
	    }
	    return true;
	  }
	
	  var i,
	      duplicates = 0;
	  for (i = 0; i < loops.length; i++) {
	    var a = loops[i];
	    if (a == null) continue;
	    for (var j = i + 1; j < loops.length; j++) {
	      var b = loops[j];
	      if (b == null || a.length !== b.length) {
	        continue;
	      }
	      if (sameLoop(a, b)) {
	        loops[j] = null;
	        ++duplicates;
	      }
	    }
	  }
	  if (duplicates != 0) {
	    var filtered = [];
	    for (i = 0; i < loops.length; i++) {
	      if (loops[i] != null) filtered.push(loops[i]);
	    }
	    loops = filtered;
	  }
	
	  return loops;
	};
	
	var test = function test() {
	  var data = [[], [2], [1, 3, 9], [2, 4], [3, 9, 5, 8], [4, 6], [5, 8, 7], [6], [4, 6], [2, 4]];
	
	  var graph = new Graph(data);
	  console.log(Graph.findAllLoops(graph));
	};
	
	var test0 = function test0() {
	  var data = [[3, 1], [0, 2, 8], [1, 3, 7, 5], [0, 2, 4], [3, 5], [4, 2, 6], [5, 7], [2, 6, 8], [1, 7]];
	
	  var graph = new Graph(data);
	  console.log(Graph.findAllLoops(graph));
	};
	
	exports.Graph = Graph;

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.BasisForPlane = exports.AXIS = exports.IDENTITY_BASIS = exports.ORIGIN = exports.Matrix3 = exports.STANDARD_BASES = undefined;
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ORIGIN = new _vector2.default(0, 0, 0);
	
	var AXIS = {
	  X: new _vector2.default(1, 0, 0),
	  Y: new _vector2.default(0, 1, 0),
	  Z: new _vector2.default(0, 0, 1)
	};
	
	var IDENTITY_BASIS = [AXIS.X, AXIS.Y, AXIS.Z];
	
	var STANDARD_BASES = exports.STANDARD_BASES = {
	  'XY': IDENTITY_BASIS,
	  'XZ': [AXIS.X, AXIS.Z, AXIS.Y],
	  'ZY': [AXIS.Z, AXIS.Y, AXIS.X]
	};
	
	/** @constructor */
	function Matrix3() {
	  this.reset();
	}
	
	Matrix3.prototype.reset = function () {
	  this.mxx = 1;this.mxy = 0;this.mxz = 0;this.tx = 0;
	  this.myx = 0;this.myy = 1;this.myz = 0;this.ty = 0;
	  this.mzx = 0;this.mzy = 0;this.mzz = 1;this.tz = 0;
	  return this;
	};
	
	Matrix3.prototype.setBasis = function (basis) {
	  var b = basis;
	  this.mxx = b[0].x;this.mxy = b[1].x;this.mxz = b[2].x;this.tx = 0;
	  this.myx = b[0].y;this.myy = b[1].y;this.myz = b[2].y;this.ty = 0;
	  this.mzx = b[0].z;this.mzy = b[1].z;this.mzz = b[2].z;this.tz = 0;
	  return this;
	};
	
	Matrix3.prototype.translate = function (dx, dy, dz) {
	  this.tx += dx;
	  this.ty += dy;
	  this.tz += dz;
	  return this;
	};
	
	Matrix3.prototype.set3 = function (mxx, mxy, mxz, myx, myy, myz, mzx, mzy, mzz) {
	  this.mxx = mxx;this.mxy = mxy;this.mxz = mxz;
	  this.myx = myx;this.myy = myy;this.myz = myz;
	  this.mzx = mzx;this.mzy = mzy;this.mzz = mzz;
	  return this;
	};
	
	Matrix3.prototype.set34 = function (mxx, mxy, mxz, tx, myx, myy, myz, ty, mzx, mzy, mzz, tz) {
	  this.mxx = mxx;this.mxy = mxy;this.mxz = mxz;this.tx = tx;
	  this.myx = myx;this.myy = myy;this.myz = myz;this.ty = ty;
	  this.mzx = mzx;this.mzy = mzy;this.mzz = mzz;this.tz = tz;
	  return this;
	};
	
	Matrix3.prototype.setMatrix = function (m) {
	  this.mxx = m.mxx;this.mxy = m.mxy;this.mxz = m.mxz;this.tx = m.tx;
	  this.myx = m.myx;this.myy = m.myy;this.myz = m.myz;this.ty = m.ty;
	  this.mzx = m.mzx;this.mzy = m.mzy;this.mzz = m.mzz;this.tz = m.tz;
	  return this;
	};
	
	Matrix3.prototype.toArray = function () {
	  return [[this.mxx, this.mxy, this.mxz, this.tx], [this.myx, this.myy, this.myz, this.ty], [this.mzx, this.mzy, this.mzz, this.tz]];
	};
	
	Matrix3.prototype.invert = function () {
	
	  var det = this.mxx * (this.myy * this.mzz - this.mzy * this.myz) + this.mxy * (this.myz * this.mzx - this.mzz * this.myx) + this.mxz * (this.myx * this.mzy - this.mzx * this.myy);
	
	  if (det == 0.0) {
	    return null;
	  }
	
	  var cxx = this.myy * this.mzz - this.myz * this.mzy;
	  var cyx = -this.myx * this.mzz + this.myz * this.mzx;
	  var czx = this.myx * this.mzy - this.myy * this.mzx;
	  var cxt = -this.mxy * (this.myz * this.tz - this.mzz * this.ty) - this.mxz * (this.ty * this.mzy - this.tz * this.myy) - this.tx * (this.myy * this.mzz - this.mzy * this.myz);
	  var cxy = -this.mxy * this.mzz + this.mxz * this.mzy;
	  var cyy = this.mxx * this.mzz - this.mxz * this.mzx;
	  var czy = -this.mxx * this.mzy + this.mxy * this.mzx;
	  var cyt = this.mxx * (this.myz * this.tz - this.mzz * this.ty) + this.mxz * (this.ty * this.mzx - this.tz * this.myx) + this.tx * (this.myx * this.mzz - this.mzx * this.myz);
	  var cxz = this.mxy * this.myz - this.mxz * this.myy;
	  var cyz = -this.mxx * this.myz + this.mxz * this.myx;
	  var czz = this.mxx * this.myy - this.mxy * this.myx;
	  var czt = -this.mxx * (this.myy * this.tz - this.mzy * this.ty) - this.mxy * (this.ty * this.mzx - this.tz * this.myx) - this.tx * (this.myx * this.mzy - this.mzx * this.myy);
	
	  var result = new Matrix3();
	  result.mxx = cxx / det;
	  result.mxy = cxy / det;
	  result.mxz = cxz / det;
	  result.tx = cxt / det;
	  result.myx = cyx / det;
	  result.myy = cyy / det;
	  result.myz = cyz / det;
	  result.ty = cyt / det;
	  result.mzx = czx / det;
	  result.mzy = czy / det;
	  result.mzz = czz / det;
	  result.tz = czt / det;
	  return result;
	};
	
	Matrix3.prototype.combine = function (transform) {
	  var txx = transform.mxx;
	  var txy = transform.mxy;
	  var txz = transform.mxz;
	  var ttx = transform.tx;
	  var tyx = transform.myx;
	  var tyy = transform.myy;
	  var tyz = transform.myz;
	  var tty = transform.ty;
	  var tzx = transform.mzx;
	  var tzy = transform.mzy;
	  var tzz = transform.mzz;
	  var ttz = transform.tz;
	
	  var m = new Matrix3();
	  m.mxx = this.mxx * txx + this.mxy * tyx + this.mxz * tzx;
	  m.mxy = this.mxx * txy + this.mxy * tyy + this.mxz * tzy;
	  m.mxz = this.mxx * txz + this.mxy * tyz + this.mxz * tzz;
	  m.tx = this.mxx * ttx + this.mxy * tty + this.mxz * ttz + this.tx;
	  m.myx = this.myx * txx + this.myy * tyx + this.myz * tzx;
	  m.myy = this.myx * txy + this.myy * tyy + this.myz * tzy;
	  m.myz = this.myx * txz + this.myy * tyz + this.myz * tzz;
	  m.ty = this.myx * ttx + this.myy * tty + this.myz * ttz + this.ty;
	  m.mzx = this.mzx * txx + this.mzy * tyx + this.mzz * tzx;
	  m.mzy = this.mzx * txy + this.mzy * tyy + this.mzz * tzy;
	  m.mzz = this.mzx * txz + this.mzy * tyz + this.mzz * tzz;
	  m.tz = this.mzx * ttx + this.mzy * tty + this.mzz * ttz + this.tz;
	
	  return m;
	};
	
	Matrix3.prototype.apply = function (vector) {
	  return this.__apply(vector, new _vector2.default());
	};
	
	Matrix3.prototype._apply = function (vector) {
	  return this.__apply(vector, vector);
	};
	
	Matrix3.prototype.__apply = function (vector, out) {
	  var x = vector.x;
	  var y = vector.y;
	  var z = vector.z;
	  return out.set(this.mxx * x + this.mxy * y + this.mxz * z + this.tx, this.myx * x + this.myy * y + this.myz * z + this.ty, this.mzx * x + this.mzy * y + this.mzz * z + this.tz);
	};
	
	Matrix3.rotateMatrix = function (angle, axis, pivot) {
	  var sin = Math.sin(angle);
	  var cos = Math.cos(angle);
	  var axisX, axisY, axisZ;
	  var m = new Matrix3();
	
	  if (axis === AXIS.X || axis === AXIS.Y || axis === AXIS.Z) {
	    axisX = axis.x;
	    axisY = axis.y;
	    axisZ = axis.z;
	  } else {
	    // normalize
	    var mag = axis.length();
	
	    if (mag == 0.0) {
	      return m;
	    } else {
	      axisX = axis.x / mag;
	      axisY = axis.y / mag;
	      axisZ = axis.z / mag;
	    }
	  }
	
	  var px = pivot.x;
	  var py = pivot.y;
	  var pz = pivot.z;
	
	  m.mxx = cos + axisX * axisX * (1 - cos);
	  m.mxy = axisX * axisY * (1 - cos) - axisZ * sin;
	  m.mxz = axisX * axisZ * (1 - cos) + axisY * sin;
	
	  m.tx = px * (1 - m.mxx) - py * m.mxy - pz * m.mxz;
	
	  m.myx = axisY * axisX * (1 - cos) + axisZ * sin;
	  m.myy = cos + axisY * axisY * (1 - cos);
	  m.myz = axisY * axisZ * (1 - cos) - axisX * sin;
	  m.ty = py * (1 - m.myy) - px * m.myx - pz * m.myz;
	
	  m.mzx = axisZ * axisX * (1 - cos) - axisY * sin;
	  m.mzy = axisZ * axisY * (1 - cos) + axisX * sin;
	  m.mzz = cos + axisZ * axisZ * (1 - cos);
	  m.tz = pz * (1 - m.mzz) - px * m.mzx - py * m.mzy;
	  return m;
	};
	
	function BasisForPlane(normal) {
	  var alignPlane = void 0,
	      x = void 0,
	      y = void 0;
	  if (Math.abs(normal.dot(AXIS.Y)) < 0.5) {
	    alignPlane = normal.cross(AXIS.Y);
	  } else {
	    alignPlane = normal.cross(AXIS.Z);
	  }
	  y = alignPlane.cross(normal);
	  x = y.cross(normal);
	  return [x, y, normal];
	}
	
	exports.Matrix3 = Matrix3;
	exports.ORIGIN = ORIGIN;
	exports.IDENTITY_BASIS = IDENTITY_BASIS;
	exports.AXIS = AXIS;
	exports.BasisForPlane = BasisForPlane;

/***/ },
/* 309 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var Counters = {
	  solid: 0,
	  shared: 0
	};
	
	exports.default = Counters;

/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.MeshSceneSolid = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _hashmap = __webpack_require__(306);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _counters = __webpack_require__(309);
	
	var _counters2 = _interopRequireDefault(_counters);
	
	var _workbench = __webpack_require__(311);
	
	var _l3space = __webpack_require__(308);
	
	var _cadUtils = __webpack_require__(302);
	
	var _dpr = __webpack_require__(325);
	
	var _dpr2 = _interopRequireDefault(_dpr);
	
	var _sceneObject = __webpack_require__(326);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MeshSceneSolid = exports.MeshSceneSolid = function (_SceneSolid) {
	  _inherits(MeshSceneSolid, _SceneSolid);
	
	  function MeshSceneSolid(csg, type, id) {
	    _classCallCheck(this, MeshSceneSolid);
	
	    var _this = _possibleConstructorReturn(this, (MeshSceneSolid.__proto__ || Object.getPrototypeOf(MeshSceneSolid)).call(this, type, id));
	
	    csg = csg.reTesselated().canonicalized();
	    _this.csg = csg;
	    _this.createGeometry();
	    return _this;
	  }
	
	  _createClass(MeshSceneSolid, [{
	    key: 'createGeometry',
	    value: function createGeometry() {
	      var geometry = new THREE.Geometry();
	      geometry.dynamic = true;
	      this.mesh = new THREE.Mesh(geometry, this.material);
	      this.cadGroup.add(this.mesh);
	
	      this.wires = _hashmap.HashTable.forEdge();
	      this.curvedSurfaces = {};
	
	      this.setupGeometry();
	    }
	  }, {
	    key: 'dropGeometry',
	    value: function dropGeometry() {
	      this.cadGroup.remove(this.mesh);
	      this.mesh.geometry.dispose();
	      for (var i = this.wireframeGroup.children.length - 1; i >= 0; i--) {
	        this.wireframeGroup.remove(this.wireframeGroup.children[i]);
	      }
	    }
	  }, {
	    key: 'setupGeometry',
	    value: function setupGeometry() {
	      function threeV(v) {
	        return new THREE.Vector3(v.x, v.y, v.z);
	      }
	
	      var off = 0;
	      var groups = groupCSG(this.csg);
	      var geom = this.mesh.geometry;
	      for (var gIdx in groups) {
	        var group = groups[gIdx];
	        if (group.shared.__tcad === undefined) group.shared.__tcad = {};
	        var sceneFace = new MeshSceneFace(this, group);
	        this.sceneFaces.push(sceneFace);
	        for (var p = 0; p < group.polygons.length; ++p) {
	          var poly = group.polygons[p];
	          var vLength = poly.vertices.length;
	          if (vLength < 3) continue;
	          var firstVertex = poly.vertices[0];
	          geom.vertices.push(threeV(firstVertex.pos));
	          geom.vertices.push(threeV(poly.vertices[1].pos));
	          var normal = threeV(poly.plane.normal);
	          for (var i = 2; i < vLength; i++) {
	            geom.vertices.push(threeV(poly.vertices[i].pos));
	
	            var a = off;
	            var b = i - 1 + off;
	            var c = i + off;
	            var face = sceneFace.createMeshFace(a, b, c);
	            face.normal = normal;
	            face.materialIndex = gIdx;
	            geom.faces.push(face);
	            //face.color.set(new THREE.Color().setRGB( Math.random(), Math.random(), Math.random()));
	          }
	          //view.setFaceColor(sceneFace, utils.isSmoothPiece(group.shared) ? 0xFF0000 : null);
	          off = geom.vertices.length;
	        }
	        this.collectCurvedSurface(sceneFace);
	        this.collectWires(sceneFace, group.polygons);
	      }
	
	      geom.mergeVertices();
	
	      this.processWires();
	    }
	  }, {
	    key: 'collectCurvedSurface',
	    value: function collectCurvedSurface(face) {
	      var derivedFrom = getDerivedFrom(face.csgGroup.shared);
	      if (derivedFrom === null || !(0, _cadUtils.isCurveClass)(derivedFrom._class)) return;
	      var surfaces = this.curvedSurfaces[derivedFrom.id];
	      if (surfaces === undefined) {
	        surfaces = [];
	        this.curvedSurfaces[derivedFrom.id] = surfaces;
	      }
	      surfaces.push(face);
	      face.curvedSurfaces = surfaces;
	    }
	  }, {
	    key: 'collectWires',
	    value: function collectWires(face, facePolygons) {
	
	      function contains(planes, plane) {
	        for (var j = 0; j < planes.length; j++) {
	          if (planes[j].equals(plane)) {
	            return true;
	          }
	        }
	        return false;
	      }
	
	      var outline = (0, _workbench.findOutline)(facePolygons);
	      var paths = (0, _workbench.segmentsToPaths)(outline);
	
	      for (var i = 0; i < paths.length; i++) {
	        var path = paths[i];
	        var p,
	            q,
	            n = path.vertices.length;
	        for (q = 0, p = n - 1; q < n; p = q++) {
	          var edge = [path.vertices[p], path.vertices[q]];
	          var data = this.wires.get(edge);
	
	          if (data === null) {
	            data = {
	              sharedPlanes: [face.csgGroup.plane],
	              sharedFaces: [face]
	            };
	            this.wires.put(edge, data);
	          } else {
	            if (!contains(data.sharedPlanes, face.csgGroup.plane)) {
	              data.sharedPlanes.push(face.csgGroup.plane);
	            }
	            data.sharedFaces.push(face);
	          }
	        }
	      }
	    }
	  }, {
	    key: 'processWires',
	    value: function processWires() {
	      var solid = this;
	      this.wires.entries(function (edge, data) {
	        if (data.sharedPlanes.length > 1) {
	          var plane0 = data.sharedPlanes[0];
	          var plane1 = data.sharedPlanes[1];
	          var angle = Math.acos(plane0.normal.dot(plane1.normal));
	          if (angle < SMOOTH_LIMIT) {
	            return;
	          }
	        }
	        for (var i = 0; i < data.sharedFaces.length; ++i) {
	          for (var j = i + 1; j < data.sharedFaces.length; ++j) {
	            var face0 = data.sharedFaces[0];
	            var face1 = data.sharedFaces[1];
	            if (sameID(getDerivedID(face0.csgGroup.shared), getDerivedID(face1.csgGroup.shared))) {
	              return;
	            }
	          }
	        }
	
	        solid.addLineToScene(edge[0], edge[1]);
	      });
	    }
	  }]);
	
	  return MeshSceneSolid;
	}(_sceneObject.SceneSolid);
	
	function groupCSG(csg) {
	  var csgPolygons = csg.toPolygons();
	  var groups = {};
	  for (var i = 0; i < csgPolygons.length; i++) {
	    var p = csgPolygons[i];
	    var tag = p.shared.getTag();
	    if (groups[tag] === undefined) {
	      groups[tag] = {
	        tag: tag,
	        polygons: [],
	        shared: p.shared,
	        plane: p.plane
	      };
	    }
	    groups[tag].polygons.push(p);
	  }
	  return groups;
	}
	
	var SMOOTH_LIMIT = 10 * Math.PI / 180;
	
	var MeshSceneFace = function (_SceneFace) {
	  _inherits(MeshSceneFace, _SceneFace);
	
	  function MeshSceneFace(solid, csgGroup) {
	    _classCallCheck(this, MeshSceneFace);
	
	    var _this2 = _possibleConstructorReturn(this, (MeshSceneFace.__proto__ || Object.getPrototypeOf(MeshSceneFace)).call(this, solid, csgGroup.shared.__tcad.faceId));
	
	    csgGroup.__face = _this2;
	    csgGroup.shared.__tcad.faceId = _this2.id;
	
	    _this2.csgGroup = csgGroup;
	    _this2.curvedSurfaces = null;
	    return _this2;
	  }
	
	  _createClass(MeshSceneFace, [{
	    key: 'normal',
	    value: function normal() {
	      return this.csgGroup.plane.normal;
	    }
	  }, {
	    key: 'depth',
	    value: function depth() {
	      return this.csgGroup.plane.w;
	    }
	  }, {
	    key: 'surface',
	    value: function surface() {
	      return this.csgGroup.plane;
	    }
	  }, {
	    key: 'getBounds',
	    value: function getBounds() {
	      return (0, _workbench.reconstructSketchBounds)(this.solid.csg, this);
	    }
	  }]);
	
	  return MeshSceneFace;
	}(_sceneObject.SceneFace);
	
	function sameID(id1, id2) {
	  if (id1 === null || id2 === null) {
	    return false;
	  }
	  return id1 === id2;
	}
	
	function getDerivedID(shared) {
	  return shared.__tcad && !!shared.__tcad.csgInfo && !!shared.__tcad.csgInfo.derivedFrom ? shared.__tcad.csgInfo.derivedFrom.id : null;
	}
	
	function getDerivedFrom(shared) {
	  return shared.__tcad && !!shared.__tcad.csgInfo && !!shared.__tcad.csgInfo.derivedFrom ? shared.__tcad.csgInfo.derivedFrom : null;
	}

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.MESH_OPERATIONS = undefined;
	exports.sortPolygons = sortPolygons;
	exports.extrude = extrude;
	exports.cut = cut;
	exports.performRevolve = performRevolve;
	exports.polygonsToSegments = polygonsToSegments;
	exports.reconstructSketchBounds = reconstructSketchBounds;
	exports.findOutline = findOutline;
	exports.segmentsToPaths = segmentsToPaths;
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _cadUtils = __webpack_require__(302);
	
	var cad_utils = _interopRequireWildcard(_cadUtils);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	var _bezierCubic = __webpack_require__(312);
	
	var _l3space = __webpack_require__(308);
	
	var _hashmap = __webpack_require__(306);
	
	var _mesh = __webpack_require__(313);
	
	var _io = __webpack_require__(314);
	
	var _revolve = __webpack_require__(319);
	
	var _revolve2 = _interopRequireDefault(_revolve);
	
	var _triangulation = __webpack_require__(320);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function sortPolygons(polygons) {
	  function Loop(polygon) {
	    this.polygon = polygon;
	    this.nesting = [];
	    this.level = 0;
	  }
	  function contains(polygon, other) {
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = other._2D[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var point = _step.value;
	
	        if (!math.isPointInsidePolygon(point, polygon._2D)) {
	          return false;
	        }
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	
	    return true;
	  }
	  var loops = polygons.map(function (p) {
	    return new Loop(p);
	  });
	  for (var i = 0; i < loops.length; ++i) {
	    var loop = loops[i];
	    for (var j = 0; j < loops.length; ++j) {
	      if (i == j) continue;
	      var other = loops[j];
	      if (contains(loop.polygon, other.polygon)) {
	        loop.nesting.push(other);
	        other.level++;
	      }
	    }
	  }
	
	  var allShells = [];
	  function collect(level) {
	    var shells = loops.filter(function (l) {
	      return l.level == level;
	    });
	    if (shells.length == 0) {
	      return;
	    }
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	      for (var _iterator2 = shells[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	        var shell = _step2.value;
	
	        shell.nesting = shell.nesting.filter(function (l) {
	          return l.level == level + 1;
	        });
	        allShells.push(shell);
	      }
	    } catch (err) {
	      _didIteratorError2 = true;
	      _iteratorError2 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion2 && _iterator2.return) {
	          _iterator2.return();
	        }
	      } finally {
	        if (_didIteratorError2) {
	          throw _iteratorError2;
	        }
	      }
	    }
	
	    collect(level + 2);
	  }
	  collect(0);
	  return allShells;
	}
	
	function extrudeNestedLoops(sketchedPolygons, normal, target, expansionFactor) {
	  var loops = sortPolygons(sketchedPolygons);
	  var doExtrude = function doExtrude(polygon) {
	    var extruded = cad_utils.extrude(polygon, normal, target, expansionFactor);
	    return CSG.fromPolygons(_triangulateCSG(extruded));
	  };
	  var blob = null;
	  var _iteratorNormalCompletion3 = true;
	  var _didIteratorError3 = false;
	  var _iteratorError3 = undefined;
	
	  try {
	    for (var _iterator3 = loops[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	      var loop = _step3.value;
	
	      var shell = doExtrude(loop.polygon);
	      var _iteratorNormalCompletion4 = true;
	      var _didIteratorError4 = false;
	      var _iteratorError4 = undefined;
	
	      try {
	        for (var _iterator4 = loop.nesting[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	          var nestedLoop = _step4.value;
	
	          var hole = doExtrude(nestedLoop.polygon);
	          shell = shell.subtract(hole);
	        }
	      } catch (err) {
	        _didIteratorError4 = true;
	        _iteratorError4 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion4 && _iterator4.return) {
	            _iterator4.return();
	          }
	        } finally {
	          if (_didIteratorError4) {
	            throw _iteratorError4;
	          }
	        }
	      }
	
	      if (blob === null) {
	        blob = shell;
	      } else {
	        blob = blob.union(shell);
	      }
	    }
	  } catch (err) {
	    _didIteratorError3 = true;
	    _iteratorError3 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion3 && _iterator3.return) {
	        _iterator3.return();
	      }
	    } finally {
	      if (_didIteratorError3) {
	        throw _iteratorError3;
	      }
	    }
	  }
	
	  return blob;
	}
	
	function extrude(app, request) {
	  var face = request.face;
	  var sketchedPolygons = getSketchedPolygons3D(app, face);
	  if (sketchedPolygons == null) return null;
	  var normal = cad_utils.vec(face.csgGroup.plane.normal);
	  var blob = extrudeNestedLoops(sketchedPolygons, normal, request.params.target, request.params.expansionFactor);
	  var solid = request.solids[0];
	  if (solid.mergeable) {
	    blob = solid.csg.union(blob);
	  }
	  face.csgGroup.shared.__tcad.faceId += '$';
	  return [cad_utils.createSolid(blob, solid.id)];
	}
	
	function cut(app, request) {
	  var face = request.face;
	  var sketchedPolygons = getSketchedPolygons3D(app, face);
	  if (sketchedPolygons == null) return null;
	  var normal = cad_utils.vec(face.csgGroup.plane.normal);
	  var cutter = extrudeNestedLoops(sketchedPolygons, normal, request.params.target, request.params.expansionFactor);
	
	  face.csgGroup.shared.__tcad.faceId += '$';
	  var outSolids = [];
	  for (var si = 0; si < request.solids.length; si++) {
	    var solid = request.solids[si];
	    var work = solid.csg;
	    var _cut = work.subtract(cutter);
	    var solidMesh = cad_utils.createSolid(_cut, solid.id);
	    outSolids.push(solidMesh);
	  }
	  return outSolids;
	}
	
	function performRevolve(app, request) {
	  var face = request.face;
	  var sketchedPolygons = getSketchedPolygons3D(app, face);
	  if (sketchedPolygons == null) return null;
	
	  var params = request.params;
	
	  var vertices = face.getSketchObjectVerticesIn3D(params.pivotSketchObjectId);
	  if (!vertices) {
	    return null;
	  }
	  var axis = [vertices[0], vertices[vertices.length - 1]];
	  var revolved = (0, _revolve2.default)(sketchedPolygons, axis, params.angle / 180 * Math.PI, params.resolution);
	
	  var solid = request.solids[0];
	  var meld = CSG.fromPolygons(_triangulateCSG(revolved));
	  if (solid.mergeable) {
	    meld = solid.csg.union(meld);
	  }
	
	  face.csgGroup.shared.__tcad.faceId += '$';
	  return [cad_utils.createSolid(meld, solid.id)];
	}
	
	function _pointOnLine(p, a, b) {
	
	  var ab = a.minus(b);
	  var ap = a.minus(p);
	
	  var dp = ab.dot(ap);
	
	  var abLength = ab.length();
	  var apLength = ap.length();
	
	  return apLength > 0 && apLength < abLength && math.areEqual(abLength * apLength, dp, 1E-6);
	}
	
	function polygonsToSegments(polygons) {
	  function selfIntersecting(a, b, c) {
	    var f = _pointOnLine;
	    return f(c, a, b) || f(a, b, c) || f(b, c, a);
	  }
	  //polygons.filter(function(p) {
	  //  
	  //});
	  //magnitude of cross product is the area of parallelogram
	  //var area = points[b].pos.minus(points[a].pos).cross(points[c].pos.minus(points[a].pos)).length() / 2.0;
	  //if (selfIntersecting(points[a].pos, points[b].pos, points[c].pos))  {
	  //continue;
	  //}
	
	  var segmentsByPolygon = [];
	  for (var pi = 0; pi < polygons.length; pi++) {
	    var segments = [];
	    var poly = polygons[pi];
	    var p,
	        q,
	        n = poly.vertices.length;
	    for (p = n - 1, q = 0; q < n; p = q++) {
	      var a = poly.vertices[p];
	      var b = poly.vertices[q];
	      segments.push([a.pos, b.pos]);
	    }
	    segmentsByPolygon.push(segments);
	  }
	  return segmentsByPolygon;
	}
	
	function reconstructSketchBounds(csg, face, strict) {
	  strict = strict || false;
	  var polygons = csg.toPolygons();
	  var plane = face.csgGroup.plane;
	  var outerEdges = [];
	  var planePolygons = [];
	  for (var pi = 0; pi < polygons.length; pi++) {
	    var poly = polygons[pi];
	    if (math.equal(poly.plane.normal.dot(plane.normal), 1)) {
	      if (math.equal(plane.w, poly.plane.w) && (!strict || !!poly.shared.__tcad && poly.shared.__tcad.faceId === face.id)) {
	        planePolygons.push(poly);
	      }
	      continue;
	    }
	    var p,
	        q,
	        n = poly.vertices.length;
	    for (p = n - 1, q = 0; q < n; p = q++) {
	      var a = poly.vertices[p];
	      var b = poly.vertices[q];
	      var pointAOnPlane = math.equal(plane.signedDistanceToPoint(a.pos), 0);
	      if (!pointAOnPlane) continue;
	      var pointBOnPlane = math.equal(plane.signedDistanceToPoint(b.pos), 0);
	      if (pointBOnPlane) {
	        outerEdges.push([a.pos, b.pos, poly]);
	      }
	    }
	  }
	
	  var outline = findOutline(planePolygons);
	
	  pickUpCraftInfo(outline, outerEdges);
	
	  return segmentsToPaths(outline).map(function (poly) {
	    return poly.vertices;
	  });
	}
	
	function pickUpCraftInfo(outline, outerEdges) {
	  var eq = math.strictEqual;
	  for (var psi1 = 0; psi1 < outline.length; psi1++) {
	    var s1 = outline[psi1];
	    for (var psi2 = 0; psi2 < outerEdges.length; psi2++) {
	      var s2 = outerEdges[psi2];
	      if (math.equal(Math.abs(s1[0].minus(s1[1]).unit().dot(s2[0].minus(s2[1]).unit())), 1) && (eq(s1[0], s2[0]) || eq(s1[1], s2[1]) || eq(s1[0], s2[1]) || eq(s1[1], s2[0]) || _pointOnLine(s1[0], s2[0], s2[1]) || _pointOnLine(s1[1], s2[0], s2[1]))) {
	        s1[2] = s2[2];
	      }
	    }
	  }
	}
	
	function getOutlineByCollision(segments, outerEdges) {
	  var eq = math.strictEqual;
	  var outline = [];
	  for (var psi1 = 0; psi1 < segments.length; psi1++) {
	    var s1 = segments[psi1];
	    for (var psi2 = 0; psi2 < outerEdges.length; psi2++) {
	      var s2 = outerEdges[psi2];
	      if (math.equal(Math.abs(s1[0].minus(s1[1]).unit().dot(s2[0].minus(s2[1]).unit())), 1) && (eq(s1[0], s2[0]) || eq(s1[1], s2[1]) || eq(s1[0], s2[1]) || eq(s1[1], s2[0]) || _pointOnLine(s1[0], s2[0], s2[1]) || _pointOnLine(s1[1], s2[0], s2[1]))) {
	        outline.push(s1);
	      }
	    }
	  }
	  return outline;
	}
	
	function findOutline(planePolygons) {
	  var segmentsByPolygon = polygonsToSegments(planePolygons);
	  //simplifySegments(segmentsByPolygon);
	  var planeSegments = cad_utils.arrFlatten1L(segmentsByPolygon);
	  //planeSegments = removeSharedEdges(planeSegments);
	  removeTJoints(planeSegments);
	  planeSegments = removeSharedEdges(planeSegments);
	  return planeSegments;
	}
	
	function removeSharedEdges(segments) {
	  segments = segments.slice();
	  var eq = math.strictEqual;
	  for (var psi1 = 0; psi1 < segments.length; psi1++) {
	    var s1 = segments[psi1];
	    if (s1 == null) continue;
	    for (var psi2 = 0; psi2 < segments.length; psi2++) {
	      if (psi1 === psi2) continue;
	      var s2 = segments[psi2];
	      if (s2 == null) continue;
	      if (eq(s1[0], s2[0]) && eq(s1[1], s2[1]) || eq(s1[0], s2[1]) && eq(s1[1], s2[0])) {
	        segments[psi1] = null;
	        segments[psi2] = null;
	      }
	    }
	  }
	  return segments.filter(function (e) {
	    return e !== null;
	  });
	}
	
	function simplifySegments(polygonToSegments) {
	  for (var pi1 = 0; pi1 < polygonToSegments.length; ++pi1) {
	    for (var pi2 = 0; pi2 < polygonToSegments.length; ++pi2) {
	      if (pi1 === pi2) continue;
	      var polygon1 = polygonToSegments[pi1];
	      var polygon2 = polygonToSegments[pi2];
	      for (var si1 = 0; si1 < polygon1.length; ++si1) {
	        var seg1 = polygon1[si1];
	        for (var si2 = 0; si2 < polygon2.length; ++si2) {
	          var point = polygon2[si2][0];
	          if (_pointOnLine(point, seg1[0], seg1[1])) {
	            polygon1.push([point, seg1[1]]);
	            seg1[1] = point;
	          }
	        }
	      }
	    }
	  }
	}
	
	function _closeFactorToLine(p, seg1, seg2) {
	
	  var a = p.minus(seg1);
	  var b = seg2.minus(seg1);
	  var bn = b.unit();
	
	  var projLength = bn.dot(a);
	  var bx = bn.times(projLength);
	  if (!(projLength > 0 && projLength < b.length())) {
	    return -1;
	  }
	
	  var c = a.minus(bx);
	  return c.length();
	}
	
	function removeTJoints(segments) {
	  var pointIndex = _hashmap.HashTable.forVector3d();
	
	  for (var i = 0; i < segments.length; ++i) {
	    pointIndex.put(segments[i][0], 1);
	    pointIndex.put(segments[i][1], 1);
	  }
	
	  var points = pointIndex.getKeys();
	  var eq = math.strictEqual;
	  for (var pi1 = 0; pi1 < points.length; ++pi1) {
	    var point = points[pi1];
	    var best = null,
	        bestFactor;
	    for (var pi2 = 0; pi2 < segments.length; ++pi2) {
	      var seg = segments[pi2];
	      if (eq(seg[0], point) || eq(seg[1], point)) continue;
	      var factor = _closeFactorToLine(point, seg[0], seg[1]);
	      if (factor != -1 && factor < 1E-6 && (best == null || factor < bestFactor)) {
	        best = seg;
	        bestFactor = factor;
	      }
	    }
	    if (best != null) {
	      segments.push([point, best[1]]);
	      best[1] = point;
	    }
	  }
	}
	
	function deleteRedundantPoints(path) {
	  var cleanedPath = [];
	  //Delete redundant point
	  var pathLength = path.length;
	  var skipMode = false;
	  for (var pi = 0; pi < pathLength; pi++) {
	    var bIdx = (pi + 1) % pathLength;
	    var a = path[pi];
	    var b = path[bIdx];
	    var c = path[(pi + 2) % pathLength];
	    var eq = math.areEqual;
	    if (!skipMode) cleanedPath.push(a);
	    skipMode = eq(a.minus(b).unit().dot(b.minus(c).unit()), 1, 1E-9);
	  }
	  return cleanedPath;
	}
	
	function segmentsToPaths(segments) {
	
	  var veq = math.strictEqual;
	  var paths = [];
	  var index = _hashmap.HashTable.forVector3d();
	  var csgIndex = _hashmap.HashTable.forEdge();
	
	  function indexPoint(p, edge) {
	    var edges = index.get(p);
	    if (edges === null) {
	      edges = [];
	      index.put(p, edges);
	    }
	    edges.push(edge);
	  }
	
	  for (var si = 0; si < segments.length; si++) {
	    var k = segments[si];
	    indexPoint(k[0], k);
	    indexPoint(k[1], k);
	    var csgInfo = k[2];
	    if (csgInfo !== undefined && csgInfo !== null) {
	      csgIndex.put([k[0], k[1]], csgInfo);
	    }
	    k[3] = false;
	  }
	
	  function nextPoint(p) {
	    var edges = index.get(p);
	    if (edges === null) return null;
	    for (var i = 0; i < edges.length; i++) {
	      var edge = edges[i];
	      if (edge[3]) continue;
	      var res = null;
	      if (veq(p, edge[0])) res = edge[1];
	      if (veq(p, edge[1])) res = edge[0];
	      if (res != null) {
	        edge[3] = true;
	        return res;
	      }
	    }
	    return null;
	  }
	
	  var path;
	  for (var ei = 0; ei < segments.length; ei++) {
	    var edge = segments[ei];
	    if (edge[3]) {
	      continue;
	    }
	    edge[3] = true;
	    path = [edge[0], edge[1]];
	    paths.push(path);
	    var next = nextPoint(edge[1]);
	    while (next !== null) {
	      if (!veq(next, path[0])) {
	        path.push(next);
	        next = nextPoint(next);
	      } else {
	        next = null;
	      }
	    }
	  }
	
	  var filteredPaths = [];
	  for (var i = 0; i < paths.length; i++) {
	    path = paths[i];
	
	    //Set derived from object to be able to recunstruct
	    cad_utils.iteratePath(path, 0, function (a, b) {
	      var fromPolygon = csgIndex.get([a, b]);
	      if (fromPolygon !== null) {
	        if (fromPolygon.shared.__tcad.csgInfo) {
	          a.sketchConnectionObject = fromPolygon.shared.__tcad.csgInfo.derivedFrom;
	        }
	      }
	      return true;
	    });
	    path = deleteRedundantPoints(path);
	    if (path.length > 2) {
	      filteredPaths.push({
	        vertices: path
	      });
	    }
	  }
	
	  return filteredPaths;
	}
	
	function _triangulateCSG(polygons) {
	  function csgVert(data) {
	    return new CSG.Vertex(new CSG.Vector3D(data[0], data[1], data[2]));
	  }
	  function data(v) {
	    return [v.x, v.y, v.z];
	  }
	
	  var triangled = [];
	  var _iteratorNormalCompletion5 = true;
	  var _didIteratorError5 = false;
	  var _iteratorError5 = undefined;
	
	  try {
	    for (var _iterator5 = polygons[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	      var poly = _step5.value;
	
	      var vertices = (0, _triangulation.Triangulate)([poly.vertices.map(function (v) {
	        return data(v.pos);
	      })], data(poly.plane.normal));
	      for (var i = 0; i < vertices.length; i += 3) {
	        var a = csgVert(vertices[i]);
	        var b = csgVert(vertices[i + 1]);
	        var c = csgVert(vertices[i + 2]);
	        var csgPoly = new CSG.Polygon([a, b, c], poly.shared, poly.plane);
	        triangled.push(csgPoly);
	      }
	    }
	  } catch (err) {
	    _didIteratorError5 = true;
	    _iteratorError5 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion5 && _iterator5.return) {
	        _iterator5.return();
	      }
	    } finally {
	      if (_didIteratorError5) {
	        throw _iteratorError5;
	      }
	    }
	  }
	
	  return triangled;
	}
	
	function splitTwoSegments(a, b) {
	  var da = a[1].minus(a[0]);
	  var db = b[1].minus(b[0]);
	  var dc = b[0].minus(a[0]);
	
	  var daXdb = da.cross(db);
	  if (Math.abs(dc.dot(daXdb)) > 1e-6) {
	    // lines are not coplanar
	    return null;
	  }
	  var veq = math.strictEqual;
	  if (veq(a[0], b[0]) || veq(a[0], b[1]) || veq(a[1], b[0]) || veq(a[1], b[1])) {
	    return null;
	  }
	
	  var dcXdb = dc.cross(db);
	
	  function _split(s, ip) {
	    if (s[0].equals(ip) || s[1].equals(ip)) {
	      return [s];
	    }
	    return [[s[0], ip, s[2]], [ip, s[1], s[2]]];
	  }
	  var s = dcXdb.dot(daXdb) / daXdb.lengthSquared();
	  if (s > 0.0 && s < 1.0) {
	    var ip = a[0].plus(da.times(s));
	    return {
	      splitterParts: _split(a, ip),
	      residual: _split(b, ip)
	    };
	  }
	  return null;
	}
	
	function attract(vectors, precision) {
	  var eq = math.areEqual();
	  var dist = math.distanceAB3;
	  vectors = vectors.slice();
	  for (var i = 0; i < vectors.length; i++) {
	    var v1 = vectors[i];
	    if (v1 == null) continue;
	    for (var j = i + 1; j < vectors.length; j++) {
	      var v2 = vectors[j];
	      if (v2 == null) continue;
	      if (dist(v1, v2) <= precision) {
	        _vector2.default.prototype.setV.call(v2, v1);
	        vectors[j] = null;
	      }
	    }
	  }
	}
	
	function recoverySketchInfo(polygons) {
	  var nonStructuralGons = [];
	  var sketchEdges = _hashmap.HashTable.forDoubleArray();
	  function key(a, b) {
	    return [a.x, a.y, b.x, b.y];
	  }
	
	  for (var pi = 0; pi < polygons.length; pi++) {
	    var poly = polygons[pi];
	    var paths = [];
	    poly.collectPaths(paths);
	    var i, path, n, p, q;
	    for (i = 0; i < paths.length; i++) {
	      path = paths[i];
	      if (poly.csgInfo !== undefined && poly.csgInfo.derivedFrom !== undefined) {
	        n = path.length;
	        for (p = n - 1, q = 0; q < n; p = q++) {
	          sketchEdges.put(key(path[p], path[q]), poly.csgInfo);
	        }
	      } else {
	        nonStructuralGons.push(path);
	      }
	    }
	  }
	
	  for (i = 0; i < nonStructuralGons.length; i++) {
	    path = nonStructuralGons[i];
	    n = path.length;
	    for (p = n - 1, q = 0; q < n; p = q++) {
	      var csgInfo = sketchEdges.get(key(path[p], path[q]));
	      if (csgInfo === null) {
	        csgInfo = sketchEdges.get(key(path[q], path[p]));
	      }
	      if (csgInfo) {
	        path[p].sketchConnectionObject = csgInfo.derivedFrom;
	      }
	    }
	  }
	}
	
	function detach(request) {
	  var detachedConfig = {};
	  for (var prop in request) {
	    if (request.hasOwnProperty(prop)) {
	      var value = request[prop];
	      if (prop == 'solids') {
	        detachedConfig[prop] = value.map(function (s) {
	          return s.tCadId;
	        });
	      } else if (prop == 'face') {
	        detachedConfig[prop] = value.id;
	      } else if (prop == 'target') {
	        detachedConfig[prop] = [value.x, value.y, value.z];
	      } else if (prop == 'basis') {
	        detachedConfig[prop] = value.map(function (v) {
	          return [v.x, v.y, v.z];
	        });
	      } else if (prop == 'params') {
	        detachedConfig[prop] = detach(value);
	      } else {
	        detachedConfig[prop] = value;
	      }
	    }
	  }
	  return detachedConfig;
	}
	
	function materialize(index, detachedConfig) {
	  var request = {};
	  function required(value) {
	    if (value == null || value == undefined) throw "value is required";
	    return value;
	  }
	  for (var prop in detachedConfig) {
	    if (detachedConfig.hasOwnProperty(prop)) {
	      var value = detachedConfig[prop];
	      if (prop == 'solids') {
	        request[prop] = value.map(function (id) {
	          return required(index.solids[id]);
	        });
	      } else if (prop == 'target') {
	        request[prop] = new _vector2.default().set3(value);
	      } else if (prop == 'face') {
	        request[prop] = required(index.faces[value]);
	      } else if (prop == 'basis') {
	        request[prop] = value.map(function (v) {
	          return new _vector2.default().set3(v);
	        });
	      } else if (prop == 'params') {
	        request[prop] = materialize(index, value);
	      } else {
	        request[prop] = value;
	      }
	    }
	  }
	  return request;
	}
	
	var MESH_OPERATIONS = exports.MESH_OPERATIONS = {
	  CUT: cut,
	  EXTRUDE: extrude,
	  REVOLVE: performRevolve,
	  PLANE: function PLANE(app, request) {
	    var basis = void 0,
	        depth = request.params.depth;
	    var relativeToFaceId = request.params.relativeToFaceId;
	    if (relativeToFaceId != undefined && relativeToFaceId != '') {
	      var face = app.findFace(relativeToFaceId);
	      if (!face) return;
	      basis = face.basis();
	      depth += face.depth();
	    } else {
	      basis = request.params.basis;
	    }
	    return [cad_utils.createPlane(basis, depth)];
	  },
	  BOX: function BOX(app, request) {
	    var p = request.params;
	    return [cad_utils.createCSGBox(p.w, p.h, p.d)];
	  },
	  SPHERE: function SPHERE(app, request) {
	    return [cad_utils.createSphere(request.params.radius)];
	  },
	  IMPORT_STL: function IMPORT_STL(app, request) {
	    return request.params.objects.map(function (s) {
	      var smoothAngle = 1 / 180 * Math.PI;
	      var mesh = _mesh.Mesh.fromPolygons(s.faces.map(function (f) {
	        return f.vertices.map(function (v) {
	          return new _vector2.default().set3(v);
	        });
	      }), smoothAngle);
	      var polygons = [];
	      var _iteratorNormalCompletion6 = true;
	      var _didIteratorError6 = false;
	      var _iteratorError6 = undefined;
	
	      try {
	        var _loop = function _loop() {
	          var meshFace = _step6.value;
	
	          var pl = meshFace.polygons[0];
	          var plane = new CSG.Plane(pl.normal.csg(), pl.w);
	          var shared = cad_utils.createShared();
	          meshFace.polygons.map(function (p) {
	            return new CSG.Polygon(p.points.map(function (v) {
	              return new CSG.Vertex(v.csg());
	            }), shared, plane);
	          }).forEach(function (p) {
	            return polygons.push(p);
	          });
	        };
	
	        for (var _iterator6 = mesh.faces[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	          _loop();
	        }
	      } catch (err) {
	        _didIteratorError6 = true;
	        _iteratorError6 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion6 && _iterator6.return) {
	            _iterator6.return();
	          }
	        } finally {
	          if (_didIteratorError6) {
	            throw _iteratorError6;
	          }
	        }
	      }
	
	      return cad_utils.createSolid(CSG.fromPolygons(polygons));
	    });
	  }
	};

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.LUT = LUT;
	exports.compute = compute;
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function LUT(a, b, cp1, cp2, scale) {
	  scale = 1 / scale;
	  var lut = [];
	  for (var t = 0; t < 1; t += 0.1 * scale) {
	    var p = compute(t, a, b, cp1, cp2);
	    lut.push(p);
	  }
	  lut[0] = a;
	  lut[lut.length - 1] = b;
	  return lut;
	}
	
	function compute(t, from, to, controlPoint1, controlPoint2) {
	  var mt = 1 - t;
	  var mt2 = mt * mt;
	  var t2 = t * t;
	
	  var a = mt2 * mt;
	  var b = mt2 * t * 3;
	  var c = mt * t2 * 3;
	  var d = t * t2;
	  var p0 = from;
	  var p3 = to;
	  var p1 = controlPoint1;
	  var p2 = controlPoint2;
	  return new _vector2.default(a * p0.x + b * p1.x + c * p2.x + d * p3.x, a * p0.y + b * p1.y + c * p2.y + d * p3.y, a * p0.z + b * p1.z + c * p2.z + d * p3.z);
	}

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.MeshFace = MeshFace;
	exports.MeshPolygon = MeshPolygon;
	exports.Mesh = Mesh;
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _cadUtils = __webpack_require__(302);
	
	var cad_utils = _interopRequireWildcard(_cadUtils);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	var _l3space = __webpack_require__(308);
	
	var _hashmap = __webpack_require__(306);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function MeshFace() {
	  this.polygons = [];
	}
	
	function MeshPolygon(id, normal, w, points) {
	  this.id = id;
	  this.normal = normal;
	  this.w = w;
	  this.points = points;
	  this.neighbors = [];
	}
	
	function Mesh(edges) {
	  this.edges = edges;
	  this.faces = [];
	  this.getEdgeInfo = function (point1, point2) {
	    return edges.get(arguments);
	  };
	}
	
	Mesh.fromPolygons = function (polygons, smoothAngle) {
	  var edges = _hashmap.HashTable.forEdge();
	
	  var counter = 0;
	  var allPolygons = [];
	  function index(polygon) {
	    if (polygon.length < 3) {
	      console.warn('invalid polygon ' + polygon);
	      return;
	    }
	    var normal = cad_utils.normalOfCCWSeq(polygon);
	    var w = normal.dot(polygon[0]);
	
	    var polygonInfo = new MeshPolygon(counter++, normal, w, polygon);
	
	    allPolygons.push(polygonInfo);
	
	    for (var p = polygon.length - 1, q = 0; q < polygon.length; p = q++) {
	      var edgeKey = [polygon[p], polygon[q]];
	      var edgeInfo = edges.get(edgeKey);
	      if (edgeInfo == null) {
	        edges.put(edgeKey, [polygonInfo]);
	      } else {
	        var other = edgeInfo[0];
	        other.neighbors.push(polygonInfo);
	        polygonInfo.neighbors.push(other);
	        edgeInfo.push(polygonInfo);
	      }
	    }
	  }
	
	  var visited = {};
	  function mergePolygons(tr, meshFace) {
	    if (visited[tr.id]) {
	      return;
	    }
	    visited[tr.id] = true;
	    meshFace.polygons.push(tr);
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = tr.neighbors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var nb = _step.value;
	
	        if (Math.acos(nb.normal.dot(tr.normal)) < smoothAngle) {
	          mergePolygons(nb, meshFace);
	        }
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	  }
	  polygons.forEach(function (p) {
	    return index(p);
	  });
	  var mesh = new Mesh(edges);
	  var _iteratorNormalCompletion2 = true;
	  var _didIteratorError2 = false;
	  var _iteratorError2 = undefined;
	
	  try {
	    for (var _iterator2 = allPolygons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	      var tr = _step2.value;
	
	      var meshFace = new MeshFace();
	      mergePolygons(tr, meshFace);
	      if (meshFace.polygons.length != 0) {
	        mesh.faces.push(meshFace);
	      }
	    }
	  } catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion2 && _iterator2.return) {
	        _iterator2.return();
	      }
	    } finally {
	      if (_didIteratorError2) {
	        throw _iteratorError2;
	      }
	    }
	  }
	
	  return mesh;
	};

/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.LoadSTLFromURL = LoadSTLFromURL;
	
	var _stlReader = __webpack_require__(315);
	
	function LoadSTLFromURL(url, solidsConsumer) {
	  var xhr = new XMLHttpRequest();
	  xhr.onreadystatechange = function () {
	    if (this.readyState == 4) {
	      //console.log(this.response, typeof this.response);
	      if (this.status == 200) {
	        var reader = new FileReader();
	        reader.addEventListener("loadend", function () {
	          var solids = (0, _stlReader.ParseStl)(reader.result);
	          solidsConsumer(solids);
	        });
	        reader.readAsArrayBuffer(this.response);
	      } else {
	        solidsConsumer(null, this.status);
	      }
	    }
	  };
	  xhr.open('GET', url);
	  xhr.responseType = 'blob';
	  xhr.send();
	}

/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ParseStl = ParseStl;
	
	var _stlAsciiReader = __webpack_require__(316);
	
	var _stlBinaryReader = __webpack_require__(318);
	
	function ParseStl(buf) {
	  if (typeof buf === 'string') {
	    return (0, _stlAsciiReader.parse)(buf);
	  }
	
	  // The other way is to check if file starts with 'solid' then it's ascii
	  // WIKI: A binary STL file has an 80-character header (which is generally ignored, but should never begin with "solid" 
	  // because that will lead most software to assume that this is an ASCII STL file
	
	  var dataView = new DataView(buf);
	  var triangleCount = dataView.getUint32(80, true);
	  var expectedSize = 80 + 4 + triangleCount * (4 * 3 * 4 + 2);
	
	  if (expectedSize === buf.byteLength) {
	    return [(0, _stlBinaryReader.parse)(dataView)];
	  }
	
	  return (0, _stlAsciiReader.parse)(buf);
	}

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.parse = parse;
	
	var _stlDataStructure = __webpack_require__(317);
	
	function parse(buf) {
	
	  var solid = new _stlDataStructure.StlSolid('');
	  var face = new _stlDataStructure.StlFace(null);
	  var solids = [];
	  var reader = new LinesReader(buf);
	  var lineNumber = 0;
	  while (reader.hasNextLine()) {
	    var line = reader.nextLine();
	    lineNumber++;
	    var parts = line.trim().split(' ').filter(function (part) {
	      return part !== '';
	    });
	    switch (parts[0]) {
	      case 'solid':
	        solid = new _stlDataStructure.StlSolid(parts.slice(1).join(' '));
	        break;
	      case 'endsolid':
	        solids.push(solid);
	        break;
	      case 'facet':
	        var noramlParts = parts.slice(2);
	        if (noramlParts.length == 3) {
	          face.normal = noramlParts.map(Number);
	        } else {
	          console.warn('bad normal definition at line ' + lineNumber);
	        }
	        break;
	      case 'vertex':
	        var position = parts.slice(1).map(Number);
	        face.vertices.push(position);
	        break;
	      case 'endfacet':
	        if (face.normal != null && face.vertices.length == 3) {
	          solid.faces.push(face);
	        } else {
	          console.warn('bad stl face at line ' + lineNumber);
	        }
	        face = new _stlDataStructure.StlFace(null);
	      default:
	      // skip
	    }
	  }
	  return solids;
	}
	
	function LinesReader(buf) {
	  var mark = 0;
	  var pos = 0;
	  var arr = new Uint8Array(buf);
	  this.nextLine = function () {
	    var str = "";
	    for (var i = mark; i < pos; i++) {
	      str += String.fromCharCode(arr[i]);
	    }
	    mark = pos;
	    return str;
	  };
	  this.hasNextLine = function () {
	    while (pos < arr.length) {
	      if (arr[pos++] == 10) {
	        return true;
	      }
	    }
	    return false;
	  };
	}

/***/ },
/* 317 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.StlSolid = StlSolid;
	exports.StlFace = StlFace;
	function StlSolid(name) {
	  this.name = name;
	  this.faces = [];
	}
	
	function StlFace(normal) {
	  this.normal = normal;
	  this.vertices = [];
	}

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.parse = parse;
	
	var _stlDataStructure = __webpack_require__(317);
	
	function readVector(dataView, off) {
	  return [dataView.getFloat32(off + 0, true), dataView.getFloat32(off + 4, true), dataView.getFloat32(off + 8, true)];
	}
	
	function parse(dataView) {
	  var solid = new _stlDataStructure.StlSolid('binary');
	  var off = 80; // skip header
	
	  var triangleCount = dataView.getUint32(off, true);
	  off += 4;
	
	  for (var i = 0; i < triangleCount; i++) {
	    var normal = readVector(dataView, off);
	    off += 12; // 3 floats
	
	    var face = new _stlDataStructure.StlFace(normal);
	
	    for (var j = 0; j < 3; j++) {
	      var position = readVector(dataView, off);
	      off += 12;
	      face.vertices.push(position);
	    }
	    solid.faces.push(face);
	    off += 2; // skip attribute byte count
	  }
	  return solid;
	}

/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = revolve;
	exports.revolveToWireframe = revolveToWireframe;
	exports.revolveToTriangles = revolveToTriangles;
	exports.revolveIterator = revolveIterator;
	
	var _l3space = __webpack_require__(308);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	var _cadUtils = __webpack_require__(302);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Group(derivedFrom) {
	  this.polygons = [];
	  this.derivedFrom = derivedFrom;
	}
	
	function revolve(polygons, axisSegment, angle, resolution) {
	  var groups = {};
	  var out = [];
	  var lids = revolveIterator(polygons, axisSegment, angle, resolution, function (pOrig, pRot, p, q, reverse, segmentId) {
	    var polygon = [pOrig[p], pOrig[q]];
	
	    //skip point if they are on the axis of revolving
	    if (!math.equal(0, math.distanceAB3(pOrig[q], pRot[q]))) {
	      polygon.push(pRot[q]);
	    }
	    if (!math.equal(0, math.distanceAB3(pOrig[p], pRot[p]))) {
	      polygon.push(pRot[p]);
	    }
	    if (polygon.length < 3) {
	      return;
	    }
	    if (reverse) {
	      polygon.reverse(); //fixes CCW order
	    }
	
	    var shared = (0, _cadUtils.createShared)();
	    var sketchConnectionObject = pOrig[p].sketchConnectionObject;
	    if (sketchConnectionObject) {
	      if (sketchConnectionObject._class == 'TCAD.TWO.Segment') {
	        sketchConnectionObject = Object.assign({}, sketchConnectionObject, {
	          _class: 'TCAD.TWO.Arc',
	          id: sketchConnectionObject.id + ":REVOLVED" // just avoid having object with the same ID but different classes
	        });
	      }
	      shared.__tcad.csgInfo = { derivedFrom: sketchConnectionObject };
	      pRot[p].sketchConnectionObject = sketchConnectionObject;
	    }
	
	    var face = csgPolygon(polygon, shared);
	    out.push(face);
	  });
	  if (!math.equal(_360, angle)) {
	    if (angle < 0) {
	      var t = lids;
	      lids = polygons;
	      polygons = t;
	    }
	    lids.forEach(function (p) {
	      return out.push(csgPolygon(p, (0, _cadUtils.createShared)()));
	    });
	    polygons.forEach(function (p) {
	      return out.push(csgPolygon(p.slice().reverse(), (0, _cadUtils.createShared)()));
	    });
	  }
	  return out;
	}
	
	function revolveToWireframe(polygons, axisSegment, angle, resolution) {
	  var out = [];
	  //add initial polygon
	  addAsSegments(out, polygons);
	  revolveIterator(polygons, axisSegment, angle, resolution, function (pOrig, pRot, p, q) {
	    out.push([pRot[p], pRot[q]]);
	    addIfNonZero(out, [pOrig[q], pRot[q]]);
	    addIfNonZero(out, [pOrig[p], pRot[p]]);
	  });
	  return out;
	}
	
	function revolveToTriangles(polygons, axisSegment, angle, resolution) {
	  var out = [];
	  //add initial polygon
	  revolveIterator(polygons, axisSegment, angle, resolution, function (pOrig, pRot, p, q) {
	    //skip point if they are on the axis of revolving
	    if (!math.equal(0, math.distanceAB3(pOrig[q], pRot[q]))) {
	      out.push([pOrig[p], pOrig[q], pRot[q]]);
	    }
	    if (!math.equal(0, math.distanceAB3(pOrig[p], pRot[p]))) {
	      out.push([pRot[q], pRot[p], pOrig[p]]);
	    }
	  });
	  if (angle < 0) {
	    out.forEach(function (tr) {
	      return tr.reverse();
	    });
	  }
	  return out;
	}
	
	function revolveIterator(polygons, axisSegment, angle, resolution, callback) {
	
	  if (resolution < 2) resolution = 2;
	  var reverse = angle < 0;
	  angle = Math.abs(angle);
	  if (angle > _360) {
	    angle = _360;
	  }
	
	  var angleStep = angle / resolution * (reverse ? -1 : 1);
	  var axis = new _vector2.default().setV(axisSegment[1])._minus(axisSegment[0]);
	  var tr = _l3space.Matrix3.rotateMatrix(angleStep, axis, axisSegment[0]);
	
	  for (var resIndex = 0; resIndex < resolution; resIndex++) {
	    var rotatedPolygons = polygons.map(function (poly) {
	      return poly.map(function (point) {
	        return tr.apply(point);
	      });
	    });
	    var segmentId = 0;
	    for (var i = 0; i < polygons.length; i++) {
	      var pOrig = polygons[i];
	      var pRot = rotatedPolygons[i];
	      var n = pOrig.length;
	      for (var p = n - 1, q = 0; q < n; p = q++) {
	        callback(pOrig, pRot, p, q, reverse, segmentId++);
	      }
	    }
	    polygons = rotatedPolygons;
	  }
	  return polygons;
	}
	
	function addIfNonZero(out, seg) {
	  if (!math.equal(0, math.distanceAB3(seg[0], seg[1]))) {
	    out.push(seg);
	  }
	}
	
	function addAsSegments(out, polygons) {
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = polygons[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var poly = _step.value;
	
	      for (var p = poly.length - 1, q = 0; q < poly.length; p = q++) {
	        out.push([poly[p], poly[q]]);
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	}
	
	function csgPolygon(points, shared) {
	  return new CSG.Polygon(points.map(function (p) {
	    return new CSG.Vertex(p.csg());
	  }), shared);
	}
	
	var _360 = 2 * Math.PI;

/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Triangulate = Triangulate;
	exports.TriangulatePolygons = TriangulatePolygons;
	exports.TriangulateFace = TriangulateFace;
	
	var _libtess = __webpack_require__(321);
	
	var _libtess2 = _interopRequireDefault(_libtess);
	
	var _point = __webpack_require__(322);
	
	var _vertex = __webpack_require__(323);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function initTesselator() {
	  // function called for each vertex of tesselator output
	  function vertexCallback(data, polyVertArray) {
	    polyVertArray.push(data);
	  }
	  // callback for when segments intersect and must be split
	  function combinecallback(coords, data, weight) {
	    // console.log('combine callback');
	    return [coords[0], coords[1], coords[2]];
	  }
	  function edgeCallback(flag) {
	    // don't really care about the flag, but need no-strip/no-fan behavior
	    // console.log('edge flag: ' + flag);
	  }
	
	  var tessy = new _libtess2.default.GluTesselator();
	  // tessy.gluTessProperty(libtess.gluEnum.GLU_TESS_WINDING_RULE, libtess.windingRule.GLU_TESS_WINDING_POSITIVE);
	  tessy.gluTessCallback(_libtess2.default.gluEnum.GLU_TESS_VERTEX_DATA, vertexCallback);
	  tessy.gluTessCallback(_libtess2.default.gluEnum.GLU_TESS_BEGIN, begincallback);
	  tessy.gluTessCallback(_libtess2.default.gluEnum.GLU_TESS_ERROR, errorcallback);
	  tessy.gluTessCallback(_libtess2.default.gluEnum.GLU_TESS_COMBINE, combinecallback);
	  tessy.gluTessCallback(_libtess2.default.gluEnum.GLU_TESS_EDGE_FLAG, edgeCallback);
	
	  return tessy;
	}
	
	function begincallback(type) {
	  if (type !== _libtess2.default.primitiveType.GL_TRIANGLES) {
	    console.log('expected TRIANGLES but got type: ' + type);
	  }
	}
	
	function errorcallback(errno) {
	  console.log('error callback');
	  console.log('error number: ' + errno);
	}
	
	function Triangulate(contours, normal) {
	  var tessy = initTesselator();
	  // libtess will take 3d verts and flatten to a plane for tesselation
	  // since only doing 2d tesselation here, provide z=1 normal to skip
	  // iterating over verts only to get the same answer.
	  // comment out to test normal-generation code
	  //tessy.gluTessNormal(0, 0, 1);
	  tessy.gluTessNormal(normal[0], normal[1], normal[2]);
	
	  var triangleVerts = [];
	  tessy.gluTessBeginPolygon(triangleVerts);
	
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = contours[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var contour = _step.value;
	
	      tessy.gluTessBeginContour();
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        for (var _iterator2 = contour[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var coords = _step2.value;
	
	          tessy.gluTessVertex(coords, coords);
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	
	      tessy.gluTessEndContour();
	    }
	
	    // finish polygon (and time triangulation process)
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  tessy.gluTessEndPolygon();
	  return triangleVerts;
	}
	
	function TriangulatePolygons(polygons, normal, toArray, fromArray) {
	  var triangled = [];
	  var contours = [];
	  var _iteratorNormalCompletion3 = true;
	  var _didIteratorError3 = false;
	  var _iteratorError3 = undefined;
	
	  try {
	    for (var _iterator3 = polygons[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	      var poly = _step3.value;
	
	      contours.push(poly.map(function (point) {
	        return toArray(point);
	      }));
	    }
	  } catch (err) {
	    _didIteratorError3 = true;
	    _iteratorError3 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion3 && _iterator3.return) {
	        _iterator3.return();
	      }
	    } finally {
	      if (_didIteratorError3) {
	        throw _iteratorError3;
	      }
	    }
	  }
	
	  var vertices = Triangulate(contours, toArray(normal));
	  for (var i = 0; i < vertices.length; i += 3) {
	    var a = fromArray(vertices[i]);
	    var b = fromArray(vertices[i + 1]);
	    var c = fromArray(vertices[i + 2]);
	    triangled.push([a, b, c]);
	  }
	  return triangled;
	}
	
	function TriangulateFace(face) {
	  function arr(v) {
	    return [v.x, v.y, v.z];
	  }
	
	  function vertexCallback(data, out) {
	    out.push(data);
	  }
	  function combinecallback(coords, data, weight) {
	    //throw 'should never happen cuz brep is non-manifold'
	  }
	  function edgeCallback(flag) {}
	
	  var tessy = new _libtess2.default.GluTesselator();
	  // tessy.gluTessProperty(libtess.gluEnum.GLU_TESS_WINDING_RULE, libtess.windingRule.GLU_TESS_WINDING_POSITIVE);
	  tessy.gluTessCallback(_libtess2.default.gluEnum.GLU_TESS_VERTEX_DATA, vertexCallback);
	  tessy.gluTessCallback(_libtess2.default.gluEnum.GLU_TESS_BEGIN, begincallback);
	  tessy.gluTessCallback(_libtess2.default.gluEnum.GLU_TESS_ERROR, errorcallback);
	  tessy.gluTessCallback(_libtess2.default.gluEnum.GLU_TESS_COMBINE, combinecallback);
	  tessy.gluTessCallback(_libtess2.default.gluEnum.GLU_TESS_EDGE_FLAG, edgeCallback);
	
	  var normal = arr(face.surface.normal);
	  tessy.gluTessNormal(normal[0], normal[1], normal[2]);
	
	  var vertices = [];
	  tessy.gluTessBeginPolygon(vertices);
	
	  var _iteratorNormalCompletion4 = true;
	  var _didIteratorError4 = false;
	  var _iteratorError4 = undefined;
	
	  try {
	    for (var _iterator4 = face.loops[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	      var loop = _step4.value;
	
	      tessy.gluTessBeginContour();
	      var _iteratorNormalCompletion5 = true;
	      var _didIteratorError5 = false;
	      var _iteratorError5 = undefined;
	
	      try {
	        for (var _iterator5 = loop.halfEdges[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	          var e = _step5.value;
	
	          tessy.gluTessVertex(arr(e.vertexA.point), e.vertexA);
	        }
	      } catch (err) {
	        _didIteratorError5 = true;
	        _iteratorError5 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion5 && _iterator5.return) {
	            _iterator5.return();
	          }
	        } finally {
	          if (_didIteratorError5) {
	            throw _iteratorError5;
	          }
	        }
	      }
	
	      tessy.gluTessEndContour();
	    }
	  } catch (err) {
	    _didIteratorError4 = true;
	    _iteratorError4 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion4 && _iterator4.return) {
	        _iterator4.return();
	      }
	    } finally {
	      if (_didIteratorError4) {
	        throw _iteratorError4;
	      }
	    }
	  }
	
	  tessy.gluTessEndPolygon();
	
	  var triangled = [];
	
	  for (var i = 0; i < vertices.length; i += 3) {
	    var a = vertices[i];
	    var b = vertices[i + 1];
	    var c = vertices[i + 2];
	    triangled.push([a, b, c]);
	  }
	  return triangled;
	}

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	/*
	
	 Copyright 2000, Silicon Graphics, Inc. All Rights Reserved.
	 Copyright 2015, Google Inc. All Rights Reserved.
	
	 Permission is hereby granted, free of charge, to any person obtaining a copy
	 of this software and associated documentation files (the "Software"), to
	 deal in the Software without restriction, including without limitation the
	 rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	 sell copies of the Software, and to permit persons to whom the Software is
	 furnished to do so, subject to the following conditions:
	
	 The above copyright notice including the dates of first publication and
	 either this permission notice or a reference to http://oss.sgi.com/projects/FreeB/
	 shall be included in all copies or substantial portions of the Software.
	
	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
	 SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
	 IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	 Original Code. The Original Code is: OpenGL Sample Implementation,
	 Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
	 Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
	 Copyright in any portions created by third parties is as indicated
	 elsewhere herein. All Rights Reserved.
	*/
	'use strict';var n;function t(a,b){return a.b===b.b&&a.a===b.a}function u(a,b){return a.b<b.b||a.b===b.b&&a.a<=b.a}function v(a,b,c){var d=b.b-a.b,e=c.b-b.b;return 0<d+e?d<e?b.a-a.a+d/(d+e)*(a.a-c.a):b.a-c.a+e/(d+e)*(c.a-a.a):0}function x(a,b,c){var d=b.b-a.b,e=c.b-b.b;return 0<d+e?(b.a-c.a)*d+(b.a-a.a)*e:0}function z(a,b){return a.a<b.a||a.a===b.a&&a.b<=b.b}function aa(a,b,c){var d=b.a-a.a,e=c.a-b.a;return 0<d+e?d<e?b.b-a.b+d/(d+e)*(a.b-c.b):b.b-c.b+e/(d+e)*(c.b-a.b):0}
	function ba(a,b,c){var d=b.a-a.a,e=c.a-b.a;return 0<d+e?(b.b-c.b)*d+(b.b-a.b)*e:0}function ca(a){return u(a.b.a,a.a)}function da(a){return u(a.a,a.b.a)}function A(a,b,c,d){a=0>a?0:a;c=0>c?0:c;return a<=c?0===c?(b+d)/2:b+a/(a+c)*(d-b):d+c/(a+c)*(b-d)};function ea(a){var b=B(a.b);C(b,a.c);C(b.b,a.c);D(b,a.a);return b}function E(a,b){var c=!1,d=!1;a!==b&&(b.a!==a.a&&(d=!0,F(b.a,a.a)),b.d!==a.d&&(c=!0,G(b.d,a.d)),H(b,a),d||(C(b,a.a),a.a.c=a),c||(D(b,a.d),a.d.a=a))}function I(a){var b=a.b,c=!1;a.d!==a.b.d&&(c=!0,G(a.d,a.b.d));a.c===a?F(a.a,null):(a.b.d.a=J(a),a.a.c=a.c,H(a,J(a)),c||D(a,a.d));b.c===b?(F(b.a,null),G(b.d,null)):(a.d.a=J(b),b.a.c=b.c,H(b,J(b)));fa(a)}
	function K(a){var b=B(a),c=b.b;H(b,a.e);b.a=a.b.a;C(c,b.a);b.d=c.d=a.d;b=b.b;H(a.b,J(a.b));H(a.b,b);a.b.a=b.a;b.b.a.c=b.b;b.b.d=a.b.d;b.f=a.f;b.b.f=a.b.f;return b}function L(a,b){var c=!1,d=B(a),e=d.b;b.d!==a.d&&(c=!0,G(b.d,a.d));H(d,a.e);H(e,b);d.a=a.b.a;e.a=b.a;d.d=e.d=a.d;a.d.a=e;c||D(d,a.d);return d}function B(a){var b=new M,c=new M,d=a.b.h;c.h=d;d.b.h=b;b.h=a;a.b.h=c;b.b=c;b.c=b;b.e=c;c.b=b;c.c=c;return c.e=b}function H(a,b){var c=a.c,d=b.c;c.b.e=b;d.b.e=a;a.c=d;b.c=c}
	function C(a,b){var c=b.f,d=new N(b,c);c.e=d;b.f=d;c=d.c=a;do c.a=d,c=c.c;while(c!==a)}function D(a,b){var c=b.d,d=new ga(b,c);c.b=d;b.d=d;d.a=a;d.c=b.c;c=a;do c.d=d,c=c.e;while(c!==a)}function fa(a){var b=a.h;a=a.b.h;b.b.h=a;a.b.h=b}function F(a,b){var c=a.c,d=c;do d.a=b,d=d.c;while(d!==c);c=a.f;d=a.e;d.f=c;c.e=d}function G(a,b){var c=a.a,d=c;do d.d=b,d=d.e;while(d!==c);c=a.d;d=a.b;d.d=c;c.b=d};function ha(a){var b=0;Math.abs(a[1])>Math.abs(a[0])&&(b=1);Math.abs(a[2])>Math.abs(a[b])&&(b=2);return b};var O=4*1E150;function P(a,b){a.f+=b.f;a.b.f+=b.b.f}function ia(a,b,c){a=a.a;b=b.a;c=c.a;if(b.b.a===a)return c.b.a===a?u(b.a,c.a)?0>=x(c.b.a,b.a,c.a):0<=x(b.b.a,c.a,b.a):0>=x(c.b.a,a,c.a);if(c.b.a===a)return 0<=x(b.b.a,a,b.a);b=v(b.b.a,a,b.a);a=v(c.b.a,a,c.a);return b>=a}function Q(a){a.a.i=null;var b=a.e;b.a.c=b.c;b.c.a=b.a;a.e=null}function ja(a,b){I(a.a);a.c=!1;a.a=b;b.i=a}function ka(a){var b=a.a.a;do a=R(a);while(a.a.a===b);a.c&&(b=L(S(a).a.b,a.a.e),ja(a,b),a=R(a));return a}
	function la(a,b,c){var d=new ma;d.a=c;d.e=na(a.f,b.e,d);return c.i=d}function oa(a,b){switch(a.s){case 100130:return 0!==(b&1);case 100131:return 0!==b;case 100132:return 0<b;case 100133:return 0>b;case 100134:return 2<=b||-2>=b}return!1}function pa(a){var b=a.a,c=b.d;c.c=a.d;c.a=b;Q(a)}function T(a,b,c){a=b;for(b=b.a;a!==c;){a.c=!1;var d=S(a),e=d.a;if(e.a!==b.a){if(!d.c){pa(a);break}e=L(b.c.b,e.b);ja(d,e)}b.c!==e&&(E(J(e),e),E(b,e));pa(a);b=d.a;a=d}return b}
	function U(a,b,c,d,e,f){var g=!0;do la(a,b,c.b),c=c.c;while(c!==d);for(null===e&&(e=S(b).a.b.c);;){d=S(b);c=d.a.b;if(c.a!==e.a)break;c.c!==e&&(E(J(c),c),E(J(e),c));d.f=b.f-c.f;d.d=oa(a,d.f);b.b=!0;!g&&qa(a,b)&&(P(c,e),Q(b),I(e));g=!1;b=d;e=c}b.b=!0;f&&ra(a,b)}function sa(a,b,c,d,e){var f=[b.g[0],b.g[1],b.g[2]];b.d=null;b.d=a.o?a.o(f,c,d,a.c)||null:null;null===b.d&&(e?a.n||(V(a,100156),a.n=!0):b.d=c[0])}
	function ta(a,b,c){var d=[null,null,null,null];d[0]=b.a.d;d[1]=c.a.d;sa(a,b.a,d,[.5,.5,0,0],!1);E(b,c)}function ua(a,b,c,d,e){var f=Math.abs(b.b-a.b)+Math.abs(b.a-a.a),g=Math.abs(c.b-a.b)+Math.abs(c.a-a.a),h=e+1;d[e]=.5*g/(f+g);d[h]=.5*f/(f+g);a.g[0]+=d[e]*b.g[0]+d[h]*c.g[0];a.g[1]+=d[e]*b.g[1]+d[h]*c.g[1];a.g[2]+=d[e]*b.g[2]+d[h]*c.g[2]}
	function qa(a,b){var c=S(b),d=b.a,e=c.a;if(u(d.a,e.a)){if(0<x(e.b.a,d.a,e.a))return!1;if(!t(d.a,e.a))K(e.b),E(d,J(e)),b.b=c.b=!0;else if(d.a!==e.a){var c=a.e,f=d.a.h;if(0<=f){var c=c.b,g=c.d,h=c.e,k=c.c,l=k[f];g[l]=g[c.a];k[g[l]]=l;l<=--c.a&&(1>=l?W(c,l):u(h[g[l>>1]],h[g[l]])?W(c,l):va(c,l));h[f]=null;k[f]=c.b;c.b=f}else for(c.c[-(f+1)]=null;0<c.a&&null===c.c[c.d[c.a-1]];)--c.a;ta(a,J(e),d)}}else{if(0>x(d.b.a,e.a,d.a))return!1;R(b).b=b.b=!0;K(d.b);E(J(e),d)}return!0}
	function wa(a,b){var c=S(b),d=b.a,e=c.a,f=d.a,g=e.a,h=d.b.a,k=e.b.a,l=new N;x(h,a.a,f);x(k,a.a,g);if(f===g||Math.min(f.a,h.a)>Math.max(g.a,k.a))return!1;if(u(f,g)){if(0<x(k,f,g))return!1}else if(0>x(h,g,f))return!1;var r=h,p=f,q=k,y=g,m,w;u(r,p)||(m=r,r=p,p=m);u(q,y)||(m=q,q=y,y=m);u(r,q)||(m=r,r=q,q=m,m=p,p=y,y=m);u(q,p)?u(p,y)?(m=v(r,q,p),w=v(q,p,y),0>m+w&&(m=-m,w=-w),l.b=A(m,q.b,w,p.b)):(m=x(r,q,p),w=-x(r,y,p),0>m+w&&(m=-m,w=-w),l.b=A(m,q.b,w,y.b)):l.b=(q.b+p.b)/2;z(r,p)||(m=r,r=p,p=m);z(q,y)||
	(m=q,q=y,y=m);z(r,q)||(m=r,r=q,q=m,m=p,p=y,y=m);z(q,p)?z(p,y)?(m=aa(r,q,p),w=aa(q,p,y),0>m+w&&(m=-m,w=-w),l.a=A(m,q.a,w,p.a)):(m=ba(r,q,p),w=-ba(r,y,p),0>m+w&&(m=-m,w=-w),l.a=A(m,q.a,w,y.a)):l.a=(q.a+p.a)/2;u(l,a.a)&&(l.b=a.a.b,l.a=a.a.a);r=u(f,g)?f:g;u(r,l)&&(l.b=r.b,l.a=r.a);if(t(l,f)||t(l,g))return qa(a,b),!1;if(!t(h,a.a)&&0<=x(h,a.a,l)||!t(k,a.a)&&0>=x(k,a.a,l)){if(k===a.a)return K(d.b),E(e.b,d),b=ka(b),d=S(b).a,T(a,S(b),c),U(a,b,J(d),d,d,!0),!0;if(h===a.a){K(e.b);E(d.e,J(e));f=c=b;g=f.a.b.a;
	do f=R(f);while(f.a.b.a===g);b=f;f=S(b).a.b.c;c.a=J(e);e=T(a,c,null);U(a,b,e.c,d.b.c,f,!0);return!0}0<=x(h,a.a,l)&&(R(b).b=b.b=!0,K(d.b),d.a.b=a.a.b,d.a.a=a.a.a);0>=x(k,a.a,l)&&(b.b=c.b=!0,K(e.b),e.a.b=a.a.b,e.a.a=a.a.a);return!1}K(d.b);K(e.b);E(J(e),d);d.a.b=l.b;d.a.a=l.a;d.a.h=xa(a.e,d.a);d=d.a;e=[0,0,0,0];l=[f.d,h.d,g.d,k.d];d.g[0]=d.g[1]=d.g[2]=0;ua(d,f,h,e,0);ua(d,g,k,e,2);sa(a,d,l,e,!0);R(b).b=b.b=c.b=!0;return!1}
	function ra(a,b){for(var c=S(b);;){for(;c.b;)b=c,c=S(c);if(!b.b&&(c=b,b=R(b),null===b||!b.b))break;b.b=!1;var d=b.a,e=c.a,f;if(f=d.b.a!==e.b.a)a:{f=b;var g=S(f),h=f.a,k=g.a,l=void 0;if(u(h.b.a,k.b.a)){if(0>x(h.b.a,k.b.a,h.a)){f=!1;break a}R(f).b=f.b=!0;l=K(h);E(k.b,l);l.d.c=f.d}else{if(0<x(k.b.a,h.b.a,k.a)){f=!1;break a}f.b=g.b=!0;l=K(k);E(h.e,k.b);l.b.d.c=f.d}f=!0}f&&(c.c?(Q(c),I(e),c=S(b),e=c.a):b.c&&(Q(b),I(d),b=R(c),d=b.a));if(d.a!==e.a)if(d.b.a===e.b.a||b.c||c.c||d.b.a!==a.a&&e.b.a!==a.a)qa(a,
	b);else if(wa(a,b))break;d.a===e.a&&d.b.a===e.b.a&&(P(e,d),Q(b),I(d),b=R(c))}}
	function ya(a,b){a.a=b;for(var c=b.c;null===c.i;)if(c=c.c,c===b.c){var c=a,d=b,e=new ma;e.a=d.c.b;var f=c.f,g=f.a;do g=g.a;while(null!==g.b&&!f.c(f.b,e,g.b));var f=g.b,h=S(f),e=f.a,g=h.a;if(0===x(e.b.a,d,e.a))e=f.a,t(e.a,d)||t(e.b.a,d)||(K(e.b),f.c&&(I(e.c),f.c=!1),E(d.c,e),ya(c,d));else{var k=u(g.b.a,e.b.a)?f:h,h=void 0;f.d||k.c?(k===f?h=L(d.c.b,e.e):h=L(g.b.c.b,d.c).b,k.c?ja(k,h):(e=c,f=la(c,f,h),f.f=R(f).f+f.a.f,f.d=oa(e,f.f)),ya(c,d)):U(c,f,d.c,d.c,null,!0)}return}c=ka(c.i);e=S(c);f=e.a;e=T(a,
	e,null);if(e.c===f){var f=e,e=f.c,g=S(c),h=c.a,k=g.a,l=!1;h.b.a!==k.b.a&&wa(a,c);t(h.a,a.a)&&(E(J(e),h),c=ka(c),e=S(c).a,T(a,S(c),g),l=!0);t(k.a,a.a)&&(E(f,J(k)),f=T(a,g,null),l=!0);l?U(a,c,f.c,e,e,!0):(u(k.a,h.a)?d=J(k):d=h,d=L(f.c.b,d),U(a,c,d,d.c,d.c,!1),d.b.i.c=!0,ra(a,c))}else U(a,c,e.c,f,f,!0)}function za(a,b){var c=new ma,d=ea(a.b);d.a.b=O;d.a.a=b;d.b.a.b=-O;d.b.a.a=b;a.a=d.b.a;c.a=d;c.f=0;c.d=!1;c.c=!1;c.h=!0;c.b=!1;d=a.f;d=na(d,d.a,c);c.e=d};function Aa(a){this.a=new Ba;this.b=a;this.c=ia}function na(a,b,c){do b=b.c;while(null!==b.b&&!a.c(a.b,b.b,c));a=new Ba(c,b.a,b);b.a.c=a;return b.a=a};function Ba(a,b,c){this.b=a||null;this.a=b||this;this.c=c||this};function X(){this.d=Y;this.p=this.b=this.q=null;this.j=[0,0,0];this.s=100130;this.n=!1;this.o=this.a=this.e=this.f=null;this.m=!1;this.c=this.r=this.i=this.k=this.l=this.h=null}var Y=0;n=X.prototype;n.x=function(){Z(this,Y)};n.B=function(a,b){switch(a){case 100142:return;case 100140:switch(b){case 100130:case 100131:case 100132:case 100133:case 100134:this.s=b;return}break;case 100141:this.m=!!b;return;default:V(this,100900);return}V(this,100901)};
	n.y=function(a){switch(a){case 100142:return 0;case 100140:return this.s;case 100141:return this.m;default:V(this,100900)}return!1};n.A=function(a,b,c){this.j[0]=a;this.j[1]=b;this.j[2]=c};
	n.z=function(a,b){var c=b?b:null;switch(a){case 100100:case 100106:this.h=c;break;case 100104:case 100110:this.l=c;break;case 100101:case 100107:this.k=c;break;case 100102:case 100108:this.i=c;break;case 100103:case 100109:this.p=c;break;case 100105:case 100111:this.o=c;break;case 100112:this.r=c;break;default:V(this,100900)}};
	n.C=function(a,b){var c=!1,d=[0,0,0];Z(this,2);for(var e=0;3>e;++e){var f=a[e];-1E150>f&&(f=-1E150,c=!0);1E150<f&&(f=1E150,c=!0);d[e]=f}c&&V(this,100155);c=this.q;null===c?(c=ea(this.b),E(c,c.b)):(K(c),c=c.e);c.a.d=b;c.a.g[0]=d[0];c.a.g[1]=d[1];c.a.g[2]=d[2];c.f=1;c.b.f=-1;this.q=c};n.u=function(a){Z(this,Y);this.d=1;this.b=new Ca;this.c=a};n.t=function(){Z(this,1);this.d=2;this.q=null};n.v=function(){Z(this,2);this.d=1};
	n.w=function(){Z(this,1);this.d=Y;var a=this.j[0],b=this.j[1],c=this.j[2],d=!1,e=[a,b,c];if(0===a&&0===b&&0===c){for(var b=[-2*1E150,-2*1E150,-2*1E150],f=[2*1E150,2*1E150,2*1E150],c=[],g=[],d=this.b.c,a=d.e;a!==d;a=a.e)for(var h=0;3>h;++h){var k=a.g[h];k<f[h]&&(f[h]=k,g[h]=a);k>b[h]&&(b[h]=k,c[h]=a)}a=0;b[1]-f[1]>b[0]-f[0]&&(a=1);b[2]-f[2]>b[a]-f[a]&&(a=2);if(f[a]>=b[a])e[0]=0,e[1]=0,e[2]=1;else{b=0;f=g[a];c=c[a];g=[0,0,0];f=[f.g[0]-c.g[0],f.g[1]-c.g[1],f.g[2]-c.g[2]];h=[0,0,0];for(a=d.e;a!==d;a=
	a.e)h[0]=a.g[0]-c.g[0],h[1]=a.g[1]-c.g[1],h[2]=a.g[2]-c.g[2],g[0]=f[1]*h[2]-f[2]*h[1],g[1]=f[2]*h[0]-f[0]*h[2],g[2]=f[0]*h[1]-f[1]*h[0],k=g[0]*g[0]+g[1]*g[1]+g[2]*g[2],k>b&&(b=k,e[0]=g[0],e[1]=g[1],e[2]=g[2]);0>=b&&(e[0]=e[1]=e[2]=0,e[ha(f)]=1)}d=!0}g=ha(e);a=this.b.c;b=(g+1)%3;c=(g+2)%3;g=0<e[g]?1:-1;for(e=a.e;e!==a;e=e.e)e.b=e.g[b],e.a=g*e.g[c];if(d){e=0;d=this.b.a;for(a=d.b;a!==d;a=a.b)if(b=a.a,!(0>=b.f)){do e+=(b.a.b-b.b.a.b)*(b.a.a+b.b.a.a),b=b.e;while(b!==a.a)}if(0>e)for(e=this.b.c,d=e.e;d!==
	e;d=d.e)d.a=-d.a}this.n=!1;e=this.b.b;for(a=e.h;a!==e;a=d)if(d=a.h,b=a.e,t(a.a,a.b.a)&&a.e.e!==a&&(ta(this,b,a),I(a),a=b,b=a.e),b.e===a){if(b!==a){if(b===d||b===d.b)d=d.h;I(b)}if(a===d||a===d.b)d=d.h;I(a)}this.e=e=new Da;d=this.b.c;for(a=d.e;a!==d;a=a.e)a.h=xa(e,a);Ea(e);this.f=new Aa(this);za(this,-O);for(za(this,O);null!==(e=Fa(this.e));){for(;;){a:if(a=this.e,0===a.a)d=Ga(a.b);else if(d=a.c[a.d[a.a-1]],0!==a.b.a&&(a=Ga(a.b),u(a,d))){d=a;break a}if(null===d||!t(d,e))break;d=Fa(this.e);ta(this,e.c,
	d.c)}ya(this,e)}this.a=this.f.a.a.b.a.a;for(e=0;null!==(d=this.f.a.a.b);)d.h||++e,Q(d);this.f=null;e=this.e;e.b=null;e.d=null;this.e=e.c=null;e=this.b;for(a=e.a.b;a!==e.a;a=d)d=a.b,a=a.a,a.e.e===a&&(P(a.c,a),I(a));if(!this.n){e=this.b;if(this.m)for(a=e.b.h;a!==e.b;a=d)d=a.h,a.b.d.c!==a.d.c?a.f=a.d.c?1:-1:I(a);else for(a=e.a.b;a!==e.a;a=d)if(d=a.b,a.c){for(a=a.a;u(a.b.a,a.a);a=a.c.b);for(;u(a.a,a.b.a);a=a.e);b=a.c.b;for(c=void 0;a.e!==b;)if(u(a.b.a,b.a)){for(;b.e!==a&&(ca(b.e)||0>=x(b.a,b.b.a,b.e.b.a));)c=
	L(b.e,b),b=c.b;b=b.c.b}else{for(;b.e!==a&&(da(a.c.b)||0<=x(a.b.a,a.a,a.c.b.a));)c=L(a,a.c.b),a=c.b;a=a.e}for(;b.e.e!==a;)c=L(b.e,b),b=c.b}if(this.h||this.i||this.k||this.l)if(this.m)for(e=this.b,d=e.a.b;d!==e.a;d=d.b){if(d.c){this.h&&this.h(2,this.c);a=d.a;do this.k&&this.k(a.a.d,this.c),a=a.e;while(a!==d.a);this.i&&this.i(this.c)}}else{e=this.b;d=!!this.l;a=!1;b=-1;for(c=e.a.d;c!==e.a;c=c.d)if(c.c){a||(this.h&&this.h(4,this.c),a=!0);g=c.a;do d&&(f=g.b.d.c?0:1,b!==f&&(b=f,this.l&&this.l(!!b,this.c))),
	this.k&&this.k(g.a.d,this.c),g=g.e;while(g!==c.a)}a&&this.i&&this.i(this.c)}if(this.r){e=this.b;for(a=e.a.b;a!==e.a;a=d)if(d=a.b,!a.c){b=a.a;c=b.e;g=void 0;do g=c,c=g.e,g.d=null,null===g.b.d&&(g.c===g?F(g.a,null):(g.a.c=g.c,H(g,J(g))),f=g.b,f.c===f?F(f.a,null):(f.a.c=f.c,H(f,J(f))),fa(g));while(g!==b);b=a.d;a=a.b;a.d=b;b.b=a}this.r(this.b);this.c=this.b=null;return}}this.b=this.c=null};
	function Z(a,b){if(a.d!==b)for(;a.d!==b;)if(a.d<b)switch(a.d){case Y:V(a,100151);a.u(null);break;case 1:V(a,100152),a.t()}else switch(a.d){case 2:V(a,100154);a.v();break;case 1:V(a,100153),a.w()}}function V(a,b){a.p&&a.p(b,a.c)};function ga(a,b){this.b=a||this;this.d=b||this;this.a=null;this.c=!1};function M(){this.h=this;this.i=this.d=this.a=this.e=this.c=this.b=null;this.f=0}function J(a){return a.b.e};function Ca(){this.c=new N;this.a=new ga;this.b=new M;this.d=new M;this.b.b=this.d;this.d.b=this.b};function N(a,b){this.e=a||this;this.f=b||this;this.d=this.c=null;this.g=[0,0,0];this.h=this.a=this.b=0};function Da(){this.c=[];this.d=null;this.a=0;this.e=!1;this.b=new Ha}function Ea(a){a.d=[];for(var b=0;b<a.a;b++)a.d[b]=b;a.d.sort(function(a){return function(b,e){return u(a[b],a[e])?1:-1}}(a.c));a.e=!0;Ia(a.b)}function xa(a,b){if(a.e){var c=a.b,d=++c.a;2*d>c.f&&(c.f*=2,c.c=Ja(c.c,c.f+1));var e;0===c.b?e=d:(e=c.b,c.b=c.c[c.b]);c.e[e]=b;c.c[e]=d;c.d[d]=e;c.h&&va(c,d);return e}c=a.a++;a.c[c]=b;return-(c+1)}
	function Fa(a){if(0===a.a)return Ka(a.b);var b=a.c[a.d[a.a-1]];if(0!==a.b.a&&u(Ga(a.b),b))return Ka(a.b);do--a.a;while(0<a.a&&null===a.c[a.d[a.a-1]]);return b};function Ha(){this.d=Ja([0],33);this.e=[null,null];this.c=[0,0];this.a=0;this.f=32;this.b=0;this.h=!1;this.d[1]=1}function Ja(a,b){for(var c=Array(b),d=0;d<a.length;d++)c[d]=a[d];for(;d<b;d++)c[d]=0;return c}function Ia(a){for(var b=a.a;1<=b;--b)W(a,b);a.h=!0}function Ga(a){return a.e[a.d[1]]}function Ka(a){var b=a.d,c=a.e,d=a.c,e=b[1],f=c[e];0<a.a&&(b[1]=b[a.a],d[b[1]]=1,c[e]=null,d[e]=a.b,a.b=e,0<--a.a&&W(a,1));return f}
	function W(a,b){for(var c=a.d,d=a.e,e=a.c,f=b,g=c[f];;){var h=f<<1;h<a.a&&u(d[c[h+1]],d[c[h]])&&(h+=1);var k=c[h];if(h>a.a||u(d[g],d[k])){c[f]=g;e[g]=f;break}c[f]=k;e[k]=f;f=h}}function va(a,b){for(var c=a.d,d=a.e,e=a.c,f=b,g=c[f];;){var h=f>>1,k=c[h];if(0===h||u(d[k],d[g])){c[f]=g;e[g]=f;break}c[f]=k;e[k]=f;f=h}};function ma(){this.e=this.a=null;this.f=0;this.c=this.b=this.h=this.d=!1}function S(a){return a.e.c.b}function R(a){return a.e.a.b};this.libtess={GluTesselator:X,windingRule:{GLU_TESS_WINDING_ODD:100130,GLU_TESS_WINDING_NONZERO:100131,GLU_TESS_WINDING_POSITIVE:100132,GLU_TESS_WINDING_NEGATIVE:100133,GLU_TESS_WINDING_ABS_GEQ_TWO:100134},primitiveType:{GL_LINE_LOOP:2,GL_TRIANGLES:4,GL_TRIANGLE_STRIP:5,GL_TRIANGLE_FAN:6},errorType:{GLU_TESS_MISSING_BEGIN_POLYGON:100151,GLU_TESS_MISSING_END_POLYGON:100153,GLU_TESS_MISSING_BEGIN_CONTOUR:100152,GLU_TESS_MISSING_END_CONTOUR:100154,GLU_TESS_COORD_TOO_LARGE:100155,GLU_TESS_NEED_COMBINE_CALLBACK:100156},
	gluEnum:{GLU_TESS_MESH:100112,GLU_TESS_TOLERANCE:100142,GLU_TESS_WINDING_RULE:100140,GLU_TESS_BOUNDARY_ONLY:100141,GLU_INVALID_ENUM:100900,GLU_INVALID_VALUE:100901,GLU_TESS_BEGIN:100100,GLU_TESS_VERTEX:100101,GLU_TESS_END:100102,GLU_TESS_ERROR:100103,GLU_TESS_EDGE_FLAG:100104,GLU_TESS_COMBINE:100105,GLU_TESS_BEGIN_DATA:100106,GLU_TESS_VERTEX_DATA:100107,GLU_TESS_END_DATA:100108,GLU_TESS_ERROR_DATA:100109,GLU_TESS_EDGE_FLAG_DATA:100110,GLU_TESS_COMBINE_DATA:100111}};X.prototype.gluDeleteTess=X.prototype.x;
	X.prototype.gluTessProperty=X.prototype.B;X.prototype.gluGetTessProperty=X.prototype.y;X.prototype.gluTessNormal=X.prototype.A;X.prototype.gluTessCallback=X.prototype.z;X.prototype.gluTessVertex=X.prototype.C;X.prototype.gluTessBeginPolygon=X.prototype.u;X.prototype.gluTessBeginContour=X.prototype.t;X.prototype.gluTessEndContour=X.prototype.v;X.prototype.gluTessEndPolygon=X.prototype.w; if (true) { module.exports = this.libtess; }


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Point = undefined;
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Point = exports.Point = _vector2.default;

/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Vertex = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _topoObject = __webpack_require__(324);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Vertex = exports.Vertex = function (_TopoObject) {
	  _inherits(Vertex, _TopoObject);
	
	  function Vertex(point) {
	    _classCallCheck(this, Vertex);
	
	    var _this = _possibleConstructorReturn(this, (Vertex.__proto__ || Object.getPrototypeOf(Vertex)).call(this));
	
	    _this.point = point;
	    _this.edges = new Set();
	    return _this;
	  }
	
	  _createClass(Vertex, [{
	    key: 'edgeFor',
	    value: function edgeFor(other) {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = this.edges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var e = _step.value;
	
	          if (e.vertexB == other) {
	            return e;
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      return null;
	    }
	  }]);

	  return Vertex;
	}(_topoObject.TopoObject);

/***/ },
/* 324 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var TopoObject = exports.TopoObject = function () {
	  function TopoObject() {
	    _classCallCheck(this, TopoObject);
	
	    this.data = {};
	    Object.defineProperty(this, "refId", {
	      value: REF_COUNTER++,
	      writable: false
	    });
	  }
	
	  _createClass(TopoObject, [{
	    key: "defineIterable",
	    value: function defineIterable(name, iteratorFactory) {
	      this[name] = {};
	      this[name][Symbol.iterator] = iteratorFactory;
	    }
	  }]);
	
	  return TopoObject;
	}();
	
	var REF_COUNTER = 0;

/***/ },
/* 325 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = window.devicePixelRatio ? window.devicePixelRatio : 1;

/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.WIREFRAME_MATERIAL = exports.SKETCH_CONSTRUCTION_MATERIAL = exports.SKETCH_MATERIAL = exports.SceneFace = exports.SceneSolid = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	exports.createSolidMaterial = createSolidMaterial;
	
	var _hashmap = __webpack_require__(306);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _counters = __webpack_require__(309);
	
	var _counters2 = _interopRequireDefault(_counters);
	
	var _l3space = __webpack_require__(308);
	
	var _cadUtils = __webpack_require__(302);
	
	var _dpr = __webpack_require__(325);
	
	var _dpr2 = _interopRequireDefault(_dpr);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SceneSolid = exports.SceneSolid = function () {
	  function SceneSolid(type, id, skin) {
	    _classCallCheck(this, SceneSolid);
	
	    this.tCadType = type || 'SOLID';
	
	    this.cadGroup = new THREE.Object3D();
	    this.cadGroup.__tcad_solid = this;
	
	    this.tCadId = _counters2.default.solid++;
	    this.id = id === undefined ? this.tCadId : id; // to keep identity through the history
	    this.faceCounter = 0;
	
	    this.wireframeGroup = new THREE.Object3D();
	    this.cadGroup.add(this.wireframeGroup);
	    this.mergeable = true;
	    this.sceneFaces = [];
	
	    this.material = createSolidMaterial(skin);
	  }
	
	  _createClass(SceneSolid, [{
	    key: 'addLineToScene',
	    value: function addLineToScene(a, b) {
	      var lg = new THREE.Geometry();
	      lg.vertices.push(a);
	      lg.vertices.push(b);
	      var line = new THREE.Line(lg, WIREFRAME_MATERIAL);
	      this.wireframeGroup.add(line);
	      return line;
	    }
	  }, {
	    key: 'createGeometry',
	    value: function createGeometry() {
	      throw 'not implemented';
	    }
	  }, {
	    key: 'dropGeometry',
	    value: function dropGeometry() {
	      throw 'not implemented';
	    }
	  }, {
	    key: 'vanish',
	    value: function vanish() {
	      this.cadGroup.parent.remove(this.cadGroup);
	      this.material.dispose();
	      this.mesh.geometry.dispose();
	    }
	  }]);
	
	  return SceneSolid;
	}();
	
	function createSolidMaterial(skin) {
	  return new THREE.MeshPhongMaterial(Object.assign({
	    vertexColors: THREE.FaceColors,
	    color: 0xB0C4DE,
	    shininess: 0,
	    polygonOffset: true,
	    polygonOffsetFactor: 1,
	    polygonOffsetUnits: 2
	  }, skin));
	}
	
	var OFF_LINES_VECTOR = new _vector2.default(); //normal.multiply(0); // disable it. use polygon offset feature of material
	
	var SceneFace = exports.SceneFace = function () {
	  function SceneFace(solid, propagatedId) {
	    _classCallCheck(this, SceneFace);
	
	    if (propagatedId === undefined) {
	      this.id = solid.tCadId + ":" + solid.faceCounter++;
	    } else {
	      this.id = propagatedId;
	    }
	
	    this.solid = solid;
	    this.meshFaces = [];
	    this.sketch3DGroup = null;
	  }
	
	  _createClass(SceneFace, [{
	    key: 'normal',
	    value: function normal() {
	      throw 'not implemented';
	    }
	  }, {
	    key: 'depth',
	    value: function depth() {
	      throw 'not implemented';
	    }
	  }, {
	    key: 'getBounds',
	    value: function getBounds() {
	      throw 'not implemented';
	    }
	  }, {
	    key: 'surface',
	    value: function surface() {
	      throw 'not implemented';
	    }
	  }, {
	    key: 'calcBasis',
	    value: function calcBasis() {
	      return (0, _l3space.BasisForPlane)(this.normal());
	    }
	  }, {
	    key: 'basis',
	    value: function basis() {
	      if (!this._basis) {
	        this._basis = this.calcBasis();
	      }
	      return this._basis;
	    }
	  }, {
	    key: 'createMeshFace',
	    value: function createMeshFace(a, b, c) {
	      var face = new THREE.Face3(a, b, c);
	      this.registerMeshFace(face);
	      return face;
	    }
	  }, {
	    key: 'registerMeshFace',
	    value: function registerMeshFace(threeFace) {
	      this.meshFaces.push(threeFace);
	      threeFace.__TCAD_SceneFace = this;
	    }
	  }, {
	    key: 'syncSketches',
	    value: function syncSketches(geom) {
	      var _this = this;
	
	      if (this.sketch3DGroup != null) {
	        for (var i = this.sketch3DGroup.children.length - 1; i >= 0; --i) {
	          this.sketch3DGroup.remove(this.sketch3DGroup.children[i]);
	        }
	      } else {
	        this.sketch3DGroup = new THREE.Object3D();
	        this.solid.cadGroup.add(this.sketch3DGroup);
	      }
	
	      var basis = this.basis();
	      var _3dTransformation = new _l3space.Matrix3().setBasis(basis);
	      //we lost depth or z off in 2d sketch, calculate it again
	      var depth = this.depth();
	      var addSketchObjects = function addSketchObjects(sketchObjects, material, close) {
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	          var _loop = function _loop() {
	            var sketchObject = _step.value;
	
	            var line = new THREE.Line(undefined, material);
	            line.__TCAD_SketchObject = sketchObject;
	            var chunks = sketchObject.approximate(10);
	            function addLine(p, q) {
	              var lg = line.geometry;
	              chunks[p].z = chunks[q].z = depth;
	              var a = _3dTransformation.apply(chunks[p]);
	              var b = _3dTransformation.apply(chunks[q]);
	
	              lg.vertices.push(a._plus(OFF_LINES_VECTOR).three());
	              lg.vertices.push(b._plus(OFF_LINES_VECTOR).three());
	            }
	            for (var q = 1; q < chunks.length; q++) {
	              addLine(q - 1, q);
	            }
	            _this.sketch3DGroup.add(line);
	          };
	
	          for (var _iterator = sketchObjects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            _loop();
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	      };
	      addSketchObjects(geom.constructionSegments, SKETCH_CONSTRUCTION_MATERIAL);
	      addSketchObjects(geom.connections, SKETCH_MATERIAL);
	      addSketchObjects(geom.loops, SKETCH_MATERIAL);
	    }
	  }, {
	    key: 'findById',
	    value: function findById(sketchObjectId) {
	      return this.sketch3DGroup.children.find(function (o) {
	        return o.__TCAD_SketchObject && o.__TCAD_SketchObject.id == sketchObjectId;
	      });
	    }
	  }, {
	    key: 'getSketchObjectVerticesIn3D',
	    value: function getSketchObjectVerticesIn3D(sketchObjectId) {
	      var object = this.findById(sketchObjectId);
	      if (!object) {
	        return undefined;
	      }
	      return object.geometry.vertices;
	    }
	  }]);
	
	  return SceneFace;
	}();
	
	var SKETCH_MATERIAL = exports.SKETCH_MATERIAL = new THREE.LineBasicMaterial({ color: 0xFFFFFF, linewidth: 3 / _dpr2.default });
	var SKETCH_CONSTRUCTION_MATERIAL = exports.SKETCH_CONSTRUCTION_MATERIAL = new THREE.LineBasicMaterial({ color: 0x777777, linewidth: 2 / _dpr2.default });
	var WIREFRAME_MATERIAL = exports.WIREFRAME_MATERIAL = new THREE.LineBasicMaterial({ color: 0x2B3856, linewidth: 3 / _dpr2.default });

/***/ },
/* 327 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.type = type;
	exports.is = is;
	function type(n) {
	  return 1 << n - 1;
	}
	
	function is(mask, value) {
	  return (mask & value) === value;
	}

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SelectionManager = exports.EdgeSelectionManager = exports.SketchSelectionManager = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _dpr = __webpack_require__(325);
	
	var _dpr2 = _interopRequireDefault(_dpr);
	
	var _stitching = __webpack_require__(329);
	
	var stitching = _interopRequireWildcard(_stitching);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var AbstractSelectionManager = function () {
	  function AbstractSelectionManager(viewer) {
	    var _this = this;
	
	    _classCallCheck(this, AbstractSelectionManager);
	
	    this.viewer = viewer;
	    this.selection = [];
	    this.viewer.bus.subscribe('craft', function () {
	      return _this.deselectAll();
	    });
	  }
	
	  _createClass(AbstractSelectionManager, [{
	    key: 'contains',
	    value: function contains(face) {
	      return this.selection.indexOf(face) != -1;
	    }
	  }, {
	    key: 'pick',
	    value: function pick(object) {
	      if (!this.contains(object)) {
	        this.select(object);
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: 'select',
	    value: function select() {
	      throw "AbstractFunctionCall";
	    }
	  }, {
	    key: 'deselectAll',
	    value: function deselectAll() {
	      throw "AbstractFunctionCall";
	    }
	  }]);
	
	  return AbstractSelectionManager;
	}();
	
	var SketchSelectionManager = exports.SketchSelectionManager = function (_AbstractSelectionMan) {
	  _inherits(SketchSelectionManager, _AbstractSelectionMan);
	
	  function SketchSelectionManager(viewer, selectionMaterial) {
	    _classCallCheck(this, SketchSelectionManager);
	
	    var _this2 = _possibleConstructorReturn(this, (SketchSelectionManager.__proto__ || Object.getPrototypeOf(SketchSelectionManager)).call(this, viewer));
	
	    _this2.selectionMaterial = selectionMaterial;
	    _this2.defaultMaterials = [];
	    return _this2;
	  }
	
	  _createClass(SketchSelectionManager, [{
	    key: 'select',
	    value: function select(line) {
	      this._clearSilent();
	      this.defaultMaterials.push(line.material);
	      this.selection.push(line);
	      line.material = this.selectionMaterial;
	      this.notify();
	      this.viewer.render();
	    }
	  }, {
	    key: 'deselectAll',
	    value: function deselectAll() {
	      this.clear();
	    }
	  }, {
	    key: 'clear',
	    value: function clear() {
	      this._clearSilent();
	      this.notify();
	      this.viewer.render();
	    }
	  }, {
	    key: '_clearSilent',
	    value: function _clearSilent() {
	      for (var i = 0; i < this.selection.length; i++) {
	        this.selection[i].material = this.defaultMaterials[i];
	      }
	      this.defaultMaterials.length = 0;
	      this.selection.length = 0;
	    }
	  }, {
	    key: 'notify',
	    value: function notify() {
	      this.viewer.bus.notify('selection-sketch-object');
	    }
	  }]);
	
	  return SketchSelectionManager;
	}(AbstractSelectionManager);
	
	var EdgeSelectionManager = exports.EdgeSelectionManager = function (_AbstractSelectionMan2) {
	  _inherits(EdgeSelectionManager, _AbstractSelectionMan2);
	
	  function EdgeSelectionManager(viewer, selectionMaterial) {
	    _classCallCheck(this, EdgeSelectionManager);
	
	    var _this3 = _possibleConstructorReturn(this, (EdgeSelectionManager.__proto__ || Object.getPrototypeOf(EdgeSelectionManager)).call(this, viewer));
	
	    _this3.selectionMaterial = selectionMaterial;
	    _this3.defaultMaterials = [];
	    return _this3;
	  }
	
	  _createClass(EdgeSelectionManager, [{
	    key: 'select',
	    value: function select(line) {
	      this._clearSilent();
	      var edge = line.__TCAD_EDGE;
	      var stitchedCurve = edge.data[stitching.EDGE_CHUNK];
	      if (stitchedCurve) {
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	          for (var _iterator = stitchedCurve.edges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var edgeChunk = _step.value;
	
	            this.mark(edgeChunk.data['scene.edge']);
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	      } else {
	        this.mark(line);
	      }
	      this.notify();
	      this.viewer.render();
	    }
	  }, {
	    key: 'mark',
	    value: function mark(line) {
	      this.defaultMaterials.push(line.material);
	      this.selection.push(line);
	      line.material = this.selectionMaterial;
	    }
	  }, {
	    key: 'deselectAll',
	    value: function deselectAll() {
	      this.clear();
	    }
	  }, {
	    key: 'clear',
	    value: function clear() {
	      this._clearSilent();
	      this.notify();
	      this.viewer.render();
	    }
	  }, {
	    key: '_clearSilent',
	    value: function _clearSilent() {
	      for (var i = 0; i < this.selection.length; i++) {
	        this.selection[i].material = this.defaultMaterials[i];
	      }
	      this.defaultMaterials.length = 0;
	      this.selection.length = 0;
	    }
	  }, {
	    key: 'notify',
	    value: function notify() {
	      //this.viewer.bus.notify('selection-edge');
	    }
	  }]);
	
	  return EdgeSelectionManager;
	}(AbstractSelectionManager);
	
	var SelectionManager = exports.SelectionManager = function (_AbstractSelectionMan3) {
	  _inherits(SelectionManager, _AbstractSelectionMan3);
	
	  function SelectionManager(viewer, selectionColor, readOnlyColor, defaultColor) {
	    _classCallCheck(this, SelectionManager);
	
	    var _this4 = _possibleConstructorReturn(this, (SelectionManager.__proto__ || Object.getPrototypeOf(SelectionManager)).call(this, viewer));
	
	    _this4.selectionColor = selectionColor;
	    _this4.defaultColor = defaultColor;
	    _this4.readOnlyColor = readOnlyColor;
	    _this4.planeSelection = [];
	    return _this4;
	  }
	
	  _createClass(SelectionManager, [{
	    key: 'select',
	    value: function select(sceneFace) {
	      this.clear();
	      var group = this.findGroup(sceneFace);
	      if (group) {
	        for (var i = 0; i < group.length; i++) {
	          var face = group[i];
	          this.selection.push(face);
	          setFacesColor(face.meshFaces, this.readOnlyColor);
	        }
	      } else {
	        this.selection.push(sceneFace);
	        this.viewer.updateBasis(sceneFace.basis(), sceneFace.depth());
	        this.viewer.showBasis();
	        setFacesColor(sceneFace.meshFaces, this.selectionColor);
	      }
	      sceneFace.solid.mesh.geometry.colorsNeedUpdate = true;
	      this.viewer.bus.notify('selection', sceneFace);
	      this.viewer.render();
	    }
	  }, {
	    key: 'findGroup',
	    value: function findGroup(sceneFace) {
	      if (sceneFace.curvedSurfaces) {
	        return sceneFace.curvedSurfaces;
	      }
	      if (sceneFace.brepFace) {
	        var stitchedFace = sceneFace.brepFace.data[stitching.FACE_CHUNK];
	        if (stitchedFace) {
	          return stitchedFace.faces.map(function (f) {
	            return f.data['scene.face'];
	          });
	        }
	      }
	      return undefined;
	    }
	  }, {
	    key: 'deselectAll',
	    value: function deselectAll() {
	      this.clear();
	      this.viewer.bus.notify('selection', null);
	      this.viewer.render();
	    }
	  }, {
	    key: 'clear',
	    value: function clear() {
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        for (var _iterator2 = this.selection[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var selectee = _step2.value;
	
	          setFacesColor(selectee.meshFaces, this.defaultColor);
	          selectee.solid.mesh.geometry.colorsNeedUpdate = true;
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	
	      this.viewer.hideBasis();
	      this.selection.length = 0;
	    }
	  }]);
	
	  return SelectionManager;
	}(AbstractSelectionManager);
	
	function setFacesColor(faces, color) {
	  var _iteratorNormalCompletion3 = true;
	  var _didIteratorError3 = false;
	  var _iteratorError3 = undefined;
	
	  try {
	    for (var _iterator3 = faces[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	      var face = _step3.value;
	
	      if (color == null) {
	        face.color.set(new THREE.Color());
	      } else {
	        face.color.set(color);
	      }
	    }
	  } catch (err) {
	    _didIteratorError3 = true;
	    _iteratorError3 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion3 && _iterator3.return) {
	        _iterator3.return();
	      }
	    } finally {
	      if (_didIteratorError3) {
	        throw _iteratorError3;
	      }
	    }
	  }
	}

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.StitchedCurve = exports.StitchedSurface = exports.EDGE_AUX = exports.EDGE_CHUNK = exports.FACE_CHUNK = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	exports.update = update;
	exports.getCurve = getCurve;
	
	var _utils = __webpack_require__(330);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var FACE_CHUNK = exports.FACE_CHUNK = 'stitching.face.chunk';
	var EDGE_CHUNK = exports.EDGE_CHUNK = 'stitching.edge.chunk';
	var EDGE_AUX = exports.EDGE_AUX = 'stitching.edge.aux';
	
	var StitchedSurface = exports.StitchedSurface = function () {
	  function StitchedSurface() {
	    _classCallCheck(this, StitchedSurface);
	
	    this.faces = [];
	    this.origin = null;
	  }
	
	  _createClass(StitchedSurface, [{
	    key: 'addFace',
	    value: function addFace(face) {
	      face.data[FACE_CHUNK] = this;
	      this.faces.push(face);
	    }
	  }, {
	    key: 'clear',
	    value: function clear() {
	      this.faces = [];
	    }
	  }]);
	
	  return StitchedSurface;
	}();
	
	var StitchedCurve = exports.StitchedCurve = function () {
	  function StitchedCurve(surface1, surface2) {
	    _classCallCheck(this, StitchedCurve);
	
	    this.surface1 = surface1;
	    this.surface2 = surface2;
	    this.edges = [];
	  }
	
	  _createClass(StitchedCurve, [{
	    key: 'addEdge',
	    value: function addEdge(edge) {
	      this.edges.push(edge);
	      edge.data[EDGE_CHUNK] = this;
	    }
	  }, {
	    key: 'equals',
	    value: function equals(other) {
	      return other instanceof StitchedCurve && (this.surface1 == other.surface1 && this.surface2 == other.surface2 || this.surface1 == other.surface2 && this.surface2 == other.surface1);
	    }
	  }]);
	
	  return StitchedCurve;
	}();
	
	function update(shell) {
	  var index = new _utils.DoubleKeyMap();
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = shell.faces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var face = _step.value;
	
	      var stitchedSurface = face.data[FACE_CHUNK];
	      if (stitchedSurface) {
	        stitchedSurface.clear();
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  var _iteratorNormalCompletion2 = true;
	  var _didIteratorError2 = false;
	  var _iteratorError2 = undefined;
	
	  try {
	    for (var _iterator2 = shell.faces[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	      var _face = _step2.value;
	
	      var _stitchedSurface = _face.data[FACE_CHUNK];
	      if (_stitchedSurface) {
	        _stitchedSurface.addFace(_face);
	      }
	    }
	  } catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion2 && _iterator2.return) {
	        _iterator2.return();
	      }
	    } finally {
	      if (_didIteratorError2) {
	        throw _iteratorError2;
	      }
	    }
	  }
	
	  var _iteratorNormalCompletion3 = true;
	  var _didIteratorError3 = false;
	  var _iteratorError3 = undefined;
	
	  try {
	    for (var _iterator3 = shell.edges[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	      var e = _step3.value;
	
	      var face1 = e.halfEdge1.loop.face;
	      var face2 = e.halfEdge2.loop.face;
	      var stitchedSurface1 = face1.data[FACE_CHUNK];
	      var stitchedSurface2 = face2.data[FACE_CHUNK];
	      if (stitchedSurface1 !== undefined && stitchedSurface1 === stitchedSurface2) {
	        e.data[EDGE_AUX] = stitchedSurface1;
	      } else if (stitchedSurface1 !== undefined || stitchedSurface2 !== undefined) {
	        var o1 = stitchedSurface1 !== undefined ? stitchedSurface1 : face1.surface;
	        var o2 = stitchedSurface2 !== undefined ? stitchedSurface2 : face2.surface;
	        var stitchedCurve = getCurve(index, o1, o2);
	        stitchedCurve.addEdge(e);
	      }
	    }
	  } catch (err) {
	    _didIteratorError3 = true;
	    _iteratorError3 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion3 && _iterator3.return) {
	        _iterator3.return();
	      }
	    } finally {
	      if (_didIteratorError3) {
	        throw _iteratorError3;
	      }
	    }
	  }
	}
	
	function getCurve(index, o1, o2) {
	  var curve = index.get(o1, o2);
	  if (curve == null) {
	    curve = new StitchedCurve(o1, o2);
	    index.set(o1, o2, curve);
	  }
	  return curve;
	}

/***/ },
/* 330 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	exports.askNumber = askNumber;
	exports.fillArray = fillArray;
	exports.constRef = constRef;
	exports.swap = swap;
	exports.camelCaseSplit = camelCaseSplit;
	exports.defineIterable = defineIterable;
	exports.reversedIndex = reversedIndex;
	exports.rotateArr = rotateArr;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function askNumber(promptText, initValue, promptCallback, resolver) {
	  var promptValueStr = promptCallback(promptText, initValue);
	  if (promptValueStr != null) {
	    var promptValue = Number(promptValueStr);
	    if (promptValue == promptValue) {
	      // check for NaN
	      return promptValue;
	    } else {
	      if (!!resolver) {
	        promptValue = resolver(promptValueStr);
	        if (promptValue == promptValue) {
	          return promptValueStr;
	        }
	      }
	    }
	  }
	  return null;
	}
	
	var extend = exports.extend = function extend(func, parent) {
	  for (var prop in parent.prototype) {
	    if (parent.prototype.hasOwnProperty(prop)) func.prototype[prop] = parent.prototype[prop];
	  }
	};
	
	function fillArray(a, fromIndex, toIndex, val) {
	  for (var i = fromIndex; i < toIndex; i++) {
	    a[i] = val;
	  }
	}
	
	function constRef(value) {
	  return function () {
	    return value;
	  };
	}
	
	function swap(arr, i1, i2) {
	  var tmp = arr[i1];
	  arr[i1] = arr[i2];
	  arr[i2] = tmp;
	}
	
	function camelCaseSplit(str) {
	  function isUpperCase(str) {
	    return str.toUpperCase() == str;
	  }
	
	  var words = [];
	  var word = '';
	
	  for (var i = 0; i < str.length; i++) {
	    var c = str.charAt(i);
	    if (c == '_' || c == '-') {
	      continue;
	    }
	    var dot = c === '.';
	    if ((dot || isUpperCase(c)) && word.length != 0) {
	      words.push(word);
	      word = '';
	    }
	    if (!dot) word += c;
	  }
	  if (word.length != 0) {
	    words.push(word);
	  }
	  return words;
	}
	
	function defineIterable(obj, name, iteratorFactory) {
	  obj[name] = {};
	  obj[name][Symbol.iterator] = iteratorFactory;
	}
	
	var DoubleKeyMap = exports.DoubleKeyMap = function () {
	  function DoubleKeyMap() {
	    _classCallCheck(this, DoubleKeyMap);
	
	    this.map = new Map();
	  }
	
	  _createClass(DoubleKeyMap, [{
	    key: 'get',
	    value: function get(a, b) {
	      var subMap = this.map.get(a);
	      if (subMap == null) {
	        subMap = this.map.get(b);
	        if (subMap != null) {
	          return subMap.get(a);
	        }
	        return null;
	      }
	      return subMap.get(b);
	    }
	  }, {
	    key: 'set',
	    value: function set(a, b, value) {
	      var subMap = this.map.get(a);
	      if (subMap == null) {
	        subMap = this.map.get(b);
	        if (subMap != null) {
	          subMap.set(a, value);
	          return;
	        }
	        subMap = new Map();
	        this.map.set(a, subMap);
	      }
	      subMap.set(b, value);
	    }
	  }]);
	
	  return DoubleKeyMap;
	}();
	
	function reversedIndex(i, n) {
	  var lidIdx = n - i;
	  if (lidIdx == n) {
	    lidIdx = 0;
	  }
	  return lidIdx;
	}
	
	function rotateArr(arr, pivot) {
	
	  function reverse(arr, from, to) {
	    to--;
	    while (from < to) {
	      var t = arr[from];
	      arr[from] = arr[to];
	      arr[to] = t;
	      from++;
	      to--;
	    }
	  }
	  reverse(arr, 0, pivot);
	  reverse(arr, pivot, arr.length);
	  reverse(arr, 0, arr.length);
	}

/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.UI = undefined;
	
	var _toolkit = __webpack_require__(300);
	
	var tk = _interopRequireWildcard(_toolkit);
	
	var _cadUtils = __webpack_require__(302);
	
	var cad_utils = _interopRequireWildcard(_cadUtils);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	var _workbench = __webpack_require__(311);
	
	var workbench = _interopRequireWildcard(_workbench);
	
	var _toolbar = __webpack_require__(332);
	
	var _toolbar2 = _interopRequireDefault(_toolbar);
	
	var _menuConfig = __webpack_require__(357);
	
	var MenuConfig = _interopRequireWildcard(_menuConfig);
	
	var _operations = __webpack_require__(358);
	
	var Operations = _interopRequireWildcard(_operations);
	
	var _menu = __webpack_require__(383);
	
	var _menu2 = _interopRequireDefault(_menu);
	
	var _cutExtrudeWizard = __webpack_require__(384);
	
	var _revolveWizard = __webpack_require__(387);
	
	var _planeWizard = __webpack_require__(388);
	
	var _box = __webpack_require__(389);
	
	var _sphere = __webpack_require__(390);
	
	var _transform = __webpack_require__(392);
	
	var _import = __webpack_require__(393);
	
	var _utils = __webpack_require__(333);
	
	var _bind = __webpack_require__(394);
	
	var _solidList = __webpack_require__(396);
	
	var _modificationsPanel = __webpack_require__(397);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function UI(app) {
	  this.app = app;
	  this.viewer = app.viewer;
	  var mainBox = this.mainBox = new tk.Panel();
	  mainBox.root.css({ height: '100%' });
	  $('#right-panel').append(mainBox.root);
	  var modelFolder = new tk.Folder("Model");
	  this.solidList = new _solidList.SolidList(this.app);
	  modelFolder.content.append(this.solidList.dom);
	
	  tk.add(mainBox, modelFolder);
	  var modificationsPanel = new _modificationsPanel.ModificationsPanel(this.app);
	  mainBox.content.append(modificationsPanel.dom);
	
	  var toolbarVertOffset = 10; //this.mainBox.root.position().top;
	
	  this.registerMenuActions(MenuConfig);
	
	  this.craftToolBar = this.createCraftToolBar(toolbarVertOffset);
	  this.createBoolToolBar(this.craftToolBar.node.position().top + this.craftToolBar.node.height() + 20);
	  this.createMiscToolBar(toolbarVertOffset);
	  this.fillControlBar();
	  var ui = this;
	
	  this.app.bus.subscribe("showSketches", function (enabled) {
	    var solids = app.findAllSolidsOnScene();
	    for (var i = 0; i < solids.length; i++) {
	      for (var j = 0; j < solids[i].sceneFaces.length; j++) {
	        var face = solids[i].sceneFaces[j];
	        if (face.sketch3DGroup != null) face.sketch3DGroup.visible = enabled;
	      }
	    }
	    app.viewer.render();
	  });
	
	  app.bus.subscribe("solid-pick", function (solid) {
	    ui.registerWizard(new _transform.TransformWizard(app.viewer, solid));
	  });
	  registerOperations(app);
	}
	
	function registerOperations(app) {
	  var opNames = Object.keys(Operations);
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = opNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var opName = _step.value;
	
	      console.log('Registering Operation ' + opName);
	      app.craft.registerOperation(opName, Operations[opName].action);
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	}
	
	UI.prototype.createCraftToolBar = function (vertPos) {
	  var toolBar = new _toolbar2.default(this.app);
	  toolBar.add(this.app.actionManager.actions['PLANE']);
	  toolBar.add(this.app.actionManager.actions['EditFace']);
	  toolBar.add(this.app.actionManager.actions['EXTRUDE']);
	  toolBar.add(this.app.actionManager.actions['CUT']);
	  toolBar.add(this.app.actionManager.actions['REVOLVE']);
	
	  $('#viewer-container').append(toolBar.node);
	  toolBar.node.css({ left: '10px', top: vertPos + 'px' });
	  return toolBar;
	};
	
	UI.prototype.createMiscToolBar = function (vertPos) {
	  var toolBar = new _toolbar2.default(this.app);
	  toolBar.addFa(this.app.actionManager.actions['Save']);
	  toolBar.addFa(this.app.actionManager.actions['StlExport']);
	  $('#viewer-container').append(toolBar.node);
	  toolBar.node.css({ top: vertPos + 'px' });
	  toolBar.node.css({ right: '10px', 'font-size': '16px' });
	  return toolBar;
	};
	
	UI.prototype.createBoolToolBar = function (vertPos) {
	  var toolBar = new _toolbar2.default(this.app);
	  toolBar.add(this.app.actionManager.actions['INTERSECTION']);
	  toolBar.add(this.app.actionManager.actions['DIFFERENCE']);
	  toolBar.add(this.app.actionManager.actions['UNION']);
	  $('#viewer-container').append(toolBar.node);
	  toolBar.node.css({ left: '10px', top: vertPos + 'px' });
	  return toolBar;
	};
	
	UI.prototype.registerMenuActions = function (menuConfig) {
	  var _this = this;
	
	  for (var menuName in menuConfig) {
	    var m = menuConfig[menuName];
	    var action = Object.assign({ 'type': 'menu' }, m);
	    delete action['actions'];
	    action.menu = new _menu2.default(m.actions.map(function (a) {
	      return _this.app.actionManager.actions[a];
	    }).filter(function (a) {
	      return a != undefined;
	    }), this.app.inputManager);
	    this.app.actionManager.registerAction('menu.' + menuName, action);
	  }
	};
	
	UI.prototype.fillControlBar = function () {
	  var LEFT = true;
	  var RIGHT = !LEFT;
	  this.app.controlBar.add('Info', RIGHT, { 'label': null });
	  this.app.controlBar.add('RefreshSketches', RIGHT, { 'label': null });
	  this.app.controlBar.add('ShowSketches', RIGHT, { 'label': 'sketches' });
	  this.app.controlBar.add('DeselectAll', RIGHT, { 'label': null });
	  this.app.controlBar.add('menu.file', LEFT);
	  this.app.controlBar.add('menu.craft', LEFT);
	  this.app.controlBar.add('menu.boolean', LEFT);
	  this.app.controlBar.add('menu.primitives', LEFT);
	  this.app.controlBar.add('Donate', LEFT);
	  this.app.controlBar.add('GitHub', LEFT);
	};
	
	UI.prototype.registerWizard = function (wizard, overridingHistory) {
	  wizard.box.root.css({ left: this.mainBox.root.width() + this.craftToolBar.node.width() + 30 + 'px', top: 0 });
	  var craft = this.app.craft;
	  wizard.overridingHistory = overridingHistory;
	  wizard.focus();
	  if (this.registeredWizard != undefined) {
	    if (!this.registeredWizard.disposed) {
	      this.registeredWizard.dispose();
	    }
	  }
	  this.registeredWizard = wizard;
	  return wizard;
	};
	
	UI.prototype.getInfoForOp = function (op) {
	  var p = op.params;
	  var opDef = Operations[op.type];
	  if (opDef && opDef.info) {
	    return op.type + ' ' + opDef.info(p);
	  }
	  return op.type;
	};
	
	UI.prototype.initOperation = function (op) {
	  var selection = this.app.viewer.selectionMgr.selection;
	  return this.createWizard(op, false, undefined, selection[0]);
	};
	
	UI.prototype.createWizardForOperation = function (op) {
	  var initParams = op.params;
	  var face = op.face !== undefined ? this.app.findFace(op.face) : null;
	  if (face != null) {
	    this.app.viewer.selectionMgr.select(face);
	  }
	  return this.createWizard(op.type, true, initParams, face);
	};
	
	UI.prototype.createWizard = function (type, overridingHistory, initParams, face) {
	  var wizard = null;
	  if ('CUT' === type) {
	    wizard = new _cutExtrudeWizard.CutWizard(this.app, initParams);
	  } else if ('EXTRUDE' === type) {
	    wizard = new _cutExtrudeWizard.ExtrudeWizard(this.app, initParams);
	  } else if ('REVOLVE' === type) {
	    wizard = new _revolveWizard.RevolveWizard(this.app, face, initParams);
	  } else if ('PLANE' === type) {
	    wizard = new _planeWizard.PlaneWizard(this.app, initParams);
	  } else if ('BOX' === type) {
	    wizard = new _box.BoxWizard(this.app, initParams);
	  } else if ('SPHERE' === type) {
	    wizard = new _sphere.SphereWizard(this.app.viewer, initParams);
	  } else if ('IMPORT_STL' === type) {
	    wizard = new _import.ImportWizard(this.app.viewer, initParams);
	  } else {
	    console.log('unknown operation');
	  }
	  if (wizard != null) {
	    this.registerWizard(wizard, overridingHistory);
	  }
	  return wizard;
	};
	
	exports.UI = UI;

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ToolBar;
	
	var _utils = __webpack_require__(333);
	
	function ToolBar(app) {
	  this.app = app;
	  this.node = $('<div>', {
	    css: {
	      'position': 'absolute',
	      'background-color': 'rgba(255, 255, 255, 0.5)',
	      'padding': '5px',
	      'border-radius': '5px'
	    }
	  });
	}
	
	ToolBar.prototype.add = function (action) {
	  if (!action) return;
	  var btn = $('<div>', {
	    'class': 'tc-toolbar-btn tc-squeezed-text',
	    text: (0, _utils.capitalize)(action.label),
	    css: ToolBar.buttonCss({
	      'background-image': 'url(' + action.icon96 + ')',
	      'background-repeat': 'no-repeat',
	      'background-position-x': 'center',
	      'background-position-y': 'top',
	      'background-size': '48px 48px'
	    })
	  });
	  this.setUp(btn, action);
	  this.node.append(btn);
	  return btn;
	};
	
	ToolBar.prototype.setUp = function (btn, action) {
	  btn.addClass('action-item');
	  btn.attr('data-action', action.id);
	  this.app.actionManager.subscribe(action.id, function (state) {
	    if (state.enabled) {
	      btn.removeClass('action-disabled');
	    } else {
	      btn.addClass('action-disabled');
	    }
	  });
	};
	
	ToolBar.prototype.addFa = function (action) {
	  if (!action || !action.cssIcons) return;
	  var btn = $('<div>', {
	    'class': 'tc-toolbar-btn',
	    css: {
	      'border-radius': '5px',
	      'padding': '5px'
	    }
	  });
	  btn.append($('<i>', {
	    'class': 'fa ' + (0, _utils.cssIconsToClasses)(action.cssIcons),
	    css: {
	      'vertical-align': 'middle'
	    }
	  }));
	  this.setUp(btn, action);
	  this.node.append(btn);
	  return btn;
	};
	
	ToolBar.buttonCss = function (css) {
	  return Object.assign(css, {
	    'border-radius': '5px',
	    'width': '53px',
	    'padding-top': '48px',
	    'margin-top': '5px'
	  });
	};

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DefaultMouseEvent = DefaultMouseEvent;
	exports.fit = fit;
	exports.capitalize = capitalize;
	exports.cssIconsToClasses = cssIconsToClasses;
	exports.LoadTemplate = LoadTemplate;
	function DefaultMouseEvent() {
	  var viewer = $('#viewer-container');
	  var off = viewer.offset();
	  var r = Math.round;
	  this.type = 'click';
	  this.canBubble = true;
	  this.cancelable = true;
	  this.detail = 1;
	  this.screenX = r(off.left + viewer.width() / 2);
	  this.screenY = r(off.top + viewer.height() / 2);
	  this.clientX = this.screenX;
	  this.clientY = this.screenY;
	  this.pageX = this.screenX;
	  this.pageY = this.screenY;
	  this.ctrlKey = false;
	  this.altKey = false;
	  this.shiftKey = false;
	  this.metaKey = false;
	  this.button = 0;
	  this.relatedTarget = null;
	}
	
	var EventData = exports.EventData = {
	
	  get: function get(event, key) {
	    if (event.data) {
	      return event.data[key];
	    } else {
	      return undefined;
	    }
	  },
	
	  set: function set(event, key, value) {
	    if (!event.data) {
	      event.data = {};
	    }
	    event.data[key] = value;
	  }
	};
	
	function fit(el, relativeEl) {
	  var span = 5;
	  var relOff = relativeEl.offset();
	  var off = el.offset();
	
	  var needToSet = false;
	  if (off.left < relOff.left) {
	    off.left = relOff.left + span;
	    needToSet = true;
	  }
	  var right = relOff.left + relativeEl.width() - span;
	  var outerWidth = el.outerWidth();
	  if (off.left + outerWidth >= right) {
	    off.left = right - outerWidth;
	    needToSet = true;
	  }
	  if (off.top < relOff.top + span) {
	    off.top = relOff.top + span;
	    needToSet = true;
	  }
	  var bottom = relOff.top + relativeEl.height() - span;
	  var outerHeight = el.outerHeight();
	  if (off.top + outerHeight >= bottom) {
	    off.top = bottom - outerHeight;
	    needToSet = true;
	  }
	  if (needToSet) {
	    el.css({
	      left: off.left + 'px',
	      top: off.top + 'px'
	    });
	  }
	}
	
	function capitalize(str) {
	  if (!str) return;
	  return str.charAt(0).toUpperCase() + str.slice(1);
	}
	
	function cssIconsToClasses(cssIcons) {
	  return cssIcons.map(function (i) {
	    return 'fa-' + i;
	  }).join(' ');
	}
	
	function LoadTemplate(name) {
	  return __webpack_require__(334)("./" + name + '.html');
	}

/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./action-info.html": 335,
		"./modifications.html": 355,
		"./solid-list.html": 356
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 334;


/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	var Handlebars = __webpack_require__(336);
	function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
	module.exports = (Handlebars["default"] || Handlebars).template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
	    return "<div class=\"action-info\">\r\n  <div class=\"action-info-hint\" data-bind=\"hint\"></div>\r\n  <div class=\"action-info-info\" data-bind=\"info\"></div>\r\n  <div class=\"action-info-hotkey\" data-bind=\"hotKey\">hotkey: %s</div>\r\n</div>";
	},"useData":true});

/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	// Create a simple path alias to allow browserify to resolve
	// the runtime on a supported path.
	module.exports = __webpack_require__(337)['default'];


/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	// istanbul ignore next
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	// istanbul ignore next
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }
	
	var _handlebarsBase = __webpack_require__(338);
	
	var base = _interopRequireWildcard(_handlebarsBase);
	
	// Each of these augment the Handlebars object. No need to setup here.
	// (This is done to easily share code between commonjs and browse envs)
	
	var _handlebarsSafeString = __webpack_require__(352);
	
	var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
	
	var _handlebarsException = __webpack_require__(340);
	
	var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
	
	var _handlebarsUtils = __webpack_require__(339);
	
	var Utils = _interopRequireWildcard(_handlebarsUtils);
	
	var _handlebarsRuntime = __webpack_require__(353);
	
	var runtime = _interopRequireWildcard(_handlebarsRuntime);
	
	var _handlebarsNoConflict = __webpack_require__(354);
	
	var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
	
	// For compatibility and usage outside of module systems, make the Handlebars object a namespace
	function create() {
	  var hb = new base.HandlebarsEnvironment();
	
	  Utils.extend(hb, base);
	  hb.SafeString = _handlebarsSafeString2['default'];
	  hb.Exception = _handlebarsException2['default'];
	  hb.Utils = Utils;
	  hb.escapeExpression = Utils.escapeExpression;
	
	  hb.VM = runtime;
	  hb.template = function (spec) {
	    return runtime.template(spec, hb);
	  };
	
	  return hb;
	}
	
	var inst = create();
	inst.create = create;
	
	_handlebarsNoConflict2['default'](inst);
	
	inst['default'] = inst;
	
	exports['default'] = inst;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9oYW5kbGViYXJzLnJ1bnRpbWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OEJBQXNCLG1CQUFtQjs7SUFBN0IsSUFBSTs7Ozs7b0NBSU8sMEJBQTBCOzs7O21DQUMzQix3QkFBd0I7Ozs7K0JBQ3ZCLG9CQUFvQjs7SUFBL0IsS0FBSzs7aUNBQ1Esc0JBQXNCOztJQUFuQyxPQUFPOztvQ0FFSSwwQkFBMEI7Ozs7O0FBR2pELFNBQVMsTUFBTSxHQUFHO0FBQ2hCLE1BQUksRUFBRSxHQUFHLElBQUksSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7O0FBRTFDLE9BQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3ZCLElBQUUsQ0FBQyxVQUFVLG9DQUFhLENBQUM7QUFDM0IsSUFBRSxDQUFDLFNBQVMsbUNBQVksQ0FBQztBQUN6QixJQUFFLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNqQixJQUFFLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDLGdCQUFnQixDQUFDOztBQUU3QyxJQUFFLENBQUMsRUFBRSxHQUFHLE9BQU8sQ0FBQztBQUNoQixJQUFFLENBQUMsUUFBUSxHQUFHLFVBQVMsSUFBSSxFQUFFO0FBQzNCLFdBQU8sT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7R0FDbkMsQ0FBQzs7QUFFRixTQUFPLEVBQUUsQ0FBQztDQUNYOztBQUVELElBQUksSUFBSSxHQUFHLE1BQU0sRUFBRSxDQUFDO0FBQ3BCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDOztBQUVyQixrQ0FBVyxJQUFJLENBQUMsQ0FBQzs7QUFFakIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQzs7cUJBRVIsSUFBSSIsImZpbGUiOiJoYW5kbGViYXJzLnJ1bnRpbWUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBiYXNlIGZyb20gJy4vaGFuZGxlYmFycy9iYXNlJztcblxuLy8gRWFjaCBvZiB0aGVzZSBhdWdtZW50IHRoZSBIYW5kbGViYXJzIG9iamVjdC4gTm8gbmVlZCB0byBzZXR1cCBoZXJlLlxuLy8gKFRoaXMgaXMgZG9uZSB0byBlYXNpbHkgc2hhcmUgY29kZSBiZXR3ZWVuIGNvbW1vbmpzIGFuZCBicm93c2UgZW52cylcbmltcG9ydCBTYWZlU3RyaW5nIGZyb20gJy4vaGFuZGxlYmFycy9zYWZlLXN0cmluZyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4vaGFuZGxlYmFycy9leGNlcHRpb24nO1xuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi9oYW5kbGViYXJzL3V0aWxzJztcbmltcG9ydCAqIGFzIHJ1bnRpbWUgZnJvbSAnLi9oYW5kbGViYXJzL3J1bnRpbWUnO1xuXG5pbXBvcnQgbm9Db25mbGljdCBmcm9tICcuL2hhbmRsZWJhcnMvbm8tY29uZmxpY3QnO1xuXG4vLyBGb3IgY29tcGF0aWJpbGl0eSBhbmQgdXNhZ2Ugb3V0c2lkZSBvZiBtb2R1bGUgc3lzdGVtcywgbWFrZSB0aGUgSGFuZGxlYmFycyBvYmplY3QgYSBuYW1lc3BhY2VcbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IGhiID0gbmV3IGJhc2UuSGFuZGxlYmFyc0Vudmlyb25tZW50KCk7XG5cbiAgVXRpbHMuZXh0ZW5kKGhiLCBiYXNlKTtcbiAgaGIuU2FmZVN0cmluZyA9IFNhZmVTdHJpbmc7XG4gIGhiLkV4Y2VwdGlvbiA9IEV4Y2VwdGlvbjtcbiAgaGIuVXRpbHMgPSBVdGlscztcbiAgaGIuZXNjYXBlRXhwcmVzc2lvbiA9IFV0aWxzLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgaGIuVk0gPSBydW50aW1lO1xuICBoYi50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICByZXR1cm4gcnVudGltZS50ZW1wbGF0ZShzcGVjLCBoYik7XG4gIH07XG5cbiAgcmV0dXJuIGhiO1xufVxuXG5sZXQgaW5zdCA9IGNyZWF0ZSgpO1xuaW5zdC5jcmVhdGUgPSBjcmVhdGU7XG5cbm5vQ29uZmxpY3QoaW5zdCk7XG5cbmluc3RbJ2RlZmF1bHQnXSA9IGluc3Q7XG5cbmV4cG9ydCBkZWZhdWx0IGluc3Q7XG4iXX0=


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.HandlebarsEnvironment = HandlebarsEnvironment;
	// istanbul ignore next
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _utils = __webpack_require__(339);
	
	var _exception = __webpack_require__(340);
	
	var _exception2 = _interopRequireDefault(_exception);
	
	var _helpers = __webpack_require__(341);
	
	var _decorators = __webpack_require__(349);
	
	var _logger = __webpack_require__(351);
	
	var _logger2 = _interopRequireDefault(_logger);
	
	var VERSION = '4.0.5';
	exports.VERSION = VERSION;
	var COMPILER_REVISION = 7;
	
	exports.COMPILER_REVISION = COMPILER_REVISION;
	var REVISION_CHANGES = {
	  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
	  2: '== 1.0.0-rc.3',
	  3: '== 1.0.0-rc.4',
	  4: '== 1.x.x',
	  5: '== 2.0.0-alpha.x',
	  6: '>= 2.0.0-beta.1',
	  7: '>= 4.0.0'
	};
	
	exports.REVISION_CHANGES = REVISION_CHANGES;
	var objectType = '[object Object]';
	
	function HandlebarsEnvironment(helpers, partials, decorators) {
	  this.helpers = helpers || {};
	  this.partials = partials || {};
	  this.decorators = decorators || {};
	
	  _helpers.registerDefaultHelpers(this);
	  _decorators.registerDefaultDecorators(this);
	}
	
	HandlebarsEnvironment.prototype = {
	  constructor: HandlebarsEnvironment,
	
	  logger: _logger2['default'],
	  log: _logger2['default'].log,
	
	  registerHelper: function registerHelper(name, fn) {
	    if (_utils.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2['default']('Arg not supported with multiple helpers');
	      }
	      _utils.extend(this.helpers, name);
	    } else {
	      this.helpers[name] = fn;
	    }
	  },
	  unregisterHelper: function unregisterHelper(name) {
	    delete this.helpers[name];
	  },
	
	  registerPartial: function registerPartial(name, partial) {
	    if (_utils.toString.call(name) === objectType) {
	      _utils.extend(this.partials, name);
	    } else {
	      if (typeof partial === 'undefined') {
	        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
	      }
	      this.partials[name] = partial;
	    }
	  },
	  unregisterPartial: function unregisterPartial(name) {
	    delete this.partials[name];
	  },
	
	  registerDecorator: function registerDecorator(name, fn) {
	    if (_utils.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2['default']('Arg not supported with multiple decorators');
	      }
	      _utils.extend(this.decorators, name);
	    } else {
	      this.decorators[name] = fn;
	    }
	  },
	  unregisterDecorator: function unregisterDecorator(name) {
	    delete this.decorators[name];
	  }
	};
	
	var log = _logger2['default'].log;
	
	exports.log = log;
	exports.createFrame = _utils.createFrame;
	exports.logger = _logger2['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2Jhc2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7cUJBQTRDLFNBQVM7O3lCQUMvQixhQUFhOzs7O3VCQUNFLFdBQVc7OzBCQUNSLGNBQWM7O3NCQUNuQyxVQUFVOzs7O0FBRXRCLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQzs7QUFDeEIsSUFBTSxpQkFBaUIsR0FBRyxDQUFDLENBQUM7OztBQUU1QixJQUFNLGdCQUFnQixHQUFHO0FBQzlCLEdBQUMsRUFBRSxhQUFhO0FBQ2hCLEdBQUMsRUFBRSxlQUFlO0FBQ2xCLEdBQUMsRUFBRSxlQUFlO0FBQ2xCLEdBQUMsRUFBRSxVQUFVO0FBQ2IsR0FBQyxFQUFFLGtCQUFrQjtBQUNyQixHQUFDLEVBQUUsaUJBQWlCO0FBQ3BCLEdBQUMsRUFBRSxVQUFVO0NBQ2QsQ0FBQzs7O0FBRUYsSUFBTSxVQUFVLEdBQUcsaUJBQWlCLENBQUM7O0FBRTlCLFNBQVMscUJBQXFCLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUU7QUFDbkUsTUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLElBQUksRUFBRSxDQUFDO0FBQzdCLE1BQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxJQUFJLEVBQUUsQ0FBQztBQUMvQixNQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsSUFBSSxFQUFFLENBQUM7O0FBRW5DLGtDQUF1QixJQUFJLENBQUMsQ0FBQztBQUM3Qix3Q0FBMEIsSUFBSSxDQUFDLENBQUM7Q0FDakM7O0FBRUQscUJBQXFCLENBQUMsU0FBUyxHQUFHO0FBQ2hDLGFBQVcsRUFBRSxxQkFBcUI7O0FBRWxDLFFBQU0scUJBQVE7QUFDZCxLQUFHLEVBQUUsb0JBQU8sR0FBRzs7QUFFZixnQkFBYyxFQUFFLHdCQUFTLElBQUksRUFBRSxFQUFFLEVBQUU7QUFDakMsUUFBSSxnQkFBUyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssVUFBVSxFQUFFO0FBQ3RDLFVBQUksRUFBRSxFQUFFO0FBQUUsY0FBTSwyQkFBYyx5Q0FBeUMsQ0FBQyxDQUFDO09BQUU7QUFDM0Usb0JBQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztLQUM1QixNQUFNO0FBQ0wsVUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7S0FDekI7R0FDRjtBQUNELGtCQUFnQixFQUFFLDBCQUFTLElBQUksRUFBRTtBQUMvQixXQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7R0FDM0I7O0FBRUQsaUJBQWUsRUFBRSx5QkFBUyxJQUFJLEVBQUUsT0FBTyxFQUFFO0FBQ3ZDLFFBQUksZ0JBQVMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLFVBQVUsRUFBRTtBQUN0QyxvQkFBTyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQzdCLE1BQU07QUFDTCxVQUFJLE9BQU8sT0FBTyxLQUFLLFdBQVcsRUFBRTtBQUNsQyxjQUFNLHlFQUEwRCxJQUFJLG9CQUFpQixDQUFDO09BQ3ZGO0FBQ0QsVUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxPQUFPLENBQUM7S0FDL0I7R0FDRjtBQUNELG1CQUFpQixFQUFFLDJCQUFTLElBQUksRUFBRTtBQUNoQyxXQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7R0FDNUI7O0FBRUQsbUJBQWlCLEVBQUUsMkJBQVMsSUFBSSxFQUFFLEVBQUUsRUFBRTtBQUNwQyxRQUFJLGdCQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxVQUFVLEVBQUU7QUFDdEMsVUFBSSxFQUFFLEVBQUU7QUFBRSxjQUFNLDJCQUFjLDRDQUE0QyxDQUFDLENBQUM7T0FBRTtBQUM5RSxvQkFBTyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQy9CLE1BQU07QUFDTCxVQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztLQUM1QjtHQUNGO0FBQ0QscUJBQW1CLEVBQUUsNkJBQVMsSUFBSSxFQUFFO0FBQ2xDLFdBQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztHQUM5QjtDQUNGLENBQUM7O0FBRUssSUFBSSxHQUFHLEdBQUcsb0JBQU8sR0FBRyxDQUFDOzs7UUFFcEIsV0FBVztRQUFFLE1BQU0iLCJmaWxlIjoiYmFzZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y3JlYXRlRnJhbWUsIGV4dGVuZCwgdG9TdHJpbmd9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuL2V4Y2VwdGlvbic7XG5pbXBvcnQge3JlZ2lzdGVyRGVmYXVsdEhlbHBlcnN9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQge3JlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnN9IGZyb20gJy4vZGVjb3JhdG9ycyc7XG5pbXBvcnQgbG9nZ2VyIGZyb20gJy4vbG9nZ2VyJztcblxuZXhwb3J0IGNvbnN0IFZFUlNJT04gPSAnNC4wLjUnO1xuZXhwb3J0IGNvbnN0IENPTVBJTEVSX1JFVklTSU9OID0gNztcblxuZXhwb3J0IGNvbnN0IFJFVklTSU9OX0NIQU5HRVMgPSB7XG4gIDE6ICc8PSAxLjAucmMuMicsIC8vIDEuMC5yYy4yIGlzIGFjdHVhbGx5IHJldjIgYnV0IGRvZXNuJ3QgcmVwb3J0IGl0XG4gIDI6ICc9PSAxLjAuMC1yYy4zJyxcbiAgMzogJz09IDEuMC4wLXJjLjQnLFxuICA0OiAnPT0gMS54LngnLFxuICA1OiAnPT0gMi4wLjAtYWxwaGEueCcsXG4gIDY6ICc+PSAyLjAuMC1iZXRhLjEnLFxuICA3OiAnPj0gNC4wLjAnXG59O1xuXG5jb25zdCBvYmplY3RUeXBlID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBIYW5kbGViYXJzRW52aXJvbm1lbnQoaGVscGVycywgcGFydGlhbHMsIGRlY29yYXRvcnMpIHtcbiAgdGhpcy5oZWxwZXJzID0gaGVscGVycyB8fCB7fTtcbiAgdGhpcy5wYXJ0aWFscyA9IHBhcnRpYWxzIHx8IHt9O1xuICB0aGlzLmRlY29yYXRvcnMgPSBkZWNvcmF0b3JzIHx8IHt9O1xuXG4gIHJlZ2lzdGVyRGVmYXVsdEhlbHBlcnModGhpcyk7XG4gIHJlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnModGhpcyk7XG59XG5cbkhhbmRsZWJhcnNFbnZpcm9ubWVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBIYW5kbGViYXJzRW52aXJvbm1lbnQsXG5cbiAgbG9nZ2VyOiBsb2dnZXIsXG4gIGxvZzogbG9nZ2VyLmxvZyxcblxuICByZWdpc3RlckhlbHBlcjogZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgaWYgKGZuKSB7IHRocm93IG5ldyBFeGNlcHRpb24oJ0FyZyBub3Qgc3VwcG9ydGVkIHdpdGggbXVsdGlwbGUgaGVscGVycycpOyB9XG4gICAgICBleHRlbmQodGhpcy5oZWxwZXJzLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWxwZXJzW25hbWVdID0gZm47XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVySGVscGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuaGVscGVyc1tuYW1lXTtcbiAgfSxcblxuICByZWdpc3RlclBhcnRpYWw6IGZ1bmN0aW9uKG5hbWUsIHBhcnRpYWwpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgZXh0ZW5kKHRoaXMucGFydGlhbHMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHBhcnRpYWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oYEF0dGVtcHRpbmcgdG8gcmVnaXN0ZXIgYSBwYXJ0aWFsIGNhbGxlZCBcIiR7bmFtZX1cIiBhcyB1bmRlZmluZWRgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFydGlhbHNbbmFtZV0gPSBwYXJ0aWFsO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3RlclBhcnRpYWw6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5wYXJ0aWFsc1tuYW1lXTtcbiAgfSxcblxuICByZWdpc3RlckRlY29yYXRvcjogZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgaWYgKGZuKSB7IHRocm93IG5ldyBFeGNlcHRpb24oJ0FyZyBub3Qgc3VwcG9ydGVkIHdpdGggbXVsdGlwbGUgZGVjb3JhdG9ycycpOyB9XG4gICAgICBleHRlbmQodGhpcy5kZWNvcmF0b3JzLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWNvcmF0b3JzW25hbWVdID0gZm47XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVyRGVjb3JhdG9yOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuZGVjb3JhdG9yc1tuYW1lXTtcbiAgfVxufTtcblxuZXhwb3J0IGxldCBsb2cgPSBsb2dnZXIubG9nO1xuXG5leHBvcnQge2NyZWF0ZUZyYW1lLCBsb2dnZXJ9O1xuIl19


/***/ },
/* 339 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.extend = extend;
	exports.indexOf = indexOf;
	exports.escapeExpression = escapeExpression;
	exports.isEmpty = isEmpty;
	exports.createFrame = createFrame;
	exports.blockParams = blockParams;
	exports.appendContextPath = appendContextPath;
	var escape = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#x27;',
	  '`': '&#x60;',
	  '=': '&#x3D;'
	};
	
	var badChars = /[&<>"'`=]/g,
	    possible = /[&<>"'`=]/;
	
	function escapeChar(chr) {
	  return escape[chr];
	}
	
	function extend(obj /* , ...source */) {
	  for (var i = 1; i < arguments.length; i++) {
	    for (var key in arguments[i]) {
	      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
	        obj[key] = arguments[i][key];
	      }
	    }
	  }
	
	  return obj;
	}
	
	var toString = Object.prototype.toString;
	
	exports.toString = toString;
	// Sourced from lodash
	// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
	/* eslint-disable func-style */
	var isFunction = function isFunction(value) {
	  return typeof value === 'function';
	};
	// fallback for older versions of Chrome and Safari
	/* istanbul ignore next */
	if (isFunction(/x/)) {
	  exports.isFunction = isFunction = function (value) {
	    return typeof value === 'function' && toString.call(value) === '[object Function]';
	  };
	}
	exports.isFunction = isFunction;
	
	/* eslint-enable func-style */
	
	/* istanbul ignore next */
	var isArray = Array.isArray || function (value) {
	  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
	};
	
	exports.isArray = isArray;
	// Older IE versions do not directly support indexOf so we must implement our own, sadly.
	
	function indexOf(array, value) {
	  for (var i = 0, len = array.length; i < len; i++) {
	    if (array[i] === value) {
	      return i;
	    }
	  }
	  return -1;
	}
	
	function escapeExpression(string) {
	  if (typeof string !== 'string') {
	    // don't escape SafeStrings, since they're already safe
	    if (string && string.toHTML) {
	      return string.toHTML();
	    } else if (string == null) {
	      return '';
	    } else if (!string) {
	      return string + '';
	    }
	
	    // Force a string conversion as this will be done by the append regardless and
	    // the regex test will do this transparently behind the scenes, causing issues if
	    // an object's to string has escaped characters in it.
	    string = '' + string;
	  }
	
	  if (!possible.test(string)) {
	    return string;
	  }
	  return string.replace(badChars, escapeChar);
	}
	
	function isEmpty(value) {
	  if (!value && value !== 0) {
	    return true;
	  } else if (isArray(value) && value.length === 0) {
	    return true;
	  } else {
	    return false;
	  }
	}
	
	function createFrame(object) {
	  var frame = extend({}, object);
	  frame._parent = object;
	  return frame;
	}
	
	function blockParams(params, ids) {
	  params.path = ids;
	  return params;
	}
	
	function appendContextPath(contextPath, id) {
	  return (contextPath ? contextPath + '.' : '') + id;
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxJQUFNLE1BQU0sR0FBRztBQUNiLEtBQUcsRUFBRSxPQUFPO0FBQ1osS0FBRyxFQUFFLE1BQU07QUFDWCxLQUFHLEVBQUUsTUFBTTtBQUNYLEtBQUcsRUFBRSxRQUFRO0FBQ2IsS0FBRyxFQUFFLFFBQVE7QUFDYixLQUFHLEVBQUUsUUFBUTtBQUNiLEtBQUcsRUFBRSxRQUFRO0NBQ2QsQ0FBQzs7QUFFRixJQUFNLFFBQVEsR0FBRyxZQUFZO0lBQ3ZCLFFBQVEsR0FBRyxXQUFXLENBQUM7O0FBRTdCLFNBQVMsVUFBVSxDQUFDLEdBQUcsRUFBRTtBQUN2QixTQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztDQUNwQjs7QUFFTSxTQUFTLE1BQU0sQ0FBQyxHQUFHLG9CQUFtQjtBQUMzQyxPQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN6QyxTQUFLLElBQUksR0FBRyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRTtBQUM1QixVQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUU7QUFDM0QsV0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztPQUM5QjtLQUNGO0dBQ0Y7O0FBRUQsU0FBTyxHQUFHLENBQUM7Q0FDWjs7QUFFTSxJQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQzs7Ozs7O0FBS2hELElBQUksVUFBVSxHQUFHLG9CQUFTLEtBQUssRUFBRTtBQUMvQixTQUFPLE9BQU8sS0FBSyxLQUFLLFVBQVUsQ0FBQztDQUNwQyxDQUFDOzs7QUFHRixJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUNuQixVQUlNLFVBQVUsR0FKaEIsVUFBVSxHQUFHLFVBQVMsS0FBSyxFQUFFO0FBQzNCLFdBQU8sT0FBTyxLQUFLLEtBQUssVUFBVSxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssbUJBQW1CLENBQUM7R0FDcEYsQ0FBQztDQUNIO1FBQ08sVUFBVSxHQUFWLFVBQVU7Ozs7O0FBSVgsSUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sSUFBSSxVQUFTLEtBQUssRUFBRTtBQUN0RCxTQUFPLEFBQUMsS0FBSyxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsR0FBSSxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLGdCQUFnQixHQUFHLEtBQUssQ0FBQztDQUNqRyxDQUFDOzs7OztBQUdLLFNBQVMsT0FBTyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUU7QUFDcEMsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUNoRCxRQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLEVBQUU7QUFDdEIsYUFBTyxDQUFDLENBQUM7S0FDVjtHQUNGO0FBQ0QsU0FBTyxDQUFDLENBQUMsQ0FBQztDQUNYOztBQUdNLFNBQVMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFO0FBQ3ZDLE1BQUksT0FBTyxNQUFNLEtBQUssUUFBUSxFQUFFOztBQUU5QixRQUFJLE1BQU0sSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO0FBQzNCLGFBQU8sTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO0tBQ3hCLE1BQU0sSUFBSSxNQUFNLElBQUksSUFBSSxFQUFFO0FBQ3pCLGFBQU8sRUFBRSxDQUFDO0tBQ1gsTUFBTSxJQUFJLENBQUMsTUFBTSxFQUFFO0FBQ2xCLGFBQU8sTUFBTSxHQUFHLEVBQUUsQ0FBQztLQUNwQjs7Ozs7QUFLRCxVQUFNLEdBQUcsRUFBRSxHQUFHLE1BQU0sQ0FBQztHQUN0Qjs7QUFFRCxNQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtBQUFFLFdBQU8sTUFBTSxDQUFDO0dBQUU7QUFDOUMsU0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQztDQUM3Qzs7QUFFTSxTQUFTLE9BQU8sQ0FBQyxLQUFLLEVBQUU7QUFDN0IsTUFBSSxDQUFDLEtBQUssSUFBSSxLQUFLLEtBQUssQ0FBQyxFQUFFO0FBQ3pCLFdBQU8sSUFBSSxDQUFDO0dBQ2IsTUFBTSxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtBQUMvQyxXQUFPLElBQUksQ0FBQztHQUNiLE1BQU07QUFDTCxXQUFPLEtBQUssQ0FBQztHQUNkO0NBQ0Y7O0FBRU0sU0FBUyxXQUFXLENBQUMsTUFBTSxFQUFFO0FBQ2xDLE1BQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDL0IsT0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7QUFDdkIsU0FBTyxLQUFLLENBQUM7Q0FDZDs7QUFFTSxTQUFTLFdBQVcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFO0FBQ3ZDLFFBQU0sQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO0FBQ2xCLFNBQU8sTUFBTSxDQUFDO0NBQ2Y7O0FBRU0sU0FBUyxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsRUFBRSxFQUFFO0FBQ2pELFNBQU8sQ0FBQyxXQUFXLEdBQUcsV0FBVyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUEsR0FBSSxFQUFFLENBQUM7Q0FDcEQiLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBlc2NhcGUgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmI3gyNzsnLFxuICAnYCc6ICcmI3g2MDsnLFxuICAnPSc6ICcmI3gzRDsnXG59O1xuXG5jb25zdCBiYWRDaGFycyA9IC9bJjw+XCInYD1dL2csXG4gICAgICBwb3NzaWJsZSA9IC9bJjw+XCInYD1dLztcblxuZnVuY3Rpb24gZXNjYXBlQ2hhcihjaHIpIHtcbiAgcmV0dXJuIGVzY2FwZVtjaHJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKG9iai8qICwgLi4uc291cmNlICovKSB7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQga2V5IGluIGFyZ3VtZW50c1tpXSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcmd1bWVudHNbaV0sIGtleSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSBhcmd1bWVudHNbaV1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5leHBvcnQgbGV0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLy8gU291cmNlZCBmcm9tIGxvZGFzaFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL2xvZGFzaC9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dFxuLyogZXNsaW50LWRpc2FibGUgZnVuYy1zdHlsZSAqL1xubGV0IGlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufTtcbi8vIGZhbGxiYWNrIGZvciBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChpc0Z1bmN0aW9uKC94LykpIHtcbiAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgfTtcbn1cbmV4cG9ydCB7aXNGdW5jdGlvbn07XG4vKiBlc2xpbnQtZW5hYmxlIGZ1bmMtc3R5bGUgKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpID8gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScgOiBmYWxzZTtcbn07XG5cbi8vIE9sZGVyIElFIHZlcnNpb25zIGRvIG5vdCBkaXJlY3RseSBzdXBwb3J0IGluZGV4T2Ygc28gd2UgbXVzdCBpbXBsZW1lbnQgb3VyIG93biwgc2FkbHkuXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlRXhwcmVzc2lvbihzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZG9uJ3QgZXNjYXBlIFNhZmVTdHJpbmdzLCBzaW5jZSB0aGV5J3JlIGFscmVhZHkgc2FmZVxuICAgIGlmIChzdHJpbmcgJiYgc3RyaW5nLnRvSFRNTCkge1xuICAgICAgcmV0dXJuIHN0cmluZy50b0hUTUwoKTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nICsgJyc7XG4gICAgfVxuXG4gICAgLy8gRm9yY2UgYSBzdHJpbmcgY29udmVyc2lvbiBhcyB0aGlzIHdpbGwgYmUgZG9uZSBieSB0aGUgYXBwZW5kIHJlZ2FyZGxlc3MgYW5kXG4gICAgLy8gdGhlIHJlZ2V4IHRlc3Qgd2lsbCBkbyB0aGlzIHRyYW5zcGFyZW50bHkgYmVoaW5kIHRoZSBzY2VuZXMsIGNhdXNpbmcgaXNzdWVzIGlmXG4gICAgLy8gYW4gb2JqZWN0J3MgdG8gc3RyaW5nIGhhcyBlc2NhcGVkIGNoYXJhY3RlcnMgaW4gaXQuXG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gIH1cblxuICBpZiAoIXBvc3NpYmxlLnRlc3Qoc3RyaW5nKSkgeyByZXR1cm4gc3RyaW5nOyB9XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShiYWRDaGFycywgZXNjYXBlQ2hhcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyYW1lKG9iamVjdCkge1xuICBsZXQgZnJhbWUgPSBleHRlbmQoe30sIG9iamVjdCk7XG4gIGZyYW1lLl9wYXJlbnQgPSBvYmplY3Q7XG4gIHJldHVybiBmcmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJsb2NrUGFyYW1zKHBhcmFtcywgaWRzKSB7XG4gIHBhcmFtcy5wYXRoID0gaWRzO1xuICByZXR1cm4gcGFyYW1zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kQ29udGV4dFBhdGgoY29udGV4dFBhdGgsIGlkKSB7XG4gIHJldHVybiAoY29udGV4dFBhdGggPyBjb250ZXh0UGF0aCArICcuJyA6ICcnKSArIGlkO1xufVxuIl19


/***/ },
/* 340 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	
	var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];
	
	function Exception(message, node) {
	  var loc = node && node.loc,
	      line = undefined,
	      column = undefined;
	  if (loc) {
	    line = loc.start.line;
	    column = loc.start.column;
	
	    message += ' - ' + line + ':' + column;
	  }
	
	  var tmp = Error.prototype.constructor.call(this, message);
	
	  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
	  for (var idx = 0; idx < errorProps.length; idx++) {
	    this[errorProps[idx]] = tmp[errorProps[idx]];
	  }
	
	  /* istanbul ignore else */
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, Exception);
	  }
	
	  try {
	    if (loc) {
	      this.lineNumber = line;
	
	      // Work around issue under safari where we can't directly set the column value
	      /* istanbul ignore next */
	      if (Object.defineProperty) {
	        Object.defineProperty(this, 'column', { value: column });
	      } else {
	        this.column = column;
	      }
	    }
	  } catch (nop) {
	    /* Ignore if the browser is very particular */
	  }
	}
	
	Exception.prototype = new Error();
	
	exports['default'] = Exception;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2V4Y2VwdGlvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQ0EsSUFBTSxVQUFVLEdBQUcsQ0FBQyxhQUFhLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQzs7QUFFbkcsU0FBUyxTQUFTLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRTtBQUNoQyxNQUFJLEdBQUcsR0FBRyxJQUFJLElBQUksSUFBSSxDQUFDLEdBQUc7TUFDdEIsSUFBSSxZQUFBO01BQ0osTUFBTSxZQUFBLENBQUM7QUFDWCxNQUFJLEdBQUcsRUFBRTtBQUNQLFFBQUksR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQztBQUN0QixVQUFNLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7O0FBRTFCLFdBQU8sSUFBSSxLQUFLLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUM7R0FDeEM7O0FBRUQsTUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQzs7O0FBRzFELE9BQUssSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxVQUFVLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQ2hELFFBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7R0FDOUM7OztBQUdELE1BQUksS0FBSyxDQUFDLGlCQUFpQixFQUFFO0FBQzNCLFNBQUssQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7R0FDMUM7O0FBRUQsTUFBSTtBQUNGLFFBQUksR0FBRyxFQUFFO0FBQ1AsVUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7Ozs7QUFJdkIsVUFBSSxNQUFNLENBQUMsY0FBYyxFQUFFO0FBQ3pCLGNBQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxFQUFDLEtBQUssRUFBRSxNQUFNLEVBQUMsQ0FBQyxDQUFDO09BQ3hELE1BQU07QUFDTCxZQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztPQUN0QjtLQUNGO0dBQ0YsQ0FBQyxPQUFPLEdBQUcsRUFBRTs7R0FFYjtDQUNGOztBQUVELFNBQVMsQ0FBQyxTQUFTLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQzs7cUJBRW5CLFNBQVMiLCJmaWxlIjoiZXhjZXB0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5jb25zdCBlcnJvclByb3BzID0gWydkZXNjcmlwdGlvbicsICdmaWxlTmFtZScsICdsaW5lTnVtYmVyJywgJ21lc3NhZ2UnLCAnbmFtZScsICdudW1iZXInLCAnc3RhY2snXTtcblxuZnVuY3Rpb24gRXhjZXB0aW9uKG1lc3NhZ2UsIG5vZGUpIHtcbiAgbGV0IGxvYyA9IG5vZGUgJiYgbm9kZS5sb2MsXG4gICAgICBsaW5lLFxuICAgICAgY29sdW1uO1xuICBpZiAobG9jKSB7XG4gICAgbGluZSA9IGxvYy5zdGFydC5saW5lO1xuICAgIGNvbHVtbiA9IGxvYy5zdGFydC5jb2x1bW47XG5cbiAgICBtZXNzYWdlICs9ICcgLSAnICsgbGluZSArICc6JyArIGNvbHVtbjtcbiAgfVxuXG4gIGxldCB0bXAgPSBFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuICAvLyBVbmZvcnR1bmF0ZWx5IGVycm9ycyBhcmUgbm90IGVudW1lcmFibGUgaW4gQ2hyb21lIChhdCBsZWFzdCksIHNvIGBmb3IgcHJvcCBpbiB0bXBgIGRvZXNuJ3Qgd29yay5cbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgZXJyb3JQcm9wcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdGhpc1tlcnJvclByb3BzW2lkeF1dID0gdG1wW2Vycm9yUHJvcHNbaWR4XV07XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBFeGNlcHRpb24pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAobG9jKSB7XG4gICAgICB0aGlzLmxpbmVOdW1iZXIgPSBsaW5lO1xuXG4gICAgICAvLyBXb3JrIGFyb3VuZCBpc3N1ZSB1bmRlciBzYWZhcmkgd2hlcmUgd2UgY2FuJ3QgZGlyZWN0bHkgc2V0IHRoZSBjb2x1bW4gdmFsdWVcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29sdW1uJywge3ZhbHVlOiBjb2x1bW59KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAobm9wKSB7XG4gICAgLyogSWdub3JlIGlmIHRoZSBicm93c2VyIGlzIHZlcnkgcGFydGljdWxhciAqL1xuICB9XG59XG5cbkV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblxuZXhwb3J0IGRlZmF1bHQgRXhjZXB0aW9uO1xuIl19


/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.registerDefaultHelpers = registerDefaultHelpers;
	// istanbul ignore next
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _helpersBlockHelperMissing = __webpack_require__(342);
	
	var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
	
	var _helpersEach = __webpack_require__(343);
	
	var _helpersEach2 = _interopRequireDefault(_helpersEach);
	
	var _helpersHelperMissing = __webpack_require__(344);
	
	var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
	
	var _helpersIf = __webpack_require__(345);
	
	var _helpersIf2 = _interopRequireDefault(_helpersIf);
	
	var _helpersLog = __webpack_require__(346);
	
	var _helpersLog2 = _interopRequireDefault(_helpersLog);
	
	var _helpersLookup = __webpack_require__(347);
	
	var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
	
	var _helpersWith = __webpack_require__(348);
	
	var _helpersWith2 = _interopRequireDefault(_helpersWith);
	
	function registerDefaultHelpers(instance) {
	  _helpersBlockHelperMissing2['default'](instance);
	  _helpersEach2['default'](instance);
	  _helpersHelperMissing2['default'](instance);
	  _helpersIf2['default'](instance);
	  _helpersLog2['default'](instance);
	  _helpersLookup2['default'](instance);
	  _helpersWith2['default'](instance);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7eUNBQXVDLGdDQUFnQzs7OzsyQkFDOUMsZ0JBQWdCOzs7O29DQUNQLDBCQUEwQjs7Ozt5QkFDckMsY0FBYzs7OzswQkFDYixlQUFlOzs7OzZCQUNaLGtCQUFrQjs7OzsyQkFDcEIsZ0JBQWdCOzs7O0FBRWxDLFNBQVMsc0JBQXNCLENBQUMsUUFBUSxFQUFFO0FBQy9DLHlDQUEyQixRQUFRLENBQUMsQ0FBQztBQUNyQywyQkFBYSxRQUFRLENBQUMsQ0FBQztBQUN2QixvQ0FBc0IsUUFBUSxDQUFDLENBQUM7QUFDaEMseUJBQVcsUUFBUSxDQUFDLENBQUM7QUFDckIsMEJBQVksUUFBUSxDQUFDLENBQUM7QUFDdEIsNkJBQWUsUUFBUSxDQUFDLENBQUM7QUFDekIsMkJBQWEsUUFBUSxDQUFDLENBQUM7Q0FDeEIiLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCByZWdpc3RlckJsb2NrSGVscGVyTWlzc2luZyBmcm9tICcuL2hlbHBlcnMvYmxvY2staGVscGVyLW1pc3NpbmcnO1xuaW1wb3J0IHJlZ2lzdGVyRWFjaCBmcm9tICcuL2hlbHBlcnMvZWFjaCc7XG5pbXBvcnQgcmVnaXN0ZXJIZWxwZXJNaXNzaW5nIGZyb20gJy4vaGVscGVycy9oZWxwZXItbWlzc2luZyc7XG5pbXBvcnQgcmVnaXN0ZXJJZiBmcm9tICcuL2hlbHBlcnMvaWYnO1xuaW1wb3J0IHJlZ2lzdGVyTG9nIGZyb20gJy4vaGVscGVycy9sb2cnO1xuaW1wb3J0IHJlZ2lzdGVyTG9va3VwIGZyb20gJy4vaGVscGVycy9sb29rdXAnO1xuaW1wb3J0IHJlZ2lzdGVyV2l0aCBmcm9tICcuL2hlbHBlcnMvd2l0aCc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHRIZWxwZXJzKGluc3RhbmNlKSB7XG4gIHJlZ2lzdGVyQmxvY2tIZWxwZXJNaXNzaW5nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJFYWNoKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJIZWxwZXJNaXNzaW5nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJJZihpbnN0YW5jZSk7XG4gIHJlZ2lzdGVyTG9nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJMb29rdXAoaW5zdGFuY2UpO1xuICByZWdpc3RlcldpdGgoaW5zdGFuY2UpO1xufVxuIl19


/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _utils = __webpack_require__(339);
	
	exports['default'] = function (instance) {
	  instance.registerHelper('blockHelperMissing', function (context, options) {
	    var inverse = options.inverse,
	        fn = options.fn;
	
	    if (context === true) {
	      return fn(this);
	    } else if (context === false || context == null) {
	      return inverse(this);
	    } else if (_utils.isArray(context)) {
	      if (context.length > 0) {
	        if (options.ids) {
	          options.ids = [options.name];
	        }
	
	        return instance.helpers.each(context, options);
	      } else {
	        return inverse(this);
	      }
	    } else {
	      if (options.data && options.ids) {
	        var data = _utils.createFrame(options.data);
	        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
	        options = { data: data };
	      }
	
	      return fn(context, options);
	    }
	  });
	};
	
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvYmxvY2staGVscGVyLW1pc3NpbmcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztxQkFBc0QsVUFBVTs7cUJBRWpELFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsb0JBQW9CLEVBQUUsVUFBUyxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3ZFLFFBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPO1FBQ3pCLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDOztBQUVwQixRQUFJLE9BQU8sS0FBSyxJQUFJLEVBQUU7QUFDcEIsYUFBTyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDakIsTUFBTSxJQUFJLE9BQU8sS0FBSyxLQUFLLElBQUksT0FBTyxJQUFJLElBQUksRUFBRTtBQUMvQyxhQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUN0QixNQUFNLElBQUksZUFBUSxPQUFPLENBQUMsRUFBRTtBQUMzQixVQUFJLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO0FBQ3RCLFlBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUNmLGlCQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzlCOztBQUVELGVBQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO09BQ2hELE1BQU07QUFDTCxlQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztPQUN0QjtLQUNGLE1BQU07QUFDTCxVQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUMvQixZQUFJLElBQUksR0FBRyxtQkFBWSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDckMsWUFBSSxDQUFDLFdBQVcsR0FBRyx5QkFBa0IsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzdFLGVBQU8sR0FBRyxFQUFDLElBQUksRUFBRSxJQUFJLEVBQUMsQ0FBQztPQUN4Qjs7QUFFRCxhQUFPLEVBQUUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDN0I7R0FDRixDQUFDLENBQUM7Q0FDSiIsImZpbGUiOiJibG9jay1oZWxwZXItbWlzc2luZy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YXBwZW5kQ29udGV4dFBhdGgsIGNyZWF0ZUZyYW1lLCBpc0FycmF5fSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdibG9ja0hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgbGV0IGludmVyc2UgPSBvcHRpb25zLmludmVyc2UsXG4gICAgICAgIGZuID0gb3B0aW9ucy5mbjtcblxuICAgIGlmIChjb250ZXh0ID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZm4odGhpcyk7XG4gICAgfSBlbHNlIGlmIChjb250ZXh0ID09PSBmYWxzZSB8fCBjb250ZXh0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShjb250ZXh0KSkge1xuICAgICAgaWYgKGNvbnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAob3B0aW9ucy5pZHMpIHtcbiAgICAgICAgICBvcHRpb25zLmlkcyA9IFtvcHRpb25zLm5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLmhlbHBlcnMuZWFjaChjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG4gICAgICAgIGxldCBkYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5uYW1lKTtcbiAgICAgICAgb3B0aW9ucyA9IHtkYXRhOiBkYXRhfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZuKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG59XG4iXX0=


/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	// istanbul ignore next
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _utils = __webpack_require__(339);
	
	var _exception = __webpack_require__(340);
	
	var _exception2 = _interopRequireDefault(_exception);
	
	exports['default'] = function (instance) {
	  instance.registerHelper('each', function (context, options) {
	    if (!options) {
	      throw new _exception2['default']('Must pass iterator to #each');
	    }
	
	    var fn = options.fn,
	        inverse = options.inverse,
	        i = 0,
	        ret = '',
	        data = undefined,
	        contextPath = undefined;
	
	    if (options.data && options.ids) {
	      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
	    }
	
	    if (_utils.isFunction(context)) {
	      context = context.call(this);
	    }
	
	    if (options.data) {
	      data = _utils.createFrame(options.data);
	    }
	
	    function execIteration(field, index, last) {
	      if (data) {
	        data.key = field;
	        data.index = index;
	        data.first = index === 0;
	        data.last = !!last;
	
	        if (contextPath) {
	          data.contextPath = contextPath + field;
	        }
	      }
	
	      ret = ret + fn(context[field], {
	        data: data,
	        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
	      });
	    }
	
	    if (context && typeof context === 'object') {
	      if (_utils.isArray(context)) {
	        for (var j = context.length; i < j; i++) {
	          if (i in context) {
	            execIteration(i, i, i === context.length - 1);
	          }
	        }
	      } else {
	        var priorKey = undefined;
	
	        for (var key in context) {
	          if (context.hasOwnProperty(key)) {
	            // We're running the iterations one step out of sync so we can detect
	            // the last iteration without have to scan the object twice and create
	            // an itermediate keys array.
	            if (priorKey !== undefined) {
	              execIteration(priorKey, i - 1);
	            }
	            priorKey = key;
	            i++;
	          }
	        }
	        if (priorKey !== undefined) {
	          execIteration(priorKey, i - 1, true);
	        }
	      }
	    }
	
	    if (i === 0) {
	      ret = inverse(this);
	    }
	
	    return ret;
	  });
	};
	
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvZWFjaC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O3FCQUErRSxVQUFVOzt5QkFDbkUsY0FBYzs7OztxQkFFckIsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsVUFBUyxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3pELFFBQUksQ0FBQyxPQUFPLEVBQUU7QUFDWixZQUFNLDJCQUFjLDZCQUE2QixDQUFDLENBQUM7S0FDcEQ7O0FBRUQsUUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUU7UUFDZixPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU87UUFDekIsQ0FBQyxHQUFHLENBQUM7UUFDTCxHQUFHLEdBQUcsRUFBRTtRQUNSLElBQUksWUFBQTtRQUNKLFdBQVcsWUFBQSxDQUFDOztBQUVoQixRQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUMvQixpQkFBVyxHQUFHLHlCQUFrQixPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0tBQ2pGOztBQUVELFFBQUksa0JBQVcsT0FBTyxDQUFDLEVBQUU7QUFBRSxhQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUFFOztBQUUxRCxRQUFJLE9BQU8sQ0FBQyxJQUFJLEVBQUU7QUFDaEIsVUFBSSxHQUFHLG1CQUFZLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNsQzs7QUFFRCxhQUFTLGFBQWEsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRTtBQUN6QyxVQUFJLElBQUksRUFBRTtBQUNSLFlBQUksQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDO0FBQ2pCLFlBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ25CLFlBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxLQUFLLENBQUMsQ0FBQztBQUN6QixZQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7O0FBRW5CLFlBQUksV0FBVyxFQUFFO0FBQ2YsY0FBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLEdBQUcsS0FBSyxDQUFDO1NBQ3hDO09BQ0Y7O0FBRUQsU0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQzdCLFlBQUksRUFBRSxJQUFJO0FBQ1YsbUJBQVcsRUFBRSxtQkFBWSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLFdBQVcsR0FBRyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7T0FDL0UsQ0FBQyxDQUFDO0tBQ0o7O0FBRUQsUUFBSSxPQUFPLElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFO0FBQzFDLFVBQUksZUFBUSxPQUFPLENBQUMsRUFBRTtBQUNwQixhQUFLLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN2QyxjQUFJLENBQUMsSUFBSSxPQUFPLEVBQUU7QUFDaEIseUJBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsS0FBSyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1dBQy9DO1NBQ0Y7T0FDRixNQUFNO0FBQ0wsWUFBSSxRQUFRLFlBQUEsQ0FBQzs7QUFFYixhQUFLLElBQUksR0FBRyxJQUFJLE9BQU8sRUFBRTtBQUN2QixjQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUU7Ozs7QUFJL0IsZ0JBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtBQUMxQiwyQkFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDaEM7QUFDRCxvQkFBUSxHQUFHLEdBQUcsQ0FBQztBQUNmLGFBQUMsRUFBRSxDQUFDO1dBQ0w7U0FDRjtBQUNELFlBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtBQUMxQix1QkFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ3RDO09BQ0Y7S0FDRjs7QUFFRCxRQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDWCxTQUFHLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3JCOztBQUVELFdBQU8sR0FBRyxDQUFDO0dBQ1osQ0FBQyxDQUFDO0NBQ0oiLCJmaWxlIjoiZWFjaC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YXBwZW5kQ29udGV4dFBhdGgsIGJsb2NrUGFyYW1zLCBjcmVhdGVGcmFtZSwgaXNBcnJheSwgaXNGdW5jdGlvbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuLi9leGNlcHRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignZWFjaCcsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ011c3QgcGFzcyBpdGVyYXRvciB0byAjZWFjaCcpO1xuICAgIH1cblxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm4sXG4gICAgICAgIGludmVyc2UgPSBvcHRpb25zLmludmVyc2UsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICByZXQgPSAnJyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dFBhdGg7XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG4gICAgICBjb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pICsgJy4nO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRleHQpKSB7IGNvbnRleHQgPSBjb250ZXh0LmNhbGwodGhpcyk7IH1cblxuICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4ZWNJdGVyYXRpb24oZmllbGQsIGluZGV4LCBsYXN0KSB7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhLmtleSA9IGZpZWxkO1xuICAgICAgICBkYXRhLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGRhdGEuZmlyc3QgPSBpbmRleCA9PT0gMDtcbiAgICAgICAgZGF0YS5sYXN0ID0gISFsYXN0O1xuXG4gICAgICAgIGlmIChjb250ZXh0UGF0aCkge1xuICAgICAgICAgIGRhdGEuY29udGV4dFBhdGggPSBjb250ZXh0UGF0aCArIGZpZWxkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldCA9IHJldCArIGZuKGNvbnRleHRbZmllbGRdLCB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyhbY29udGV4dFtmaWVsZF0sIGZpZWxkXSwgW2NvbnRleHRQYXRoICsgZmllbGQsIG51bGxdKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoaXNBcnJheShjb250ZXh0KSkge1xuICAgICAgICBmb3IgKGxldCBqID0gY29udGV4dC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICBpZiAoaSBpbiBjb250ZXh0KSB7XG4gICAgICAgICAgICBleGVjSXRlcmF0aW9uKGksIGksIGkgPT09IGNvbnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcHJpb3JLZXk7XG5cbiAgICAgICAgZm9yIChsZXQga2V5IGluIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBydW5uaW5nIHRoZSBpdGVyYXRpb25zIG9uZSBzdGVwIG91dCBvZiBzeW5jIHNvIHdlIGNhbiBkZXRlY3RcbiAgICAgICAgICAgIC8vIHRoZSBsYXN0IGl0ZXJhdGlvbiB3aXRob3V0IGhhdmUgdG8gc2NhbiB0aGUgb2JqZWN0IHR3aWNlIGFuZCBjcmVhdGVcbiAgICAgICAgICAgIC8vIGFuIGl0ZXJtZWRpYXRlIGtleXMgYXJyYXkuXG4gICAgICAgICAgICBpZiAocHJpb3JLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBleGVjSXRlcmF0aW9uKHByaW9yS2V5LCBpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmlvcktleSA9IGtleTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaW9yS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBleGVjSXRlcmF0aW9uKHByaW9yS2V5LCBpIC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgcmV0ID0gaW52ZXJzZSh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cbiJdfQ==


/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	// istanbul ignore next
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _exception = __webpack_require__(340);
	
	var _exception2 = _interopRequireDefault(_exception);
	
	exports['default'] = function (instance) {
	  instance.registerHelper('helperMissing', function () /* [args, ]options */{
	    if (arguments.length === 1) {
	      // A missing field in a {{foo}} construct.
	      return undefined;
	    } else {
	      // Someone is actually trying to call something, blow up.
	      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
	    }
	  });
	};
	
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvaGVscGVyLW1pc3NpbmcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozt5QkFBc0IsY0FBYzs7OztxQkFFckIsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxlQUFlLEVBQUUsaUNBQWdDO0FBQ3ZFLFFBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7O0FBRTFCLGFBQU8sU0FBUyxDQUFDO0tBQ2xCLE1BQU07O0FBRUwsWUFBTSwyQkFBYyxtQkFBbUIsR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7S0FDdkY7R0FDRixDQUFDLENBQUM7Q0FDSiIsImZpbGUiOiJoZWxwZXItbWlzc2luZy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi4vZXhjZXB0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbigvKiBbYXJncywgXW9wdGlvbnMgKi8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gQSBtaXNzaW5nIGZpZWxkIGluIGEge3tmb299fSBjb25zdHJ1Y3QuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTb21lb25lIGlzIGFjdHVhbGx5IHRyeWluZyB0byBjYWxsIHNvbWV0aGluZywgYmxvdyB1cC5cbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ01pc3NpbmcgaGVscGVyOiBcIicgKyBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdLm5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH0pO1xufVxuIl19


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _utils = __webpack_require__(339);
	
	exports['default'] = function (instance) {
	  instance.registerHelper('if', function (conditional, options) {
	    if (_utils.isFunction(conditional)) {
	      conditional = conditional.call(this);
	    }
	
	    // Default behavior is to render the positive path if the value is truthy and not empty.
	    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
	    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
	    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
	      return options.inverse(this);
	    } else {
	      return options.fn(this);
	    }
	  });
	
	  instance.registerHelper('unless', function (conditional, options) {
	    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
	  });
	};
	
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvaWYuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztxQkFBa0MsVUFBVTs7cUJBRTdCLFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLFVBQVMsV0FBVyxFQUFFLE9BQU8sRUFBRTtBQUMzRCxRQUFJLGtCQUFXLFdBQVcsQ0FBQyxFQUFFO0FBQUUsaUJBQVcsR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQUU7Ozs7O0FBS3RFLFFBQUksQUFBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxJQUFJLENBQUMsV0FBVyxJQUFLLGVBQVEsV0FBVyxDQUFDLEVBQUU7QUFDdkUsYUFBTyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzlCLE1BQU07QUFDTCxhQUFPLE9BQU8sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDekI7R0FDRixDQUFDLENBQUM7O0FBRUgsVUFBUSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsVUFBUyxXQUFXLEVBQUUsT0FBTyxFQUFFO0FBQy9ELFdBQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxFQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQztHQUN2SCxDQUFDLENBQUM7Q0FDSiIsImZpbGUiOiJpZi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7aXNFbXB0eSwgaXNGdW5jdGlvbn0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignaWYnLCBmdW5jdGlvbihjb25kaXRpb25hbCwgb3B0aW9ucykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGNvbmRpdGlvbmFsKSkgeyBjb25kaXRpb25hbCA9IGNvbmRpdGlvbmFsLmNhbGwodGhpcyk7IH1cblxuICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgaXMgdG8gcmVuZGVyIHRoZSBwb3NpdGl2ZSBwYXRoIGlmIHRoZSB2YWx1ZSBpcyB0cnV0aHkgYW5kIG5vdCBlbXB0eS5cbiAgICAvLyBUaGUgYGluY2x1ZGVaZXJvYCBvcHRpb24gbWF5IGJlIHNldCB0byB0cmVhdCB0aGUgY29uZHRpb25hbCBhcyBwdXJlbHkgbm90IGVtcHR5IGJhc2VkIG9uIHRoZVxuICAgIC8vIGJlaGF2aW9yIG9mIGlzRW1wdHkuIEVmZmVjdGl2ZWx5IHRoaXMgZGV0ZXJtaW5lcyBpZiAwIGlzIGhhbmRsZWQgYnkgdGhlIHBvc2l0aXZlIHBhdGggb3IgbmVnYXRpdmUuXG4gICAgaWYgKCghb3B0aW9ucy5oYXNoLmluY2x1ZGVaZXJvICYmICFjb25kaXRpb25hbCkgfHwgaXNFbXB0eShjb25kaXRpb25hbCkpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmZuKHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ3VubGVzcycsIGZ1bmN0aW9uKGNvbmRpdGlvbmFsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLmhlbHBlcnNbJ2lmJ10uY2FsbCh0aGlzLCBjb25kaXRpb25hbCwge2ZuOiBvcHRpb25zLmludmVyc2UsIGludmVyc2U6IG9wdGlvbnMuZm4sIGhhc2g6IG9wdGlvbnMuaGFzaH0pO1xuICB9KTtcbn1cbiJdfQ==


/***/ },
/* 346 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	
	exports['default'] = function (instance) {
	  instance.registerHelper('log', function () /* message, options */{
	    var args = [undefined],
	        options = arguments[arguments.length - 1];
	    for (var i = 0; i < arguments.length - 1; i++) {
	      args.push(arguments[i]);
	    }
	
	    var level = 1;
	    if (options.hash.level != null) {
	      level = options.hash.level;
	    } else if (options.data && options.data.level != null) {
	      level = options.data.level;
	    }
	    args[0] = level;
	
	    instance.log.apply(instance, args);
	  });
	};
	
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvbG9nLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7cUJBQWUsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsa0NBQWlDO0FBQzlELFFBQUksSUFBSSxHQUFHLENBQUMsU0FBUyxDQUFDO1FBQ2xCLE9BQU8sR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztBQUM5QyxTQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDN0MsVUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUN6Qjs7QUFFRCxRQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDZCxRQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksRUFBRTtBQUM5QixXQUFLLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7S0FDNUIsTUFBTSxJQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxFQUFFO0FBQ3JELFdBQUssR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztLQUM1QjtBQUNELFFBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7O0FBRWhCLFlBQVEsQ0FBQyxHQUFHLE1BQUEsQ0FBWixRQUFRLEVBQVMsSUFBSSxDQUFDLENBQUM7R0FDeEIsQ0FBQyxDQUFDO0NBQ0oiLCJmaWxlIjoibG9nLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvZycsIGZ1bmN0aW9uKC8qIG1lc3NhZ2UsIG9wdGlvbnMgKi8pIHtcbiAgICBsZXQgYXJncyA9IFt1bmRlZmluZWRdLFxuICAgICAgICBvcHRpb25zID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIGxldCBsZXZlbCA9IDE7XG4gICAgaWYgKG9wdGlvbnMuaGFzaC5sZXZlbCAhPSBudWxsKSB7XG4gICAgICBsZXZlbCA9IG9wdGlvbnMuaGFzaC5sZXZlbDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmRhdGEubGV2ZWwgIT0gbnVsbCkge1xuICAgICAgbGV2ZWwgPSBvcHRpb25zLmRhdGEubGV2ZWw7XG4gICAgfVxuICAgIGFyZ3NbMF0gPSBsZXZlbDtcblxuICAgIGluc3RhbmNlLmxvZyguLi4gYXJncyk7XG4gIH0pO1xufVxuIl19


/***/ },
/* 347 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	
	exports['default'] = function (instance) {
	  instance.registerHelper('lookup', function (obj, field) {
	    return obj && obj[field];
	  });
	};
	
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvbG9va3VwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7cUJBQWUsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsVUFBUyxHQUFHLEVBQUUsS0FBSyxFQUFFO0FBQ3JELFdBQU8sR0FBRyxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztHQUMxQixDQUFDLENBQUM7Q0FDSiIsImZpbGUiOiJsb29rdXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignbG9va3VwJywgZnVuY3Rpb24ob2JqLCBmaWVsZCkge1xuICAgIHJldHVybiBvYmogJiYgb2JqW2ZpZWxkXTtcbiAgfSk7XG59XG4iXX0=


/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _utils = __webpack_require__(339);
	
	exports['default'] = function (instance) {
	  instance.registerHelper('with', function (context, options) {
	    if (_utils.isFunction(context)) {
	      context = context.call(this);
	    }
	
	    var fn = options.fn;
	
	    if (!_utils.isEmpty(context)) {
	      var data = options.data;
	      if (options.data && options.ids) {
	        data = _utils.createFrame(options.data);
	        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
	      }
	
	      return fn(context, {
	        data: data,
	        blockParams: _utils.blockParams([context], [data && data.contextPath])
	      });
	    } else {
	      return options.inverse(this);
	    }
	  });
	};
	
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvd2l0aC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O3FCQUErRSxVQUFVOztxQkFFMUUsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsVUFBUyxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3pELFFBQUksa0JBQVcsT0FBTyxDQUFDLEVBQUU7QUFBRSxhQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUFFOztBQUUxRCxRQUFJLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDOztBQUVwQixRQUFJLENBQUMsZUFBUSxPQUFPLENBQUMsRUFBRTtBQUNyQixVQUFJLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDO0FBQ3hCLFVBQUksT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO0FBQy9CLFlBQUksR0FBRyxtQkFBWSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDakMsWUFBSSxDQUFDLFdBQVcsR0FBRyx5QkFBa0IsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO09BQ2hGOztBQUVELGFBQU8sRUFBRSxDQUFDLE9BQU8sRUFBRTtBQUNqQixZQUFJLEVBQUUsSUFBSTtBQUNWLG1CQUFXLEVBQUUsbUJBQVksQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7T0FDaEUsQ0FBQyxDQUFDO0tBQ0osTUFBTTtBQUNMLGFBQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUM5QjtHQUNGLENBQUMsQ0FBQztDQUNKIiwiZmlsZSI6IndpdGguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2FwcGVuZENvbnRleHRQYXRoLCBibG9ja1BhcmFtcywgY3JlYXRlRnJhbWUsIGlzRW1wdHksIGlzRnVuY3Rpb259IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ3dpdGgnLCBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oY29udGV4dCkpIHsgY29udGV4dCA9IGNvbnRleHQuY2FsbCh0aGlzKTsgfVxuXG4gICAgbGV0IGZuID0gb3B0aW9ucy5mbjtcblxuICAgIGlmICghaXNFbXB0eShjb250ZXh0KSkge1xuICAgICAgbGV0IGRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG4gICAgICAgIGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLmlkc1swXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbihjb250ZXh0LCB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyhbY29udGV4dF0sIFtkYXRhICYmIGRhdGEuY29udGV4dFBhdGhdKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgfVxuICB9KTtcbn1cbiJdfQ==


/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.registerDefaultDecorators = registerDefaultDecorators;
	// istanbul ignore next
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _decoratorsInline = __webpack_require__(350);
	
	var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
	
	function registerDefaultDecorators(instance) {
	  _decoratorsInline2['default'](instance);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2RlY29yYXRvcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Z0NBQTJCLHFCQUFxQjs7OztBQUV6QyxTQUFTLHlCQUF5QixDQUFDLFFBQVEsRUFBRTtBQUNsRCxnQ0FBZSxRQUFRLENBQUMsQ0FBQztDQUMxQiIsImZpbGUiOiJkZWNvcmF0b3JzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJlZ2lzdGVySW5saW5lIGZyb20gJy4vZGVjb3JhdG9ycy9pbmxpbmUnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0RGVjb3JhdG9ycyhpbnN0YW5jZSkge1xuICByZWdpc3RlcklubGluZShpbnN0YW5jZSk7XG59XG5cbiJdfQ==


/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _utils = __webpack_require__(339);
	
	exports['default'] = function (instance) {
	  instance.registerDecorator('inline', function (fn, props, container, options) {
	    var ret = fn;
	    if (!props.partials) {
	      props.partials = {};
	      ret = function (context, options) {
	        // Create a new partials stack frame prior to exec.
	        var original = container.partials;
	        container.partials = _utils.extend({}, original, props.partials);
	        var ret = fn(context, options);
	        container.partials = original;
	        return ret;
	      };
	    }
	
	    props.partials[options.args[0]] = options.fn;
	
	    return ret;
	  });
	};
	
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2RlY29yYXRvcnMvaW5saW5lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7cUJBQXFCLFVBQVU7O3FCQUVoQixVQUFTLFFBQVEsRUFBRTtBQUNoQyxVQUFRLENBQUMsaUJBQWlCLENBQUMsUUFBUSxFQUFFLFVBQVMsRUFBRSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFO0FBQzNFLFFBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNiLFFBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFO0FBQ25CLFdBQUssQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO0FBQ3BCLFNBQUcsR0FBRyxVQUFTLE9BQU8sRUFBRSxPQUFPLEVBQUU7O0FBRS9CLFlBQUksUUFBUSxHQUFHLFNBQVMsQ0FBQyxRQUFRLENBQUM7QUFDbEMsaUJBQVMsQ0FBQyxRQUFRLEdBQUcsY0FBTyxFQUFFLEVBQUUsUUFBUSxFQUFFLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUMxRCxZQUFJLEdBQUcsR0FBRyxFQUFFLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQy9CLGlCQUFTLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztBQUM5QixlQUFPLEdBQUcsQ0FBQztPQUNaLENBQUM7S0FDSDs7QUFFRCxTQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDOztBQUU3QyxXQUFPLEdBQUcsQ0FBQztHQUNaLENBQUMsQ0FBQztDQUNKIiwiZmlsZSI6ImlubGluZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVyRGVjb3JhdG9yKCdpbmxpbmUnLCBmdW5jdGlvbihmbiwgcHJvcHMsIGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgIGxldCByZXQgPSBmbjtcbiAgICBpZiAoIXByb3BzLnBhcnRpYWxzKSB7XG4gICAgICBwcm9wcy5wYXJ0aWFscyA9IHt9O1xuICAgICAgcmV0ID0gZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgcGFydGlhbHMgc3RhY2sgZnJhbWUgcHJpb3IgdG8gZXhlYy5cbiAgICAgICAgbGV0IG9yaWdpbmFsID0gY29udGFpbmVyLnBhcnRpYWxzO1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBleHRlbmQoe30sIG9yaWdpbmFsLCBwcm9wcy5wYXJ0aWFscyk7XG4gICAgICAgIGxldCByZXQgPSBmbihjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gb3JpZ2luYWw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHByb3BzLnBhcnRpYWxzW29wdGlvbnMuYXJnc1swXV0gPSBvcHRpb25zLmZuO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG4iXX0=


/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _utils = __webpack_require__(339);
	
	var logger = {
	  methodMap: ['debug', 'info', 'warn', 'error'],
	  level: 'info',
	
	  // Maps a given level value to the `methodMap` indexes above.
	  lookupLevel: function lookupLevel(level) {
	    if (typeof level === 'string') {
	      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
	      if (levelMap >= 0) {
	        level = levelMap;
	      } else {
	        level = parseInt(level, 10);
	      }
	    }
	
	    return level;
	  },
	
	  // Can be overridden in the host environment
	  log: function log(level) {
	    level = logger.lookupLevel(level);
	
	    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
	      var method = logger.methodMap[level];
	      if (!console[method]) {
	        // eslint-disable-line no-console
	        method = 'log';
	      }
	
	      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        message[_key - 1] = arguments[_key];
	      }
	
	      console[method].apply(console, message); // eslint-disable-line no-console
	    }
	  }
	};
	
	exports['default'] = logger;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2xvZ2dlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O3FCQUFzQixTQUFTOztBQUUvQixJQUFJLE1BQU0sR0FBRztBQUNYLFdBQVMsRUFBRSxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQztBQUM3QyxPQUFLLEVBQUUsTUFBTTs7O0FBR2IsYUFBVyxFQUFFLHFCQUFTLEtBQUssRUFBRTtBQUMzQixRQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtBQUM3QixVQUFJLFFBQVEsR0FBRyxlQUFRLE1BQU0sQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7QUFDOUQsVUFBSSxRQUFRLElBQUksQ0FBQyxFQUFFO0FBQ2pCLGFBQUssR0FBRyxRQUFRLENBQUM7T0FDbEIsTUFBTTtBQUNMLGFBQUssR0FBRyxRQUFRLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO09BQzdCO0tBQ0Y7O0FBRUQsV0FBTyxLQUFLLENBQUM7R0FDZDs7O0FBR0QsS0FBRyxFQUFFLGFBQVMsS0FBSyxFQUFjO0FBQy9CLFNBQUssR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDOztBQUVsQyxRQUFJLE9BQU8sT0FBTyxLQUFLLFdBQVcsSUFBSSxNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLEVBQUU7QUFDL0UsVUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNyQyxVQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFOztBQUNwQixjQUFNLEdBQUcsS0FBSyxDQUFDO09BQ2hCOzt3Q0FQbUIsT0FBTztBQUFQLGVBQU87OztBQVEzQixhQUFPLENBQUMsTUFBTSxPQUFDLENBQWYsT0FBTyxFQUFZLE9BQU8sQ0FBQyxDQUFDO0tBQzdCO0dBQ0Y7Q0FDRixDQUFDOztxQkFFYSxNQUFNIiwiZmlsZSI6ImxvZ2dlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7aW5kZXhPZn0gZnJvbSAnLi91dGlscyc7XG5cbmxldCBsb2dnZXIgPSB7XG4gIG1ldGhvZE1hcDogWydkZWJ1ZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InXSxcbiAgbGV2ZWw6ICdpbmZvJyxcblxuICAvLyBNYXBzIGEgZ2l2ZW4gbGV2ZWwgdmFsdWUgdG8gdGhlIGBtZXRob2RNYXBgIGluZGV4ZXMgYWJvdmUuXG4gIGxvb2t1cExldmVsOiBmdW5jdGlvbihsZXZlbCkge1xuICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgbGV2ZWxNYXAgPSBpbmRleE9mKGxvZ2dlci5tZXRob2RNYXAsIGxldmVsLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKGxldmVsTWFwID49IDApIHtcbiAgICAgICAgbGV2ZWwgPSBsZXZlbE1hcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsID0gcGFyc2VJbnQobGV2ZWwsIDEwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGV2ZWw7XG4gIH0sXG5cbiAgLy8gQ2FuIGJlIG92ZXJyaWRkZW4gaW4gdGhlIGhvc3QgZW52aXJvbm1lbnRcbiAgbG9nOiBmdW5jdGlvbihsZXZlbCwgLi4ubWVzc2FnZSkge1xuICAgIGxldmVsID0gbG9nZ2VyLmxvb2t1cExldmVsKGxldmVsKTtcblxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbG9nZ2VyLmxvb2t1cExldmVsKGxvZ2dlci5sZXZlbCkgPD0gbGV2ZWwpIHtcbiAgICAgIGxldCBtZXRob2QgPSBsb2dnZXIubWV0aG9kTWFwW2xldmVsXTtcbiAgICAgIGlmICghY29uc29sZVttZXRob2RdKSB7ICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgIG1ldGhvZCA9ICdsb2cnO1xuICAgICAgfVxuICAgICAgY29uc29sZVttZXRob2RdKC4uLm1lc3NhZ2UpOyAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGxvZ2dlcjtcbiJdfQ==


/***/ },
/* 352 */
/***/ function(module, exports) {

	// Build out our basic SafeString type
	'use strict';
	
	exports.__esModule = true;
	function SafeString(string) {
	  this.string = string;
	}
	
	SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
	  return '' + this.string;
	};
	
	exports['default'] = SafeString;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL3NhZmUtc3RyaW5nLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFDQSxTQUFTLFVBQVUsQ0FBQyxNQUFNLEVBQUU7QUFDMUIsTUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7Q0FDdEI7O0FBRUQsVUFBVSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsWUFBVztBQUN2RSxTQUFPLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO0NBQ3pCLENBQUM7O3FCQUVhLFVBQVUiLCJmaWxlIjoic2FmZS1zdHJpbmcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBCdWlsZCBvdXQgb3VyIGJhc2ljIFNhZmVTdHJpbmcgdHlwZVxuZnVuY3Rpb24gU2FmZVN0cmluZyhzdHJpbmcpIHtcbiAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG59XG5cblNhZmVTdHJpbmcucHJvdG90eXBlLnRvU3RyaW5nID0gU2FmZVN0cmluZy5wcm90b3R5cGUudG9IVE1MID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnJyArIHRoaXMuc3RyaW5nO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgU2FmZVN0cmluZztcbiJdfQ==


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.checkRevision = checkRevision;
	exports.template = template;
	exports.wrapProgram = wrapProgram;
	exports.resolvePartial = resolvePartial;
	exports.invokePartial = invokePartial;
	exports.noop = noop;
	// istanbul ignore next
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	// istanbul ignore next
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }
	
	var _utils = __webpack_require__(339);
	
	var Utils = _interopRequireWildcard(_utils);
	
	var _exception = __webpack_require__(340);
	
	var _exception2 = _interopRequireDefault(_exception);
	
	var _base = __webpack_require__(338);
	
	function checkRevision(compilerInfo) {
	  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
	      currentRevision = _base.COMPILER_REVISION;
	
	  if (compilerRevision !== currentRevision) {
	    if (compilerRevision < currentRevision) {
	      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
	          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
	      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
	    } else {
	      // Use the embedded version info since the runtime doesn't know about this revision yet
	      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
	    }
	  }
	}
	
	function template(templateSpec, env) {
	  /* istanbul ignore next */
	  if (!env) {
	    throw new _exception2['default']('No environment passed to template');
	  }
	  if (!templateSpec || !templateSpec.main) {
	    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
	  }
	
	  templateSpec.main.decorator = templateSpec.main_d;
	
	  // Note: Using env.VM references rather than local var references throughout this section to allow
	  // for external users to override these as psuedo-supported APIs.
	  env.VM.checkRevision(templateSpec.compiler);
	
	  function invokePartialWrapper(partial, context, options) {
	    if (options.hash) {
	      context = Utils.extend({}, context, options.hash);
	      if (options.ids) {
	        options.ids[0] = true;
	      }
	    }
	
	    partial = env.VM.resolvePartial.call(this, partial, context, options);
	    var result = env.VM.invokePartial.call(this, partial, context, options);
	
	    if (result == null && env.compile) {
	      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
	      result = options.partials[options.name](context, options);
	    }
	    if (result != null) {
	      if (options.indent) {
	        var lines = result.split('\n');
	        for (var i = 0, l = lines.length; i < l; i++) {
	          if (!lines[i] && i + 1 === l) {
	            break;
	          }
	
	          lines[i] = options.indent + lines[i];
	        }
	        result = lines.join('\n');
	      }
	      return result;
	    } else {
	      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
	    }
	  }
	
	  // Just add water
	  var container = {
	    strict: function strict(obj, name) {
	      if (!(name in obj)) {
	        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
	      }
	      return obj[name];
	    },
	    lookup: function lookup(depths, name) {
	      var len = depths.length;
	      for (var i = 0; i < len; i++) {
	        if (depths[i] && depths[i][name] != null) {
	          return depths[i][name];
	        }
	      }
	    },
	    lambda: function lambda(current, context) {
	      return typeof current === 'function' ? current.call(context) : current;
	    },
	
	    escapeExpression: Utils.escapeExpression,
	    invokePartial: invokePartialWrapper,
	
	    fn: function fn(i) {
	      var ret = templateSpec[i];
	      ret.decorator = templateSpec[i + '_d'];
	      return ret;
	    },
	
	    programs: [],
	    program: function program(i, data, declaredBlockParams, blockParams, depths) {
	      var programWrapper = this.programs[i],
	          fn = this.fn(i);
	      if (data || depths || blockParams || declaredBlockParams) {
	        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
	      } else if (!programWrapper) {
	        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
	      }
	      return programWrapper;
	    },
	
	    data: function data(value, depth) {
	      while (value && depth--) {
	        value = value._parent;
	      }
	      return value;
	    },
	    merge: function merge(param, common) {
	      var obj = param || common;
	
	      if (param && common && param !== common) {
	        obj = Utils.extend({}, common, param);
	      }
	
	      return obj;
	    },
	
	    noop: env.VM.noop,
	    compilerInfo: templateSpec.compiler
	  };
	
	  function ret(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	    var data = options.data;
	
	    ret._setup(options);
	    if (!options.partial && templateSpec.useData) {
	      data = initData(context, data);
	    }
	    var depths = undefined,
	        blockParams = templateSpec.useBlockParams ? [] : undefined;
	    if (templateSpec.useDepths) {
	      if (options.depths) {
	        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
	      } else {
	        depths = [context];
	      }
	    }
	
	    function main(context /*, options*/) {
	      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
	    }
	    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
	    return main(context, options);
	  }
	  ret.isTop = true;
	
	  ret._setup = function (options) {
	    if (!options.partial) {
	      container.helpers = container.merge(options.helpers, env.helpers);
	
	      if (templateSpec.usePartial) {
	        container.partials = container.merge(options.partials, env.partials);
	      }
	      if (templateSpec.usePartial || templateSpec.useDecorators) {
	        container.decorators = container.merge(options.decorators, env.decorators);
	      }
	    } else {
	      container.helpers = options.helpers;
	      container.partials = options.partials;
	      container.decorators = options.decorators;
	    }
	  };
	
	  ret._child = function (i, data, blockParams, depths) {
	    if (templateSpec.useBlockParams && !blockParams) {
	      throw new _exception2['default']('must pass block params');
	    }
	    if (templateSpec.useDepths && !depths) {
	      throw new _exception2['default']('must pass parent depths');
	    }
	
	    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
	  };
	  return ret;
	}
	
	function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
	  function prog(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	    var currentDepths = depths;
	    if (depths && context != depths[0]) {
	      currentDepths = [context].concat(depths);
	    }
	
	    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
	  }
	
	  prog = executeDecorators(fn, prog, container, depths, data, blockParams);
	
	  prog.program = i;
	  prog.depth = depths ? depths.length : 0;
	  prog.blockParams = declaredBlockParams || 0;
	  return prog;
	}
	
	function resolvePartial(partial, context, options) {
	  if (!partial) {
	    if (options.name === '@partial-block') {
	      var data = options.data;
	      while (data['partial-block'] === noop) {
	        data = data._parent;
	      }
	      partial = data['partial-block'];
	      data['partial-block'] = noop;
	    } else {
	      partial = options.partials[options.name];
	    }
	  } else if (!partial.call && !options.name) {
	    // This is a dynamic partial that returned a string
	    options.name = partial;
	    partial = options.partials[partial];
	  }
	  return partial;
	}
	
	function invokePartial(partial, context, options) {
	  options.partial = true;
	  if (options.ids) {
	    options.data.contextPath = options.ids[0] || options.data.contextPath;
	  }
	
	  var partialBlock = undefined;
	  if (options.fn && options.fn !== noop) {
	    options.data = _base.createFrame(options.data);
	    partialBlock = options.data['partial-block'] = options.fn;
	
	    if (partialBlock.partials) {
	      options.partials = Utils.extend({}, options.partials, partialBlock.partials);
	    }
	  }
	
	  if (partial === undefined && partialBlock) {
	    partial = partialBlock;
	  }
	
	  if (partial === undefined) {
	    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
	  } else if (partial instanceof Function) {
	    return partial(context, options);
	  }
	}
	
	function noop() {
	  return '';
	}
	
	function initData(context, data) {
	  if (!data || !('root' in data)) {
	    data = data ? _base.createFrame(data) : {};
	    data.root = context;
	  }
	  return data;
	}
	
	function executeDecorators(fn, prog, container, depths, data, blockParams) {
	  if (fn.decorator) {
	    var props = {};
	    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
	    Utils.extend(prog, props);
	  }
	  return prog;
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL3J1bnRpbWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7cUJBQXVCLFNBQVM7O0lBQXBCLEtBQUs7O3lCQUNLLGFBQWE7Ozs7b0JBQzhCLFFBQVE7O0FBRWxFLFNBQVMsYUFBYSxDQUFDLFlBQVksRUFBRTtBQUMxQyxNQUFNLGdCQUFnQixHQUFHLFlBQVksSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztNQUN2RCxlQUFlLDBCQUFvQixDQUFDOztBQUUxQyxNQUFJLGdCQUFnQixLQUFLLGVBQWUsRUFBRTtBQUN4QyxRQUFJLGdCQUFnQixHQUFHLGVBQWUsRUFBRTtBQUN0QyxVQUFNLGVBQWUsR0FBRyx1QkFBaUIsZUFBZSxDQUFDO1VBQ25ELGdCQUFnQixHQUFHLHVCQUFpQixnQkFBZ0IsQ0FBQyxDQUFDO0FBQzVELFlBQU0sMkJBQWMseUZBQXlGLEdBQ3ZHLHFEQUFxRCxHQUFHLGVBQWUsR0FBRyxtREFBbUQsR0FBRyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsQ0FBQztLQUNoSyxNQUFNOztBQUVMLFlBQU0sMkJBQWMsd0ZBQXdGLEdBQ3RHLGlEQUFpRCxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztLQUNuRjtHQUNGO0NBQ0Y7O0FBRU0sU0FBUyxRQUFRLENBQUMsWUFBWSxFQUFFLEdBQUcsRUFBRTs7QUFFMUMsTUFBSSxDQUFDLEdBQUcsRUFBRTtBQUNSLFVBQU0sMkJBQWMsbUNBQW1DLENBQUMsQ0FBQztHQUMxRDtBQUNELE1BQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFO0FBQ3ZDLFVBQU0sMkJBQWMsMkJBQTJCLEdBQUcsT0FBTyxZQUFZLENBQUMsQ0FBQztHQUN4RTs7QUFFRCxjQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDOzs7O0FBSWxELEtBQUcsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQzs7QUFFNUMsV0FBUyxvQkFBb0IsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN2RCxRQUFJLE9BQU8sQ0FBQyxJQUFJLEVBQUU7QUFDaEIsYUFBTyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDbEQsVUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO0FBQ2YsZUFBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7T0FDdkI7S0FDRjs7QUFFRCxXQUFPLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3RFLFFBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQzs7QUFFeEUsUUFBSSxNQUFNLElBQUksSUFBSSxJQUFJLEdBQUcsQ0FBQyxPQUFPLEVBQUU7QUFDakMsYUFBTyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLGVBQWUsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUN6RixZQUFNLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0tBQzNEO0FBQ0QsUUFBSSxNQUFNLElBQUksSUFBSSxFQUFFO0FBQ2xCLFVBQUksT0FBTyxDQUFDLE1BQU0sRUFBRTtBQUNsQixZQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQy9CLGFBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDNUMsY0FBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRTtBQUM1QixrQkFBTTtXQUNQOztBQUVELGVBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN0QztBQUNELGNBQU0sR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO09BQzNCO0FBQ0QsYUFBTyxNQUFNLENBQUM7S0FDZixNQUFNO0FBQ0wsWUFBTSwyQkFBYyxjQUFjLEdBQUcsT0FBTyxDQUFDLElBQUksR0FBRywwREFBMEQsQ0FBQyxDQUFDO0tBQ2pIO0dBQ0Y7OztBQUdELE1BQUksU0FBUyxHQUFHO0FBQ2QsVUFBTSxFQUFFLGdCQUFTLEdBQUcsRUFBRSxJQUFJLEVBQUU7QUFDMUIsVUFBSSxFQUFFLElBQUksSUFBSSxHQUFHLENBQUEsQUFBQyxFQUFFO0FBQ2xCLGNBQU0sMkJBQWMsR0FBRyxHQUFHLElBQUksR0FBRyxtQkFBbUIsR0FBRyxHQUFHLENBQUMsQ0FBQztPQUM3RDtBQUNELGFBQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ2xCO0FBQ0QsVUFBTSxFQUFFLGdCQUFTLE1BQU0sRUFBRSxJQUFJLEVBQUU7QUFDN0IsVUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztBQUMxQixXQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzVCLFlBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLEVBQUU7QUFDeEMsaUJBQU8sTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3hCO09BQ0Y7S0FDRjtBQUNELFVBQU0sRUFBRSxnQkFBUyxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ2pDLGFBQU8sT0FBTyxPQUFPLEtBQUssVUFBVSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDO0tBQ3hFOztBQUVELG9CQUFnQixFQUFFLEtBQUssQ0FBQyxnQkFBZ0I7QUFDeEMsaUJBQWEsRUFBRSxvQkFBb0I7O0FBRW5DLE1BQUUsRUFBRSxZQUFTLENBQUMsRUFBRTtBQUNkLFVBQUksR0FBRyxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMxQixTQUFHLENBQUMsU0FBUyxHQUFHLFlBQVksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDdkMsYUFBTyxHQUFHLENBQUM7S0FDWjs7QUFFRCxZQUFRLEVBQUUsRUFBRTtBQUNaLFdBQU8sRUFBRSxpQkFBUyxDQUFDLEVBQUUsSUFBSSxFQUFFLG1CQUFtQixFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUU7QUFDbkUsVUFBSSxjQUFjLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7VUFDakMsRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEIsVUFBSSxJQUFJLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxtQkFBbUIsRUFBRTtBQUN4RCxzQkFBYyxHQUFHLFdBQVcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDO09BQzNGLE1BQU0sSUFBSSxDQUFDLGNBQWMsRUFBRTtBQUMxQixzQkFBYyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7T0FDOUQ7QUFDRCxhQUFPLGNBQWMsQ0FBQztLQUN2Qjs7QUFFRCxRQUFJLEVBQUUsY0FBUyxLQUFLLEVBQUUsS0FBSyxFQUFFO0FBQzNCLGFBQU8sS0FBSyxJQUFJLEtBQUssRUFBRSxFQUFFO0FBQ3ZCLGFBQUssR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDO09BQ3ZCO0FBQ0QsYUFBTyxLQUFLLENBQUM7S0FDZDtBQUNELFNBQUssRUFBRSxlQUFTLEtBQUssRUFBRSxNQUFNLEVBQUU7QUFDN0IsVUFBSSxHQUFHLEdBQUcsS0FBSyxJQUFJLE1BQU0sQ0FBQzs7QUFFMUIsVUFBSSxLQUFLLElBQUksTUFBTSxJQUFLLEtBQUssS0FBSyxNQUFNLEFBQUMsRUFBRTtBQUN6QyxXQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO09BQ3ZDOztBQUVELGFBQU8sR0FBRyxDQUFDO0tBQ1o7O0FBRUQsUUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSTtBQUNqQixnQkFBWSxFQUFFLFlBQVksQ0FBQyxRQUFRO0dBQ3BDLENBQUM7O0FBRUYsV0FBUyxHQUFHLENBQUMsT0FBTyxFQUFnQjtRQUFkLE9BQU8seURBQUcsRUFBRTs7QUFDaEMsUUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQzs7QUFFeEIsT0FBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNwQixRQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sSUFBSSxZQUFZLENBQUMsT0FBTyxFQUFFO0FBQzVDLFVBQUksR0FBRyxRQUFRLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQ2hDO0FBQ0QsUUFBSSxNQUFNLFlBQUE7UUFDTixXQUFXLEdBQUcsWUFBWSxDQUFDLGNBQWMsR0FBRyxFQUFFLEdBQUcsU0FBUyxDQUFDO0FBQy9ELFFBQUksWUFBWSxDQUFDLFNBQVMsRUFBRTtBQUMxQixVQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUU7QUFDbEIsY0FBTSxHQUFHLE9BQU8sSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDO09BQzNGLE1BQU07QUFDTCxjQUFNLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztPQUNwQjtLQUNGOztBQUVELGFBQVMsSUFBSSxDQUFDLE9BQU8sZ0JBQWU7QUFDbEMsYUFBTyxFQUFFLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsT0FBTyxFQUFFLFNBQVMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0tBQ3JIO0FBQ0QsUUFBSSxHQUFHLGlCQUFpQixDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsTUFBTSxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDdEcsV0FBTyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0dBQy9CO0FBQ0QsS0FBRyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7O0FBRWpCLEtBQUcsQ0FBQyxNQUFNLEdBQUcsVUFBUyxPQUFPLEVBQUU7QUFDN0IsUUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUU7QUFDcEIsZUFBUyxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDOztBQUVsRSxVQUFJLFlBQVksQ0FBQyxVQUFVLEVBQUU7QUFDM0IsaUJBQVMsQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztPQUN0RTtBQUNELFVBQUksWUFBWSxDQUFDLFVBQVUsSUFBSSxZQUFZLENBQUMsYUFBYSxFQUFFO0FBQ3pELGlCQUFTLENBQUMsVUFBVSxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7T0FDNUU7S0FDRixNQUFNO0FBQ0wsZUFBUyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDO0FBQ3BDLGVBQVMsQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQztBQUN0QyxlQUFTLENBQUMsVUFBVSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUM7S0FDM0M7R0FDRixDQUFDOztBQUVGLEtBQUcsQ0FBQyxNQUFNLEdBQUcsVUFBUyxDQUFDLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUU7QUFDbEQsUUFBSSxZQUFZLENBQUMsY0FBYyxJQUFJLENBQUMsV0FBVyxFQUFFO0FBQy9DLFlBQU0sMkJBQWMsd0JBQXdCLENBQUMsQ0FBQztLQUMvQztBQUNELFFBQUksWUFBWSxDQUFDLFNBQVMsSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUNyQyxZQUFNLDJCQUFjLHlCQUF5QixDQUFDLENBQUM7S0FDaEQ7O0FBRUQsV0FBTyxXQUFXLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxXQUFXLEVBQUUsTUFBTSxDQUFDLENBQUM7R0FDakYsQ0FBQztBQUNGLFNBQU8sR0FBRyxDQUFDO0NBQ1o7O0FBRU0sU0FBUyxXQUFXLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLG1CQUFtQixFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUU7QUFDNUYsV0FBUyxJQUFJLENBQUMsT0FBTyxFQUFnQjtRQUFkLE9BQU8seURBQUcsRUFBRTs7QUFDakMsUUFBSSxhQUFhLEdBQUcsTUFBTSxDQUFDO0FBQzNCLFFBQUksTUFBTSxJQUFJLE9BQU8sSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUU7QUFDbEMsbUJBQWEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUMxQzs7QUFFRCxXQUFPLEVBQUUsQ0FBQyxTQUFTLEVBQ2YsT0FBTyxFQUNQLFNBQVMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLFFBQVEsRUFDckMsT0FBTyxDQUFDLElBQUksSUFBSSxJQUFJLEVBQ3BCLFdBQVcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEVBQ3hELGFBQWEsQ0FBQyxDQUFDO0dBQ3BCOztBQUVELE1BQUksR0FBRyxpQkFBaUIsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDOztBQUV6RSxNQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQztBQUNqQixNQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUN4QyxNQUFJLENBQUMsV0FBVyxHQUFHLG1CQUFtQixJQUFJLENBQUMsQ0FBQztBQUM1QyxTQUFPLElBQUksQ0FBQztDQUNiOztBQUVNLFNBQVMsY0FBYyxDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3hELE1BQUksQ0FBQyxPQUFPLEVBQUU7QUFDWixRQUFJLE9BQU8sQ0FBQyxJQUFJLEtBQUssZ0JBQWdCLEVBQUU7QUFDckMsVUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQztBQUN4QixhQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxJQUFJLEVBQUU7QUFDckMsWUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7T0FDckI7QUFDRCxhQUFPLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQ2hDLFVBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxJQUFJLENBQUM7S0FDOUIsTUFBTTtBQUNMLGFBQU8sR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUMxQztHQUNGLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFOztBQUV6QyxXQUFPLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQztBQUN2QixXQUFPLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztHQUNyQztBQUNELFNBQU8sT0FBTyxDQUFDO0NBQ2hCOztBQUVNLFNBQVMsYUFBYSxDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3ZELFNBQU8sQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO0FBQ3ZCLE1BQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUNmLFdBQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUM7R0FDdkU7O0FBRUQsTUFBSSxZQUFZLFlBQUEsQ0FBQztBQUNqQixNQUFJLE9BQU8sQ0FBQyxFQUFFLElBQUksT0FBTyxDQUFDLEVBQUUsS0FBSyxJQUFJLEVBQUU7QUFDckMsV0FBTyxDQUFDLElBQUksR0FBRyxrQkFBWSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDekMsZ0JBQVksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUM7O0FBRTFELFFBQUksWUFBWSxDQUFDLFFBQVEsRUFBRTtBQUN6QixhQUFPLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxRQUFRLEVBQUUsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0tBQzlFO0dBQ0Y7O0FBRUQsTUFBSSxPQUFPLEtBQUssU0FBUyxJQUFJLFlBQVksRUFBRTtBQUN6QyxXQUFPLEdBQUcsWUFBWSxDQUFDO0dBQ3hCOztBQUVELE1BQUksT0FBTyxLQUFLLFNBQVMsRUFBRTtBQUN6QixVQUFNLDJCQUFjLGNBQWMsR0FBRyxPQUFPLENBQUMsSUFBSSxHQUFHLHFCQUFxQixDQUFDLENBQUM7R0FDNUUsTUFBTSxJQUFJLE9BQU8sWUFBWSxRQUFRLEVBQUU7QUFDdEMsV0FBTyxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0dBQ2xDO0NBQ0Y7O0FBRU0sU0FBUyxJQUFJLEdBQUc7QUFBRSxTQUFPLEVBQUUsQ0FBQztDQUFFOztBQUVyQyxTQUFTLFFBQVEsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFO0FBQy9CLE1BQUksQ0FBQyxJQUFJLElBQUksRUFBRSxNQUFNLElBQUksSUFBSSxDQUFBLEFBQUMsRUFBRTtBQUM5QixRQUFJLEdBQUcsSUFBSSxHQUFHLGtCQUFZLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNyQyxRQUFJLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQztHQUNyQjtBQUNELFNBQU8sSUFBSSxDQUFDO0NBQ2I7O0FBRUQsU0FBUyxpQkFBaUIsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRTtBQUN6RSxNQUFJLEVBQUUsQ0FBQyxTQUFTLEVBQUU7QUFDaEIsUUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDO0FBQ2YsUUFBSSxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsTUFBTSxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQzVGLFNBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO0dBQzNCO0FBQ0QsU0FBTyxJQUFJLENBQUM7Q0FDYiIsImZpbGUiOiJydW50aW1lLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4vZXhjZXB0aW9uJztcbmltcG9ydCB7IENPTVBJTEVSX1JFVklTSU9OLCBSRVZJU0lPTl9DSEFOR0VTLCBjcmVhdGVGcmFtZSB9IGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1JldmlzaW9uKGNvbXBpbGVySW5mbykge1xuICBjb25zdCBjb21waWxlclJldmlzaW9uID0gY29tcGlsZXJJbmZvICYmIGNvbXBpbGVySW5mb1swXSB8fCAxLFxuICAgICAgICBjdXJyZW50UmV2aXNpb24gPSBDT01QSUxFUl9SRVZJU0lPTjtcblxuICBpZiAoY29tcGlsZXJSZXZpc2lvbiAhPT0gY3VycmVudFJldmlzaW9uKSB7XG4gICAgaWYgKGNvbXBpbGVyUmV2aXNpb24gPCBjdXJyZW50UmV2aXNpb24pIHtcbiAgICAgIGNvbnN0IHJ1bnRpbWVWZXJzaW9ucyA9IFJFVklTSU9OX0NIQU5HRVNbY3VycmVudFJldmlzaW9uXSxcbiAgICAgICAgICAgIGNvbXBpbGVyVmVyc2lvbnMgPSBSRVZJU0lPTl9DSEFOR0VTW2NvbXBpbGVyUmV2aXNpb25dO1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVGVtcGxhdGUgd2FzIHByZWNvbXBpbGVkIHdpdGggYW4gb2xkZXIgdmVyc2lvbiBvZiBIYW5kbGViYXJzIHRoYW4gdGhlIGN1cnJlbnQgcnVudGltZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIHVwZGF0ZSB5b3VyIHByZWNvbXBpbGVyIHRvIGEgbmV3ZXIgdmVyc2lvbiAoJyArIHJ1bnRpbWVWZXJzaW9ucyArICcpIG9yIGRvd25ncmFkZSB5b3VyIHJ1bnRpbWUgdG8gYW4gb2xkZXIgdmVyc2lvbiAoJyArIGNvbXBpbGVyVmVyc2lvbnMgKyAnKS4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXNlIHRoZSBlbWJlZGRlZCB2ZXJzaW9uIGluZm8gc2luY2UgdGhlIHJ1bnRpbWUgZG9lc24ndCBrbm93IGFib3V0IHRoaXMgcmV2aXNpb24geWV0XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdUZW1wbGF0ZSB3YXMgcHJlY29tcGlsZWQgd2l0aCBhIG5ld2VyIHZlcnNpb24gb2YgSGFuZGxlYmFycyB0aGFuIHRoZSBjdXJyZW50IHJ1bnRpbWUuICcgK1xuICAgICAgICAgICAgJ1BsZWFzZSB1cGRhdGUgeW91ciBydW50aW1lIHRvIGEgbmV3ZXIgdmVyc2lvbiAoJyArIGNvbXBpbGVySW5mb1sxXSArICcpLicpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGUodGVtcGxhdGVTcGVjLCBlbnYpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKCFlbnYpIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdObyBlbnZpcm9ubWVudCBwYXNzZWQgdG8gdGVtcGxhdGUnKTtcbiAgfVxuICBpZiAoIXRlbXBsYXRlU3BlYyB8fCAhdGVtcGxhdGVTcGVjLm1haW4pIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdVbmtub3duIHRlbXBsYXRlIG9iamVjdDogJyArIHR5cGVvZiB0ZW1wbGF0ZVNwZWMpO1xuICB9XG5cbiAgdGVtcGxhdGVTcGVjLm1haW4uZGVjb3JhdG9yID0gdGVtcGxhdGVTcGVjLm1haW5fZDtcblxuICAvLyBOb3RlOiBVc2luZyBlbnYuVk0gcmVmZXJlbmNlcyByYXRoZXIgdGhhbiBsb2NhbCB2YXIgcmVmZXJlbmNlcyB0aHJvdWdob3V0IHRoaXMgc2VjdGlvbiB0byBhbGxvd1xuICAvLyBmb3IgZXh0ZXJuYWwgdXNlcnMgdG8gb3ZlcnJpZGUgdGhlc2UgYXMgcHN1ZWRvLXN1cHBvcnRlZCBBUElzLlxuICBlbnYuVk0uY2hlY2tSZXZpc2lvbih0ZW1wbGF0ZVNwZWMuY29tcGlsZXIpO1xuXG4gIGZ1bmN0aW9uIGludm9rZVBhcnRpYWxXcmFwcGVyKHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNoKSB7XG4gICAgICBjb250ZXh0ID0gVXRpbHMuZXh0ZW5kKHt9LCBjb250ZXh0LCBvcHRpb25zLmhhc2gpO1xuICAgICAgaWYgKG9wdGlvbnMuaWRzKSB7XG4gICAgICAgIG9wdGlvbnMuaWRzWzBdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJ0aWFsID0gZW52LlZNLnJlc29sdmVQYXJ0aWFsLmNhbGwodGhpcywgcGFydGlhbCwgY29udGV4dCwgb3B0aW9ucyk7XG4gICAgbGV0IHJlc3VsdCA9IGVudi5WTS5pbnZva2VQYXJ0aWFsLmNhbGwodGhpcywgcGFydGlhbCwgY29udGV4dCwgb3B0aW9ucyk7XG5cbiAgICBpZiAocmVzdWx0ID09IG51bGwgJiYgZW52LmNvbXBpbGUpIHtcbiAgICAgIG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXSA9IGVudi5jb21waWxlKHBhcnRpYWwsIHRlbXBsYXRlU3BlYy5jb21waWxlck9wdGlvbnMsIGVudik7XG4gICAgICByZXN1bHQgPSBvcHRpb25zLnBhcnRpYWxzW29wdGlvbnMubmFtZV0oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgaWYgKG9wdGlvbnMuaW5kZW50KSB7XG4gICAgICAgIGxldCBsaW5lcyA9IHJlc3VsdC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFsaW5lc1tpXSAmJiBpICsgMSA9PT0gbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGluZXNbaV0gPSBvcHRpb25zLmluZGVudCArIGxpbmVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVGhlIHBhcnRpYWwgJyArIG9wdGlvbnMubmFtZSArICcgY291bGQgbm90IGJlIGNvbXBpbGVkIHdoZW4gcnVubmluZyBpbiBydW50aW1lLW9ubHkgbW9kZScpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEp1c3QgYWRkIHdhdGVyXG4gIGxldCBjb250YWluZXIgPSB7XG4gICAgc3RyaWN0OiBmdW5jdGlvbihvYmosIG5hbWUpIHtcbiAgICAgIGlmICghKG5hbWUgaW4gb2JqKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdcIicgKyBuYW1lICsgJ1wiIG5vdCBkZWZpbmVkIGluICcgKyBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialtuYW1lXTtcbiAgICB9LFxuICAgIGxvb2t1cDogZnVuY3Rpb24oZGVwdGhzLCBuYW1lKSB7XG4gICAgICBjb25zdCBsZW4gPSBkZXB0aHMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoZGVwdGhzW2ldICYmIGRlcHRoc1tpXVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGRlcHRoc1tpXVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbGFtYmRhOiBmdW5jdGlvbihjdXJyZW50LCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGN1cnJlbnQgPT09ICdmdW5jdGlvbicgPyBjdXJyZW50LmNhbGwoY29udGV4dCkgOiBjdXJyZW50O1xuICAgIH0sXG5cbiAgICBlc2NhcGVFeHByZXNzaW9uOiBVdGlscy5lc2NhcGVFeHByZXNzaW9uLFxuICAgIGludm9rZVBhcnRpYWw6IGludm9rZVBhcnRpYWxXcmFwcGVyLFxuXG4gICAgZm46IGZ1bmN0aW9uKGkpIHtcbiAgICAgIGxldCByZXQgPSB0ZW1wbGF0ZVNwZWNbaV07XG4gICAgICByZXQuZGVjb3JhdG9yID0gdGVtcGxhdGVTcGVjW2kgKyAnX2QnXTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIHByb2dyYW1zOiBbXSxcbiAgICBwcm9ncmFtOiBmdW5jdGlvbihpLCBkYXRhLCBkZWNsYXJlZEJsb2NrUGFyYW1zLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG4gICAgICBsZXQgcHJvZ3JhbVdyYXBwZXIgPSB0aGlzLnByb2dyYW1zW2ldLFxuICAgICAgICAgIGZuID0gdGhpcy5mbihpKTtcbiAgICAgIGlmIChkYXRhIHx8IGRlcHRocyB8fCBibG9ja1BhcmFtcyB8fCBkZWNsYXJlZEJsb2NrUGFyYW1zKSB7XG4gICAgICAgIHByb2dyYW1XcmFwcGVyID0gd3JhcFByb2dyYW0odGhpcywgaSwgZm4sIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICAgICAgfSBlbHNlIGlmICghcHJvZ3JhbVdyYXBwZXIpIHtcbiAgICAgICAgcHJvZ3JhbVdyYXBwZXIgPSB0aGlzLnByb2dyYW1zW2ldID0gd3JhcFByb2dyYW0odGhpcywgaSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb2dyYW1XcmFwcGVyO1xuICAgIH0sXG5cbiAgICBkYXRhOiBmdW5jdGlvbih2YWx1ZSwgZGVwdGgpIHtcbiAgICAgIHdoaWxlICh2YWx1ZSAmJiBkZXB0aC0tKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuX3BhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIG1lcmdlOiBmdW5jdGlvbihwYXJhbSwgY29tbW9uKSB7XG4gICAgICBsZXQgb2JqID0gcGFyYW0gfHwgY29tbW9uO1xuXG4gICAgICBpZiAocGFyYW0gJiYgY29tbW9uICYmIChwYXJhbSAhPT0gY29tbW9uKSkge1xuICAgICAgICBvYmogPSBVdGlscy5leHRlbmQoe30sIGNvbW1vbiwgcGFyYW0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICBub29wOiBlbnYuVk0ubm9vcCxcbiAgICBjb21waWxlckluZm86IHRlbXBsYXRlU3BlYy5jb21waWxlclxuICB9O1xuXG4gIGZ1bmN0aW9uIHJldChjb250ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgZGF0YSA9IG9wdGlvbnMuZGF0YTtcblxuICAgIHJldC5fc2V0dXAob3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zLnBhcnRpYWwgJiYgdGVtcGxhdGVTcGVjLnVzZURhdGEpIHtcbiAgICAgIGRhdGEgPSBpbml0RGF0YShjb250ZXh0LCBkYXRhKTtcbiAgICB9XG4gICAgbGV0IGRlcHRocyxcbiAgICAgICAgYmxvY2tQYXJhbXMgPSB0ZW1wbGF0ZVNwZWMudXNlQmxvY2tQYXJhbXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICBpZiAodGVtcGxhdGVTcGVjLnVzZURlcHRocykge1xuICAgICAgaWYgKG9wdGlvbnMuZGVwdGhzKSB7XG4gICAgICAgIGRlcHRocyA9IGNvbnRleHQgIT0gb3B0aW9ucy5kZXB0aHNbMF0gPyBbY29udGV4dF0uY29uY2F0KG9wdGlvbnMuZGVwdGhzKSA6IG9wdGlvbnMuZGVwdGhzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVwdGhzID0gW2NvbnRleHRdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1haW4oY29udGV4dC8qLCBvcHRpb25zKi8pIHtcbiAgICAgIHJldHVybiAnJyArIHRlbXBsYXRlU3BlYy5tYWluKGNvbnRhaW5lciwgY29udGV4dCwgY29udGFpbmVyLmhlbHBlcnMsIGNvbnRhaW5lci5wYXJ0aWFscywgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocyk7XG4gICAgfVxuICAgIG1haW4gPSBleGVjdXRlRGVjb3JhdG9ycyh0ZW1wbGF0ZVNwZWMubWFpbiwgbWFpbiwgY29udGFpbmVyLCBvcHRpb25zLmRlcHRocyB8fCBbXSwgZGF0YSwgYmxvY2tQYXJhbXMpO1xuICAgIHJldHVybiBtYWluKGNvbnRleHQsIG9wdGlvbnMpO1xuICB9XG4gIHJldC5pc1RvcCA9IHRydWU7XG5cbiAgcmV0Ll9zZXR1cCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMucGFydGlhbCkge1xuICAgICAgY29udGFpbmVyLmhlbHBlcnMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5oZWxwZXJzLCBlbnYuaGVscGVycyk7XG5cbiAgICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlUGFydGlhbCkge1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5wYXJ0aWFscywgZW52LnBhcnRpYWxzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlUGFydGlhbCB8fCB0ZW1wbGF0ZVNwZWMudXNlRGVjb3JhdG9ycykge1xuICAgICAgICBjb250YWluZXIuZGVjb3JhdG9ycyA9IGNvbnRhaW5lci5tZXJnZShvcHRpb25zLmRlY29yYXRvcnMsIGVudi5kZWNvcmF0b3JzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLmhlbHBlcnMgPSBvcHRpb25zLmhlbHBlcnM7XG4gICAgICBjb250YWluZXIucGFydGlhbHMgPSBvcHRpb25zLnBhcnRpYWxzO1xuICAgICAgY29udGFpbmVyLmRlY29yYXRvcnMgPSBvcHRpb25zLmRlY29yYXRvcnM7XG4gICAgfVxuICB9O1xuXG4gIHJldC5fY2hpbGQgPSBmdW5jdGlvbihpLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG4gICAgaWYgKHRlbXBsYXRlU3BlYy51c2VCbG9ja1BhcmFtcyAmJiAhYmxvY2tQYXJhbXMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ211c3QgcGFzcyBibG9jayBwYXJhbXMnKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlU3BlYy51c2VEZXB0aHMgJiYgIWRlcHRocykge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignbXVzdCBwYXNzIHBhcmVudCBkZXB0aHMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcFByb2dyYW0oY29udGFpbmVyLCBpLCB0ZW1wbGF0ZVNwZWNbaV0sIGRhdGEsIDAsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICB9O1xuICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcFByb2dyYW0oY29udGFpbmVyLCBpLCBmbiwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocykge1xuICBmdW5jdGlvbiBwcm9nKGNvbnRleHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBjdXJyZW50RGVwdGhzID0gZGVwdGhzO1xuICAgIGlmIChkZXB0aHMgJiYgY29udGV4dCAhPSBkZXB0aHNbMF0pIHtcbiAgICAgIGN1cnJlbnREZXB0aHMgPSBbY29udGV4dF0uY29uY2F0KGRlcHRocyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZuKGNvbnRhaW5lcixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY29udGFpbmVyLmhlbHBlcnMsIGNvbnRhaW5lci5wYXJ0aWFscyxcbiAgICAgICAgb3B0aW9ucy5kYXRhIHx8IGRhdGEsXG4gICAgICAgIGJsb2NrUGFyYW1zICYmIFtvcHRpb25zLmJsb2NrUGFyYW1zXS5jb25jYXQoYmxvY2tQYXJhbXMpLFxuICAgICAgICBjdXJyZW50RGVwdGhzKTtcbiAgfVxuXG4gIHByb2cgPSBleGVjdXRlRGVjb3JhdG9ycyhmbiwgcHJvZywgY29udGFpbmVyLCBkZXB0aHMsIGRhdGEsIGJsb2NrUGFyYW1zKTtcblxuICBwcm9nLnByb2dyYW0gPSBpO1xuICBwcm9nLmRlcHRoID0gZGVwdGhzID8gZGVwdGhzLmxlbmd0aCA6IDA7XG4gIHByb2cuYmxvY2tQYXJhbXMgPSBkZWNsYXJlZEJsb2NrUGFyYW1zIHx8IDA7XG4gIHJldHVybiBwcm9nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVBhcnRpYWwocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xuICBpZiAoIXBhcnRpYWwpIHtcbiAgICBpZiAob3B0aW9ucy5uYW1lID09PSAnQHBhcnRpYWwtYmxvY2snKSB7XG4gICAgICBsZXQgZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgIHdoaWxlIChkYXRhWydwYXJ0aWFsLWJsb2NrJ10gPT09IG5vb3ApIHtcbiAgICAgICAgZGF0YSA9IGRhdGEuX3BhcmVudDtcbiAgICAgIH1cbiAgICAgIHBhcnRpYWwgPSBkYXRhWydwYXJ0aWFsLWJsb2NrJ107XG4gICAgICBkYXRhWydwYXJ0aWFsLWJsb2NrJ10gPSBub29wO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0aWFsID0gb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdO1xuICAgIH1cbiAgfSBlbHNlIGlmICghcGFydGlhbC5jYWxsICYmICFvcHRpb25zLm5hbWUpIHtcbiAgICAvLyBUaGlzIGlzIGEgZHluYW1pYyBwYXJ0aWFsIHRoYXQgcmV0dXJuZWQgYSBzdHJpbmdcbiAgICBvcHRpb25zLm5hbWUgPSBwYXJ0aWFsO1xuICAgIHBhcnRpYWwgPSBvcHRpb25zLnBhcnRpYWxzW3BhcnRpYWxdO1xuICB9XG4gIHJldHVybiBwYXJ0aWFsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlUGFydGlhbChwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMucGFydGlhbCA9IHRydWU7XG4gIGlmIChvcHRpb25zLmlkcykge1xuICAgIG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCA9IG9wdGlvbnMuaWRzWzBdIHx8IG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aDtcbiAgfVxuXG4gIGxldCBwYXJ0aWFsQmxvY2s7XG4gIGlmIChvcHRpb25zLmZuICYmIG9wdGlvbnMuZm4gIT09IG5vb3ApIHtcbiAgICBvcHRpb25zLmRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgIHBhcnRpYWxCbG9jayA9IG9wdGlvbnMuZGF0YVsncGFydGlhbC1ibG9jayddID0gb3B0aW9ucy5mbjtcblxuICAgIGlmIChwYXJ0aWFsQmxvY2sucGFydGlhbHMpIHtcbiAgICAgIG9wdGlvbnMucGFydGlhbHMgPSBVdGlscy5leHRlbmQoe30sIG9wdGlvbnMucGFydGlhbHMsIHBhcnRpYWxCbG9jay5wYXJ0aWFscyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnRpYWwgPT09IHVuZGVmaW5lZCAmJiBwYXJ0aWFsQmxvY2spIHtcbiAgICBwYXJ0aWFsID0gcGFydGlhbEJsb2NrO1xuICB9XG5cbiAgaWYgKHBhcnRpYWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1RoZSBwYXJ0aWFsICcgKyBvcHRpb25zLm5hbWUgKyAnIGNvdWxkIG5vdCBiZSBmb3VuZCcpO1xuICB9IGVsc2UgaWYgKHBhcnRpYWwgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIHJldHVybiBwYXJ0aWFsKGNvbnRleHQsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkgeyByZXR1cm4gJyc7IH1cblxuZnVuY3Rpb24gaW5pdERhdGEoY29udGV4dCwgZGF0YSkge1xuICBpZiAoIWRhdGEgfHwgISgncm9vdCcgaW4gZGF0YSkpIHtcbiAgICBkYXRhID0gZGF0YSA/IGNyZWF0ZUZyYW1lKGRhdGEpIDoge307XG4gICAgZGF0YS5yb290ID0gY29udGV4dDtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZXhlY3V0ZURlY29yYXRvcnMoZm4sIHByb2csIGNvbnRhaW5lciwgZGVwdGhzLCBkYXRhLCBibG9ja1BhcmFtcykge1xuICBpZiAoZm4uZGVjb3JhdG9yKSB7XG4gICAgbGV0IHByb3BzID0ge307XG4gICAgcHJvZyA9IGZuLmRlY29yYXRvcihwcm9nLCBwcm9wcywgY29udGFpbmVyLCBkZXB0aHMgJiYgZGVwdGhzWzBdLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcbiAgICBVdGlscy5leHRlbmQocHJvZywgcHJvcHMpO1xuICB9XG4gIHJldHVybiBwcm9nO1xufVxuIl19


/***/ },
/* 354 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';
	
	exports.__esModule = true;
	
	exports['default'] = function (Handlebars) {
	  /* istanbul ignore next */
	  var root = typeof global !== 'undefined' ? global : window,
	      $Handlebars = root.Handlebars;
	  /* istanbul ignore next */
	  Handlebars.noConflict = function () {
	    if (root.Handlebars === Handlebars) {
	      root.Handlebars = $Handlebars;
	    }
	    return Handlebars;
	  };
	};
	
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL25vLWNvbmZsaWN0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O3FCQUNlLFVBQVMsVUFBVSxFQUFFOztBQUVsQyxNQUFJLElBQUksR0FBRyxPQUFPLE1BQU0sS0FBSyxXQUFXLEdBQUcsTUFBTSxHQUFHLE1BQU07TUFDdEQsV0FBVyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7O0FBRWxDLFlBQVUsQ0FBQyxVQUFVLEdBQUcsWUFBVztBQUNqQyxRQUFJLElBQUksQ0FBQyxVQUFVLEtBQUssVUFBVSxFQUFFO0FBQ2xDLFVBQUksQ0FBQyxVQUFVLEdBQUcsV0FBVyxDQUFDO0tBQy9CO0FBQ0QsV0FBTyxVQUFVLENBQUM7R0FDbkIsQ0FBQztDQUNIIiwiZmlsZSI6Im5vLWNvbmZsaWN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIHdpbmRvdyAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oSGFuZGxlYmFycykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBsZXQgcm9vdCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93LFxuICAgICAgJEhhbmRsZWJhcnMgPSByb290LkhhbmRsZWJhcnM7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIEhhbmRsZWJhcnMubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChyb290LkhhbmRsZWJhcnMgPT09IEhhbmRsZWJhcnMpIHtcbiAgICAgIHJvb3QuSGFuZGxlYmFycyA9ICRIYW5kbGViYXJzO1xuICAgIH1cbiAgICByZXR1cm4gSGFuZGxlYmFycztcbiAgfTtcbn1cbiJdfQ==
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	var Handlebars = __webpack_require__(336);
	function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
	module.exports = (Handlebars["default"] || Handlebars).template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
	    return "<div class=\"tc-folder\">\r\n  <div class=\"tc-row tc-title\">Modifications</div>\r\n  <div class=\"tc-list\" data-bind-list=\"modifications\">\r\n    <div class=\"tc-row tc-pseudo-btn modification-item context-hover action-item\" data-action=\"SetHistoryPointer\" data-bind=\"@data-modification: id\">\r\n      <span data-bind=\"info\" style=\"float: left\"></span>\r\n      <span style=\"float: right\" class=\"modification-right-buttons\">\r\n        <i class=\"fa fa-edit modification-button action-item\" data-action=\"OpenHistoryWizard\"></i>\r\n        <i class=\"fa fa-image modification-button action-item require-face\" data-action=\"EditOperationSketch\"></i>\r\n        <i class=\"fa fa-remove modification-button action-item danger\" data-action=\"RemoveModification\"></i>\r\n      </span>\r\n    </div>\r\n  </div>\r\n  <div class=\"tc-row tc-ctrl tc-buttons-block\">\r\n    <span class=\"tc-block-btn active-btn\">Finish History Editing</span>\r\n  </div>\r\n</div>\r\n";
	},"useData":true});

/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	var Handlebars = __webpack_require__(336);
	function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
	module.exports = (Handlebars["default"] || Handlebars).template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
	    return "<div class=\"tc-list solid-list\">\r\n  <div>\r\n    <div class=\"tc-row tc-pseudo-btn solid-item action-item context-click\" \r\n         data-action=\"menu.SolidContext\"\r\n         data-bind=\"id, @data-id: id\">Solid %s</div>\r\n    <div class=\"sketch-list\" data-bind-list=\"sketches\">\r\n      <div class=\"tc-row tc-pseudo-btn sketch-item\" data-bind=\"id, @data-id: id\" >Sketch %s</div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n";
	},"useData":true});

/***/ },
/* 357 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var file = exports.file = {
	  label: 'file',
	  cssIcons: ['file'],
	  actions: ['Save', 'StlExport', '-', 'IMPORT_STL']
	};
	
	var craft = exports.craft = {
	  label: 'craft',
	  cssIcons: ['magic'],
	  info: 'set of available craft operations on a solid',
	  actions: ['EXTRUDE', 'CUT', 'REVOLVE', 'SHELL']
	};
	
	var primitives = exports.primitives = {
	  label: 'add',
	  cssIcons: ['cube', 'plus'],
	  info: 'set of available solid creation operations',
	  actions: ['PLANE', 'BOX', 'SPHERE']
	};
	
	var boolean = exports.boolean = {
	  label: 'bool',
	  cssIcons: ['pie-chart'],
	  info: 'set of available boolean operations',
	  actions: ['INTERSECTION', 'DIFFERENCE', 'UNION']
	};
	
	var main = exports.main = {
	  label: 'start',
	  cssIcons: ['rocket'],
	  info: 'common set of actions',
	  actions: ['EXTRUDE', 'CUT', 'SHELL', '-', 'INTERSECTION', 'DIFFERENCE', 'UNION', '-', 'PLANE', 'BOX', 'SPHERE', '-', 'EditFace', '-', 'DeselectAll', 'RefreshSketches']
	};
	
	var SolidContext = exports.SolidContext = {
	  label: 'solid-context',
	  info: 'solid context actions',
	  actions: ['LookAtSolid']
	};

/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.IMPORT_STL = exports.UNION = exports.DIFFERENCE = exports.INTERSECTION = exports.SPHERE = exports.PLANE = exports.BOX = exports.SHELL = exports.REVOLVE = exports.EXTRUDE = exports.CUT = undefined;
	
	var _workbench = __webpack_require__(311);
	
	var _cutExtrude = __webpack_require__(359);
	
	var _revolve = __webpack_require__(380);
	
	var _brepSceneObject = __webpack_require__(379);
	
	var _planeSceneObject = __webpack_require__(381);
	
	var _brepPrimitives = __webpack_require__(382);
	
	var CUT = exports.CUT = {
	  icon: 'img/3d/cut',
	  label: 'Cut',
	  info: function info(p) {
	    return '(' + r(p.value) + ')';
	  },
	  action: function action(app, params) {
	    return (0, _cutExtrude.Cut)(app, params);
	  }
	};
	
	var EXTRUDE = exports.EXTRUDE = {
	  icon: 'img/3d/extrude',
	  label: 'Extrude',
	  info: function info(p) {
	    return '(' + r(p.value) + ')';
	  },
	  action: function action(app, params) {
	    return (0, _cutExtrude.Extrude)(app, params);
	  }
	};
	
	var REVOLVE = exports.REVOLVE = {
	  icon: 'img/3d/revolve',
	  label: 'Revolve',
	  info: function info(p) {
	    return '(' + p.angle + ')';
	  },
	  action: function action(app, params) {
	    return (0, _revolve.Revolve)(app, params);
	  }
	};
	
	var SHELL = exports.SHELL = {
	  icon: 'img/3d/shell',
	  label: 'Shell',
	  info: function info(p) {
	    return '(' + p.d + ')';
	  }
	};
	
	var BOX = exports.BOX = {
	  icon: 'img/3d/cube',
	  label: 'Box',
	  info: function info(p) {
	    return '(' + p.width + ', ' + p.height + ', ' + p.depth + ')';
	  },
	  action: function action(app, request) {
	    return {
	      outdated: [],
	      created: [new _brepSceneObject.BREPSceneSolid((0, _brepPrimitives.box)(request.width, request.height, request.depth))]
	    };
	  }
	};
	
	var PLANE = exports.PLANE = {
	  icon: 'img/3d/plane',
	  label: 'Plane',
	  info: function info(p) {
	    return '(' + p.depth + ')';
	  },
	  action: function action(app, request) {
	    return {
	      outdated: [],
	      created: [_planeSceneObject.PlaneSceneObject.create(request, function (f) {
	        return app.findFace(f);
	      })]
	    };
	  }
	};
	
	var SPHERE = exports.SPHERE = {
	  icon: 'img/3d/sphere',
	  label: 'Sphere',
	  info: function info(p) {
	    return '(' + p.radius + ')';
	  },
	  action: function action(app, request) {}
	};
	
	var INTERSECTION = exports.INTERSECTION = {
	  icon: 'img/3d/intersection',
	  label: 'Intersection',
	  info: function info(p) {
	    return null;
	  }
	};
	
	var DIFFERENCE = exports.DIFFERENCE = {
	  icon: 'img/3d/difference',
	  label: 'Difference',
	  info: function info(p) {
	    return null;
	  }
	};
	
	var UNION = exports.UNION = {
	  icon: 'img/3d/union',
	  label: 'Union',
	  info: function info(p) {
	    return null;
	  }
	};
	
	var IMPORT_STL = exports.IMPORT_STL = {
	  icon: 'img/3d/stl',
	  label: 'STL Import',
	  info: function info(p) {
	    return '(' + p.url.substring(p.url.lastIndexOf('/') + 1) + ')';
	  },
	  action: function action(app, request) {}
	};
	
	function r(value) {
	  return value.toPrecision(4).replace(/\.0$/, '');
	}

/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Extrude = Extrude;
	exports.Cut = Cut;
	exports.doOperation = doOperation;
	exports.wallJoiner = wallJoiner;
	exports.getEncloseDetails = getEncloseDetails;
	
	var _l3space = __webpack_require__(308);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _brepBuilder = __webpack_require__(360);
	
	var _stitching = __webpack_require__(329);
	
	var stitching = _interopRequireWildcard(_stitching);
	
	var _loop = __webpack_require__(362);
	
	var _topoObject = __webpack_require__(324);
	
	var _line = __webpack_require__(365);
	
	var _curve = __webpack_require__(366);
	
	var _sketchReader = __webpack_require__(376);
	
	var _sketchModel = __webpack_require__(377);
	
	var _cadUtils = __webpack_require__(302);
	
	var _booleanOperation = __webpack_require__(378);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function Extrude(app, params) {
	  return doOperation(app, params, false);
	}
	
	function Cut(app, params) {
	  return doOperation(app, params, true);
	}
	
	function doOperation(app, params, cut) {
	  var face = app.findFace(params.face);
	  var solid = face.solid;
	
	  var savedFace = localStorage.getItem(app.faceStorageKey(face.id));
	  if (savedFace == null) return null;
	
	  var sketch = (0, _sketchReader.ReadSketchFromFace)(app, face);
	  var details = getEncloseDetails(params, sketch.fetchContours(), face.surface(), !cut, false);
	  var operand = (0, _booleanOperation.combineShells)(details.map(function (d) {
	    return (0, _brepBuilder.enclose)(d.basePath, d.lidPath, d.baseSurface, d.lidSurface, wallJoiner);
	  }));
	  return (0, _booleanOperation.BooleanOperation)(face, solid, operand, cut ? 'subtract' : 'union');
	}
	
	function wallJoiner(wall, group) {
	  if (group && group.constructor.name != 'Segment') {
	    var wallFace = wall.faces[0];
	    if (!group.stitchedSurface) {
	      group.stitchedSurface = new stitching.StitchedSurface();
	    }
	    group.stitchedSurface.addFace(wallFace);
	  }
	}
	
	function getEncloseDetails(params, contours, sketchSurface, invert, forceApproximation) {
	  var value = params.value;
	  if (value < 0) {
	    value = Math.abs(value);
	    invert = !invert;
	  }
	
	  var baseSurface = invert ? sketchSurface.invert() : sketchSurface;
	
	  var target = void 0;
	  var targetDir = baseSurface.normal.negate();
	
	  if (params.rotation != 0) {
	    var basis = sketchSurface.basis();
	    target = _l3space.Matrix3.rotateMatrix(params.rotation * Math.PI / 180, basis[0], _l3space.ORIGIN).apply(targetDir);
	    if (params.angle != 0) {
	      target = _l3space.Matrix3.rotateMatrix(params.angle * Math.PI / 180, basis[2], _l3space.ORIGIN)._apply(target);
	    }
	    target._multiply(value);
	  } else {
	    target = targetDir.multiply(value);
	  }
	
	  var details = [];
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = contours[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var contour = _step.value;
	
	      if (invert) contour.reverse();
	      var basePath = contour.transferOnSurface(sketchSurface, forceApproximation);
	      if (invert) contour.reverse();
	
	      var lidPath = new _curve.CompositeCurve();
	
	      var lidPoints = basePath.points;
	      var applyPrism = !math.equal(params.prism, 1);
	      if (applyPrism) {
	        (function () {
	          var _3D = sketchSurface.get3DTransformation();
	          var _2D = _3D.invert();
	          lidPoints = math.polygonOffset(lidPoints.map(function (p) {
	            return _2D.apply(p);
	          }), params.prism).map(function (p) {
	            return _3D._apply(p);
	          });
	        })();
	      }
	      lidPoints = lidPoints.map(function (p) {
	        return p.plus(target);
	      });
	      for (var i = 0; i < basePath.points.length; ++i) {
	        var curve = basePath.curves[i];
	        var point = lidPoints[i];
	        var group = basePath.groups[i];
	        var lidCurve = void 0;
	        if (curve.isLine) {
	          //TODO: breaks test_TR_OUT_TR_INNER
	          lidCurve = _line.Line.fromSegment(point, lidPoints[(i + 1) % lidPoints.length]);
	        } else {
	          lidCurve = curve.translate(target);
	          if (applyPrism) {
	            lidCurve = lidCurve.offset(params.prism);
	          }
	        }
	        lidPath.add(lidCurve, point, group);
	      }
	
	      var lidSurface = baseSurface.translate(target).invert();
	      details.push({ basePath: basePath, lidPath: lidPath, baseSurface: baseSurface, lidSurface: lidSurface });
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  return details;
	}

/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.createPrism = createPrism;
	exports.enclose = enclose;
	exports.revolveToWallNurbs = revolveToWallNurbs;
	exports.revolve = revolve;
	exports.linkHalfEdges = linkHalfEdges;
	exports.createHalfEdge = createHalfEdge;
	exports.linkSegments = linkSegments;
	exports.point = point;
	exports.iterateSegments = iterateSegments;
	exports.invertLoop = invertLoop;
	exports.createPlaneLoop = createPlaneLoop;
	exports.createWall = createWall;
	exports.wallFromNUBRS = wallFromNUBRS;
	
	var _shell = __webpack_require__(361);
	
	var _vertex = __webpack_require__(323);
	
	var _loop2 = __webpack_require__(362);
	
	var _face = __webpack_require__(363);
	
	var _edge = __webpack_require__(364);
	
	var _line = __webpack_require__(365);
	
	var _approx = __webpack_require__(367);
	
	var _nurbs2 = __webpack_require__(369);
	
	var _plane = __webpack_require__(371);
	
	var _point = __webpack_require__(322);
	
	var _l3space = __webpack_require__(308);
	
	var _curve = __webpack_require__(366);
	
	var _cadUtils = __webpack_require__(302);
	
	var cad_utils = _interopRequireWildcard(_cadUtils);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	var _verbNurbs = __webpack_require__(370);
	
	var _verbNurbs2 = _interopRequireDefault(_verbNurbs);
	
	var _stitching = __webpack_require__(329);
	
	var _nurbsTiling = __webpack_require__(372);
	
	var _nullFaceMerge = __webpack_require__(373);
	
	var _nullFaceMerge2 = _interopRequireDefault(_nullFaceMerge);
	
	var _boolean = __webpack_require__(374);
	
	var _utils = __webpack_require__(330);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function isCCW(points, normal) {
	  var tr2d = new _l3space.Matrix3().setBasis((0, _l3space.BasisForPlane)(normal)).invert();
	  var points2d = points.map(function (p) {
	    return tr2d.apply(p);
	  });
	  return math.isCCW(points2d);
	}
	
	function checkCCW(points, normal) {
	  if (!isCCW(points, normal)) {
	    points = points.slice();
	    points.reverse();
	  }
	  return points;
	}
	
	function createPrism(basePoints, height) {
	  var normal = cad_utils.normalOfCCWSeq(basePoints);
	  var baseSurface = new _plane.Plane(normal, normal.dot(basePoints[0]));
	  var extrudeVector = baseSurface.normal.multiply(-height);
	  var lidSurface = baseSurface.translate(extrudeVector).invert();
	  var lidPoints = basePoints.map(function (p) {
	    return p.plus(extrudeVector);
	  });
	  var basePath = new _curve.CompositeCurve();
	  var lidPath = new _curve.CompositeCurve();
	
	  for (var i = 0; i < basePoints.length; i++) {
	    var j = (i + 1) % basePoints.length;
	    basePath.add(_line.Line.fromSegment(basePoints[i], basePoints[j]), basePoints[i], null);
	    lidPath.add(_line.Line.fromSegment(lidPoints[i], lidPoints[j]), lidPoints[i], null);
	  }
	  return enclose(basePath, lidPath, baseSurface, lidSurface, function () {});
	}
	
	function enclose(basePath, lidPath, baseSurface, lidSurface) {
	
	  if (basePath.points.length != lidPath.points.length) {
	    throw 'illegal arguments';
	  }
	
	  var walls = [];
	
	  var baseVertices = basePath.points.map(function (p) {
	    return new _vertex.Vertex(p);
	  });
	  var lidVertices = lidPath.points.map(function (p) {
	    return new _vertex.Vertex(p);
	  });
	
	  var n = basePath.points.length;
	  for (var i = 0; i < n; i++) {
	    var j = (i + 1) % n;
	    var wall = createWall(basePath.curves[i], lidPath.curves[i], baseVertices[j], baseVertices[i], lidVertices[i], lidVertices[j]);
	    walls.push(wall);
	  }
	  return assemble(walls, baseSurface, lidSurface);
	}
	
	function assemble(walls, baseSurface, lidSurface) {
	  var baseLoop = new _loop2.Loop();
	  var lidLoop = new _loop2.Loop();
	  var shell = new _shell.Shell();
	
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = walls[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var addHalfEdges = function addHalfEdges(loop, edges) {
	        for (var i = edges.length - 1; i >= 0; i--) {
	          var he = edges[i];
	          he.edge = new _edge.Edge(_line.Line.fromSegment(he.vertexA.point, he.vertexB.point));
	          var twin = new _edge.HalfEdge().setAB(he.vertexB, he.vertexA);
	          twin.loop = loop;
	          loop.halfEdges.push(twin);
	          he.edge.link(twin, he);
	        }
	      };
	
	      var wall = _step.value;
	
	      addHalfEdges(baseLoop, wall.bottomEdges);
	      addHalfEdges(lidLoop, wall.topEdges);
	
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        for (var _iterator2 = wall.faces[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var wallFace = _step2.value;
	
	          shell.faces.push(wallFace);
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  lidLoop.halfEdges.reverse();
	  (0, _utils.rotateArr)(lidLoop.halfEdges, 1); // keep old order for the unit tests
	  linkSegments(baseLoop.halfEdges);
	  linkSegments(lidLoop.halfEdges);
	
	  connectWalls(walls);
	
	  var baseFace = createFace(baseSurface, baseLoop);
	  var lidFace = createFace(lidSurface, lidLoop);
	
	  shell.faces.push(baseFace, lidFace);
	  shell.faces.forEach(function (f) {
	    return f.shell = shell;
	  });
	  return shell;
	}
	
	function vertIsoCurve(nurbs, param, useU) {
	  var domU = nurbs.domainU();
	  var data = _verbNurbs2.default.eval.Make.surfaceIsocurve(nurbs._data, param, useU);
	  return new _verbNurbs2.default.geom.NurbsCurve(data);
	}
	
	function assembleRevolved(walls, baseSurface, lidSurface) {
	  var baseLoop = new _loop2.Loop();
	  var lidLoop = new _loop2.Loop();
	  var shell = new _shell.Shell();
	
	  // walls.reverse();
	  iterateSegments(walls, function (wall, next) {
	
	    var nullFace = new _face.Face();
	    nullFace.outerLoop = new _loop2.Loop();
	    function addEdge(he) {
	      he.edge = new _edge.Edge(_line.Line.fromSegment(he.vertexA.point, he.vertexB.point));
	      var twin = new _edge.HalfEdge().setAB(he.vertexB, he.vertexA);
	      twin.loop = nullFace.outerLoop;
	      nullFace.outerLoop.halfEdges.push(twin);
	      he.edge.link(twin, he);
	    }
	
	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;
	
	    try {
	      for (var _iterator3 = wall.topEdges[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	        var _he = _step3.value;
	
	        addEdge(_he);
	        //      __DEBUG__.AddHalfEdge(he);
	      }
	    } catch (err) {
	      _didIteratorError3 = true;
	      _iteratorError3 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion3 && _iterator3.return) {
	          _iterator3.return();
	        }
	      } finally {
	        if (_didIteratorError3) {
	          throw _iteratorError3;
	        }
	      }
	    }
	
	    for (var i = next.bottomEdges.length - 1; i >= 0; i--) {
	      var he = next.bottomEdges[i];
	      addEdge(he);
	      //      __DEBUG__.AddHalfEdge(he, 0xffffff);
	    }
	
	    linkSegments(nullFace.outerLoop.halfEdges);
	    nullFace.data.NULL_FACE = {
	      curve: vertIsoCurve(wall.surface, 1, true),
	      start: wall.topEdges[0].twin()
	    };
	    //    __DEBUG__.AddPoint.apply(null, nullFace.data.NULL_FACE.curve.point(0.0))
	    //    __DEBUG__.AddPoint.apply(null, nullFace.data.NULL_FACE.curve.point(0.1))
	    //    __DEBUG__.AddPoint.apply(null, nullFace.data.NULL_FACE.curve.point(0.2))
	    //    __DEBUG__.AddPoint.apply(null, nullFace.data.NULL_FACE.curve.point(0.3))
	    //    __DEBUG__.AddPoint.apply(null, nullFace.data.NULL_FACE.curve.point(0.4))
	    //    __DEBUG__.AddPoint.apply(null, nullFace.data.NULL_FACE.curve.point(0.5))
	    (0, _nullFaceMerge2.default)(nullFace.data.NULL_FACE);
	  });
	
	  var _iteratorNormalCompletion4 = true;
	  var _didIteratorError4 = false;
	  var _iteratorError4 = undefined;
	
	  try {
	    for (var _iterator4 = walls[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	      var addHalfEdges = function addHalfEdges(loop, edges) {
	        //      for (let i = edges.length - 1; i >= 0; i--) {
	        //        let he = edges[i];
	        var _iteratorNormalCompletion5 = true;
	        var _didIteratorError5 = false;
	        var _iteratorError5 = undefined;
	
	        try {
	          for (var _iterator5 = edges[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	            var he = _step5.value;
	
	            he.edge = new _edge.Edge(_line.Line.fromSegment(he.vertexA.point, he.vertexB.point));
	            var twin = new _edge.HalfEdge().setAB(he.vertexB, he.vertexA);
	            __DEBUG__.AddHalfEdge(twin);
	            twin.loop = loop;
	            loop.halfEdges.push(twin);
	            he.edge.link(twin, he);
	          }
	        } catch (err) {
	          _didIteratorError5 = true;
	          _iteratorError5 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion5 && _iterator5.return) {
	              _iterator5.return();
	            }
	          } finally {
	            if (_didIteratorError5) {
	              throw _iteratorError5;
	            }
	          }
	        }
	      };
	
	      var wall = _step4.value;
	
	      addHalfEdges(baseLoop, wall.leftEdges);
	      addHalfEdges(lidLoop, wall.rightEdges);
	
	      var _iteratorNormalCompletion6 = true;
	      var _didIteratorError6 = false;
	      var _iteratorError6 = undefined;
	
	      try {
	        for (var _iterator6 = wall.faces[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	          var wallFace = _step6.value;
	
	          shell.faces.push(wallFace);
	        }
	      } catch (err) {
	        _didIteratorError6 = true;
	        _iteratorError6 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion6 && _iterator6.return) {
	            _iterator6.return();
	          }
	        } finally {
	          if (_didIteratorError6) {
	            throw _iteratorError6;
	          }
	        }
	      }
	    }
	
	    // walls.reverse();
	  } catch (err) {
	    _didIteratorError4 = true;
	    _iteratorError4 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion4 && _iterator4.return) {
	        _iterator4.return();
	      }
	    } finally {
	      if (_didIteratorError4) {
	        throw _iteratorError4;
	      }
	    }
	  }
	
	  lidLoop.halfEdges.reverse();
	  linkSegments(baseLoop.halfEdges);
	  linkSegments(lidLoop.halfEdges);
	
	  var baseFace = createFace(baseSurface, baseLoop);
	  var lidFace = createFace(lidSurface, lidLoop);
	
	  shell.faces.push(baseFace, lidFace);
	  shell.faces.forEach(function (f) {
	    return f.shell = shell;
	  });
	  return shell;
	}
	
	function connectWalls(walls) {
	
	  iterateSegments(walls, function (a, b) {
	
	    function connect(halfEdgeA, halfEdgeB) {
	      var curve = _line.Line.fromSegment(halfEdgeA.vertexA.point, halfEdgeA.vertexB.point);
	      new _edge.Edge(curve).link(halfEdgeA, halfEdgeB);
	    }
	
	    var aEdges = a.leftEdges;
	    var bEdges = b.rightEdges;
	
	    if (aEdges.length == 1 && bEdges.length == 1) {
	      connect(aEdges[0], bEdges[0]);
	    } else {
	      throw "unsupported: use 'null-face' like it's done for the revolve and then merge it";
	    }
	  });
	}
	
	function revolveToWallNurbs(basePath, surface, p0, v, angle) {
	  var nurbses = [];
	  var n = basePath.points.length;
	  for (var i = 0; i < n; i++) {
	    var curve = basePath.groups[i].toNurbs(surface);
	    var nurbs = new _verbNurbs2.default.geom.RevolvedSurface(curve.verb, p0.data(), v.data(), -angle);
	    nurbses.push(nurbs);
	  }
	  return nurbses;
	}
	
	function swap(obj, prop1, prop2) {
	  var tmp = obj[prop1];
	  obj[prop1] = obj[prop2];
	  obj[prop2] = tmp;
	}
	
	function revolve(basePath, baseSurface, p0, v, angle) {
	
	  angle = -angle;
	
	  var baseLoop = new _loop2.Loop();
	
	  var shell = new _shell.Shell();
	  var walls = [];
	
	  var n = basePath.points.length;
	
	  var baseVertices = [];
	  var lidVertices = [];
	
	  var nurbses = revolveToWallNurbs(basePath, baseSurface, p0, v, -angle);
	
	  var _iteratorNormalCompletion7 = true;
	  var _didIteratorError7 = false;
	  var _iteratorError7 = undefined;
	
	  try {
	    for (var _iterator7 = nurbses[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	      var _nurbs = _step7.value;
	
	      var domU = _nurbs.domainU();
	      var domV = _nurbs.domainV();
	      // profile of revolving becomes V direction
	      baseVertices.push(new _vertex.Vertex(new _point.Point().set3(_nurbs.point(domU.min, domV.min))));
	      lidVertices.push(new _vertex.Vertex(new _point.Point().set3(_nurbs.point(domU.max, domV.min))));
	    }
	  } catch (err) {
	    _didIteratorError7 = true;
	    _iteratorError7 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion7 && _iterator7.return) {
	        _iterator7.return();
	      }
	    } finally {
	      if (_didIteratorError7) {
	        throw _iteratorError7;
	      }
	    }
	  }
	
	  for (var i = 0; i < n; i++) {
	    var j = (i + 1) % n;
	    var nurbs = nurbses[i];
	    var wall = wallFromNUBRS(nurbs, false, baseVertices[i], lidVertices[i], lidVertices[j], baseVertices[j]);
	    walls.push(wall);
	  }
	
	  var normal = cad_utils.normalOfCCWSeq([lidVertices[2].point, lidVertices[1].point, lidVertices[0].point]);
	  var w = lidVertices[0].point.dot(normal);
	  var planeLid = new _plane.Plane(normal, w);
	
	  var revolved = assembleRevolved(walls, baseSurface, planeLid);
	  if (angle < 0) {
	    (0, _boolean.invert)(revolved);
	  }
	  return revolved;
	}
	
	function createTwin(halfEdge) {
	  var twin = new _edge.HalfEdge();
	  twin.vertexA = halfEdge.vertexB;
	  twin.vertexB = halfEdge.vertexA;
	  twin.edge = halfEdge.edge;
	  if (halfEdge.edge.halfEdge1 == halfEdge) {
	    halfEdge.edge.halfEdge2 = twin;
	  } else {
	    halfEdge.edge.halfEdge1 = twin;
	  }
	  return twin;
	}
	
	function createFace(surface, loop) {
	  var face = new _face.Face(surface);
	  face.outerLoop = loop;
	  loop.face = face;
	  return face;
	}
	
	function createPlaneForLoop(normal, loop) {
	  var w = loop.halfEdges[0].vertexA.point.dot(normal);
	  var plane = new _plane.Plane(normal, w);
	  return plane;
	}
	
	function createPlaneFace(loop) {
	  var normal = cad_utils.normalOfCCWSeq(loop.halfEdges.map(function (e) {
	    return e.vertexA.point;
	  }));
	  var plane = createPlaneForLoop(normal, loop);
	  var face = new _face.Face(plane);
	  face.outerLoop = loop;
	  loop.face = face;
	  return face;
	}
	
	function linkHalfEdges(edge, halfEdge1, halfEdge2) {
	  halfEdge1.edge = edge;
	  halfEdge2.edge = edge;
	  edge.halfEdge1 = halfEdge1;
	  edge.halfEdge2 = halfEdge2;
	}
	
	function createHalfEdge(loop, vertexA, vertexB) {
	  var halfEdge = new _edge.HalfEdge();
	  halfEdge.loop = loop;
	  halfEdge.vertexA = vertexA;
	  halfEdge.vertexB = vertexB;
	  loop.halfEdges.push(halfEdge);
	  return halfEdge;
	}
	
	function linkSegments(halfEdges) {
	  iterateSegments(halfEdges, function (prev, next) {
	    prev.next = next;
	    next.prev = prev;
	  });
	}
	
	function point(x, y, z) {
	  return new _point.Point(x, y, z);
	}
	
	function iterateSegments(items, callback) {
	  var length = items.length;
	  for (var i = 0; i < length; i++) {
	    var j = (i + 1) % length;
	    callback(items[i], items[j], i, j);
	  }
	}
	
	function invertLoop(loop) {
	  var _iteratorNormalCompletion8 = true;
	  var _didIteratorError8 = false;
	  var _iteratorError8 = undefined;
	
	  try {
	    for (var _iterator8 = loop.halfEdges[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
	      var halfEdge = _step8.value;
	
	      var t = halfEdge.vertexA;
	      halfEdge.vertexA = halfEdge.vertexB;
	      halfEdge.vertexB = t;
	    }
	  } catch (err) {
	    _didIteratorError8 = true;
	    _iteratorError8 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion8 && _iterator8.return) {
	        _iterator8.return();
	      }
	    } finally {
	      if (_didIteratorError8) {
	        throw _iteratorError8;
	      }
	    }
	  }
	
	  loop.halfEdges.reverse();
	  linkSegments(loop.halfEdges);
	}
	
	function createPlaneLoop(vertices, curves) {
	
	  var loop = new _loop2.Loop();
	
	  iterateSegments(vertices, function (a, b, i) {
	    var halfEdge = createHalfEdge(loop, a, b);
	    halfEdge.edge = new _edge.Edge(curves[i] ? curves[i] : _line.Line.fromSegment(a.point, b.point));
	    return halfEdge;
	  });
	
	  linkSegments(loop.halfEdges);
	  return loop;
	}
	
	function bothClassOf(o1, o2, className) {
	  return o1.constructor.name == className && o2.constructor.name == className;
	}
	
	var Wall = function Wall(faces, bottomEdges, rightEdges, topEdges, leftEdges, surface) {
	  _classCallCheck(this, Wall);
	
	  this.faces = faces;
	  this.bottomEdges = bottomEdges;
	  this.rightEdges = rightEdges;
	  this.topEdges = topEdges;
	  this.leftEdges = leftEdges;
	  this.surface = surface;
	};
	
	function createWall(curve1, curve2, vertexNB, vertexCB, vertexCL, vertexNL) {
	  if (bothClassOf(curve1, curve2, 'Line')) {
	    var loop = new _loop2.Loop();
	    loop.halfEdges.push(_edge.HalfEdge.create(vertexNB, vertexCB, loop, new _edge.Edge(curve1)), _edge.HalfEdge.create(vertexCB, vertexCL, loop), _edge.HalfEdge.create(vertexCL, vertexNL, loop, new _edge.Edge(curve2)), _edge.HalfEdge.create(vertexNL, vertexNB, loop));
	
	    linkSegments(loop.halfEdges);
	
	    return new Wall([createPlaneFace(loop)], [loop.halfEdges[0]], [loop.halfEdges[1]], [loop.halfEdges[2]], [loop.halfEdges[3]]);
	  } else if (bothClassOf(curve1, curve2, 'NurbsCurve')) {
	    var nurbs = _verbNurbs2.default.geom.NurbsSurface.byLoftingCurves([curve1.verb.reverse(), curve2.verb.reverse()], 1);
	    return wallFromNUBRS(nurbs, true, vertexNB, vertexCB, vertexCL, vertexNL);
	  } else {
	    throw 'unsupported';
	  }
	}
	
	function swapUV(surface) {
	  throw 'not implemented';
	  var data = surface._data;
	  verb_eval_Modify.knotsReverse();
	  return new _verbNurbs2.default.geom.NurbsCurve(new _verbNurbs2.default.core.NurbsSurfaceData(data.degreeV, data.degreeU, surface.knotsV, surface.knotsU));
	}
	
	function wallFromNUBRS(surface, vFlat, vertexNB, vertexCB, vertexCL, vertexNL) {
	
	  var outerEdges = {
	    bottom: [],
	    right: [],
	    top: [],
	    left: []
	  };
	  var stitched = new _stitching.StitchedSurface();
	  stitched.origin = surface;
	
	  var opts = {};
	  if (vFlat) {
	    opts.maxVSplits = 1;
	  }
	
	  var tiles = (0, _nurbsTiling.initTiles)(surface, opts);
	  (0, _nurbsTiling.refine)(tiles, { vMax: vFlat ? 0 : undefined });
	  function vertex(uv) {
	    if (!uv._vertex) {
	      uv._vertex = new _vertex.Vertex(new _point.Point().set3(surface.point(uv.u, uv.v)));
	    }
	    return uv._vertex;
	  }
	
	  var nVs = tiles.length - 1;
	  var nUs = tiles[0].length - 1;
	
	  tiles[0][0].edges[0].a._vertex = vertexNB;
	  tiles[0][nUs].edges[0].b._vertex = vertexCB;
	  tiles[nVs][nUs].edges[1].b._vertex = vertexCL;
	  tiles[nVs][0].edges[2].b._vertex = vertexNL;
	
	  var _iteratorNormalCompletion9 = true;
	  var _didIteratorError9 = false;
	  var _iteratorError9 = undefined;
	
	  try {
	    for (var _iterator9 = tiles[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
	      var row = _step9.value;
	      var _iteratorNormalCompletion10 = true;
	      var _didIteratorError10 = false;
	      var _iteratorError10 = undefined;
	
	      try {
	        for (var _iterator10 = row[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
	          var tile = _step10.value;
	
	          tile.leafs(function (tileLeaf) {
	            var loop = new _loop2.Loop();
	            var vertexNormals = new Map();
	            var _iteratorNormalCompletion11 = true;
	            var _didIteratorError11 = false;
	            var _iteratorError11 = undefined;
	
	            try {
	              var _loop = function _loop() {
	                var e = _step11.value;
	
	                e.leafs(function (edgeLeaf) {
	                  if (!edgeLeaf._halfEdge) {
	                    var a = vertex(e.a);
	                    var b = vertex(e.b);
	                    edgeLeaf._halfEdge = new _edge.HalfEdge().setAB(a, b);
	                    if (edgeLeaf.outer) {
	                      outerEdges[edgeLeaf.outer].push(edgeLeaf._halfEdge);
	                    } else {
	                      edgeLeaf.twin._halfEdge = new _edge.HalfEdge().setAB(b, a);
	                      var edge = new _edge.Edge(_line.Line.fromSegment(a.point, b.point));
	                      edge.link(edgeLeaf._halfEdge, edgeLeaf.twin._halfEdge);
	                      edge.data[_stitching.EDGE_AUX] = stitched;
	                    }
	                    vertexNormals.set(a, e.a.normal());
	                    vertexNormals.set(b, e.b.normal());
	                  }
	                  edgeLeaf._halfEdge.loop = loop;
	                  loop.halfEdges.push(edgeLeaf._halfEdge);
	                });
	              };
	
	              for (var _iterator11 = tileLeaf.edges[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
	                _loop();
	              }
	            } catch (err) {
	              _didIteratorError11 = true;
	              _iteratorError11 = err;
	            } finally {
	              try {
	                if (!_iteratorNormalCompletion11 && _iterator11.return) {
	                  _iterator11.return();
	                }
	              } finally {
	                if (_didIteratorError11) {
	                  throw _iteratorError11;
	                }
	              }
	            }
	
	            linkSegments(loop.halfEdges);
	            var face = createPlaneFace(loop);
	            face.data.VERTEX_NORMALS = vertexNormals;
	            stitched.addFace(face);
	          });
	        }
	      } catch (err) {
	        _didIteratorError10 = true;
	        _iteratorError10 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion10 && _iterator10.return) {
	            _iterator10.return();
	          }
	        } finally {
	          if (_didIteratorError10) {
	            throw _iteratorError10;
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError9 = true;
	    _iteratorError9 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion9 && _iterator9.return) {
	        _iterator9.return();
	      }
	    } finally {
	      if (_didIteratorError9) {
	        throw _iteratorError9;
	      }
	    }
	  }
	
	  return new Wall(stitched.faces, outerEdges.bottom, outerEdges.right, outerEdges.top, outerEdges.left, surface);
	}

/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Shell = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	exports.verticesGenerator = verticesGenerator;
	exports.edges = edges;
	
	var _topoObject = __webpack_require__(324);
	
	var _marked = [verticesGenerator, edges].map(regeneratorRuntime.mark);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Shell = exports.Shell = function (_TopoObject) {
	  _inherits(Shell, _TopoObject);
	
	  function Shell() {
	    _classCallCheck(this, Shell);
	
	    var _this = _possibleConstructorReturn(this, (Shell.__proto__ || Object.getPrototypeOf(Shell)).call(this));
	
	    _this.faces = [];
	    _this.defineIterable('vertices', function () {
	      return verticesGenerator(_this);
	    });
	    _this.defineIterable('edges', function () {
	      return edges(_this);
	    });
	    return _this;
	  }
	
	  _createClass(Shell, [{
	    key: 'reindexVertices',
	    value: function reindexVertices() {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = this.edges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var e = _step.value;
	
	          e.halfEdge1.vertexA.edges.clear();
	          e.halfEdge1.vertexB.edges.clear();
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        for (var _iterator2 = this.edges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var _e = _step2.value;
	
	          _e.halfEdge1.vertexA.edges.add(_e.halfEdge1);
	          _e.halfEdge2.vertexA.edges.add(_e.halfEdge2);
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	    }
	  }]);
	
	  return Shell;
	}(_topoObject.TopoObject);
	
	function verticesGenerator(shell) {
	  var seen, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, face, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, edge;
	
	  return regeneratorRuntime.wrap(function verticesGenerator$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          seen = new Set();
	          _iteratorNormalCompletion3 = true;
	          _didIteratorError3 = false;
	          _iteratorError3 = undefined;
	          _context.prev = 4;
	          _iterator3 = shell.faces[Symbol.iterator]();
	
	        case 6:
	          if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
	            _context.next = 39;
	            break;
	          }
	
	          face = _step3.value;
	          _iteratorNormalCompletion4 = true;
	          _didIteratorError4 = false;
	          _iteratorError4 = undefined;
	          _context.prev = 11;
	          _iterator4 = face.edges[Symbol.iterator]();
	
	        case 13:
	          if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
	            _context.next = 22;
	            break;
	          }
	
	          edge = _step4.value;
	
	          if (seen.has(edge.vertexA)) {
	            _context.next = 19;
	            break;
	          }
	
	          seen.add(edge.vertexA);
	          _context.next = 19;
	          return edge.vertexA;
	
	        case 19:
	          _iteratorNormalCompletion4 = true;
	          _context.next = 13;
	          break;
	
	        case 22:
	          _context.next = 28;
	          break;
	
	        case 24:
	          _context.prev = 24;
	          _context.t0 = _context['catch'](11);
	          _didIteratorError4 = true;
	          _iteratorError4 = _context.t0;
	
	        case 28:
	          _context.prev = 28;
	          _context.prev = 29;
	
	          if (!_iteratorNormalCompletion4 && _iterator4.return) {
	            _iterator4.return();
	          }
	
	        case 31:
	          _context.prev = 31;
	
	          if (!_didIteratorError4) {
	            _context.next = 34;
	            break;
	          }
	
	          throw _iteratorError4;
	
	        case 34:
	          return _context.finish(31);
	
	        case 35:
	          return _context.finish(28);
	
	        case 36:
	          _iteratorNormalCompletion3 = true;
	          _context.next = 6;
	          break;
	
	        case 39:
	          _context.next = 45;
	          break;
	
	        case 41:
	          _context.prev = 41;
	          _context.t1 = _context['catch'](4);
	          _didIteratorError3 = true;
	          _iteratorError3 = _context.t1;
	
	        case 45:
	          _context.prev = 45;
	          _context.prev = 46;
	
	          if (!_iteratorNormalCompletion3 && _iterator3.return) {
	            _iterator3.return();
	          }
	
	        case 48:
	          _context.prev = 48;
	
	          if (!_didIteratorError3) {
	            _context.next = 51;
	            break;
	          }
	
	          throw _iteratorError3;
	
	        case 51:
	          return _context.finish(48);
	
	        case 52:
	          return _context.finish(45);
	
	        case 53:
	        case 'end':
	          return _context.stop();
	      }
	    }
	  }, _marked[0], this, [[4, 41, 45, 53], [11, 24, 28, 36], [29,, 31, 35], [46,, 48, 52]]);
	}
	
	function edges(shell) {
	  var visited, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, face, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, halfEdge;
	
	  return regeneratorRuntime.wrap(function edges$(_context2) {
	    while (1) {
	      switch (_context2.prev = _context2.next) {
	        case 0:
	          visited = new Set();
	          _iteratorNormalCompletion5 = true;
	          _didIteratorError5 = false;
	          _iteratorError5 = undefined;
	          _context2.prev = 4;
	          _iterator5 = shell.faces[Symbol.iterator]();
	
	        case 6:
	          if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
	            _context2.next = 39;
	            break;
	          }
	
	          face = _step5.value;
	          _iteratorNormalCompletion6 = true;
	          _didIteratorError6 = false;
	          _iteratorError6 = undefined;
	          _context2.prev = 11;
	          _iterator6 = face.edges[Symbol.iterator]();
	
	        case 13:
	          if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
	            _context2.next = 22;
	            break;
	          }
	
	          halfEdge = _step6.value;
	
	          if (visited.has(halfEdge.edge)) {
	            _context2.next = 19;
	            break;
	          }
	
	          visited.add(halfEdge.edge);
	          _context2.next = 19;
	          return halfEdge.edge;
	
	        case 19:
	          _iteratorNormalCompletion6 = true;
	          _context2.next = 13;
	          break;
	
	        case 22:
	          _context2.next = 28;
	          break;
	
	        case 24:
	          _context2.prev = 24;
	          _context2.t0 = _context2['catch'](11);
	          _didIteratorError6 = true;
	          _iteratorError6 = _context2.t0;
	
	        case 28:
	          _context2.prev = 28;
	          _context2.prev = 29;
	
	          if (!_iteratorNormalCompletion6 && _iterator6.return) {
	            _iterator6.return();
	          }
	
	        case 31:
	          _context2.prev = 31;
	
	          if (!_didIteratorError6) {
	            _context2.next = 34;
	            break;
	          }
	
	          throw _iteratorError6;
	
	        case 34:
	          return _context2.finish(31);
	
	        case 35:
	          return _context2.finish(28);
	
	        case 36:
	          _iteratorNormalCompletion5 = true;
	          _context2.next = 6;
	          break;
	
	        case 39:
	          _context2.next = 45;
	          break;
	
	        case 41:
	          _context2.prev = 41;
	          _context2.t1 = _context2['catch'](4);
	          _didIteratorError5 = true;
	          _iteratorError5 = _context2.t1;
	
	        case 45:
	          _context2.prev = 45;
	          _context2.prev = 46;
	
	          if (!_iteratorNormalCompletion5 && _iterator5.return) {
	            _iterator5.return();
	          }
	
	        case 48:
	          _context2.prev = 48;
	
	          if (!_didIteratorError5) {
	            _context2.next = 51;
	            break;
	          }
	
	          throw _iteratorError5;
	
	        case 51:
	          return _context2.finish(48);
	
	        case 52:
	          return _context2.finish(45);
	
	        case 53:
	        case 'end':
	          return _context2.stop();
	      }
	    }
	  }, _marked[1], this, [[4, 41, 45, 53], [11, 24, 28, 36], [29,, 31, 35], [46,, 48, 52]]);
	}

/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Loop = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _topoObject = __webpack_require__(324);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Loop = exports.Loop = function (_TopoObject) {
	  _inherits(Loop, _TopoObject);
	
	  function Loop() {
	    _classCallCheck(this, Loop);
	
	    var _this = _possibleConstructorReturn(this, (Loop.__proto__ || Object.getPrototypeOf(Loop)).call(this));
	
	    _this.face = null;
	    _this.halfEdges = [];
	    return _this;
	  }
	
	  _createClass(Loop, [{
	    key: 'isCCW',
	    value: function isCCW(surface) {
	      return Loop.isPolygonCCWOnSurface(this.asPolygon(), surface);
	    }
	  }, {
	    key: 'asPolygon',
	    value: function asPolygon() {
	      return this.halfEdges.map(function (e) {
	        return e.vertexA.point;
	      });
	    }
	  }]);
	
	  return Loop;
	}(_topoObject.TopoObject);
	
	Loop.isPolygonCCWOnSurface = function (polygon, surface) {
	  var tr = surface.get2DTransformation();
	  var polygon2d = polygon.map(function (p) {
	    return tr.apply(p);
	  });
	  var lowestLeftIdx = math.findLowestLeftPoint(polygon2d);
	  var n = polygon.length;
	  var nextIdx = (lowestLeftIdx + 1) % n;
	  var prevIdx = (n + lowestLeftIdx - 1) % n;
	  var o = polygon[lowestLeftIdx];
	  var first = polygon[nextIdx].minus(o);
	  var last = o.minus(polygon[prevIdx]);
	  return last.cross(first).dot(surface.normal) >= 0;
	};

/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Face = undefined;
	exports.loopsGenerator = loopsGenerator;
	exports.halfEdgesGenerator = halfEdgesGenerator;
	
	var _topoObject = __webpack_require__(324);
	
	var _marked = [loopsGenerator, halfEdgesGenerator].map(regeneratorRuntime.mark);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Face = exports.Face = function (_TopoObject) {
	  _inherits(Face, _TopoObject);
	
	  function Face(surface) {
	    _classCallCheck(this, Face);
	
	    var _this = _possibleConstructorReturn(this, (Face.__proto__ || Object.getPrototypeOf(Face)).call(this));
	
	    _this.id = undefined;
	    _this.surface = surface;
	    _this.shell = null;
	    _this.outerLoop = null;
	    _this.innerLoops = [];
	    _this.defineIterable('loops', function () {
	      return loopsGenerator(_this);
	    });
	    _this.defineIterable('edges', function () {
	      return halfEdgesGenerator(_this);
	    });
	    return _this;
	  }
	
	  return Face;
	}(_topoObject.TopoObject);
	
	function loopsGenerator(face) {
	  var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, innerLoop;
	
	  return regeneratorRuntime.wrap(function loopsGenerator$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          if (!(face.outerLoop != null)) {
	            _context.next = 3;
	            break;
	          }
	
	          _context.next = 3;
	          return face.outerLoop;
	
	        case 3:
	          _iteratorNormalCompletion = true;
	          _didIteratorError = false;
	          _iteratorError = undefined;
	          _context.prev = 6;
	          _iterator = face.innerLoops[Symbol.iterator]();
	
	        case 8:
	          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
	            _context.next = 15;
	            break;
	          }
	
	          innerLoop = _step.value;
	          _context.next = 12;
	          return innerLoop;
	
	        case 12:
	          _iteratorNormalCompletion = true;
	          _context.next = 8;
	          break;
	
	        case 15:
	          _context.next = 21;
	          break;
	
	        case 17:
	          _context.prev = 17;
	          _context.t0 = _context['catch'](6);
	          _didIteratorError = true;
	          _iteratorError = _context.t0;
	
	        case 21:
	          _context.prev = 21;
	          _context.prev = 22;
	
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	
	        case 24:
	          _context.prev = 24;
	
	          if (!_didIteratorError) {
	            _context.next = 27;
	            break;
	          }
	
	          throw _iteratorError;
	
	        case 27:
	          return _context.finish(24);
	
	        case 28:
	          return _context.finish(21);
	
	        case 29:
	        case 'end':
	          return _context.stop();
	      }
	    }
	  }, _marked[0], this, [[6, 17, 21, 29], [22,, 24, 28]]);
	}
	
	function halfEdgesGenerator(face) {
	  var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, loop, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, halfEdge;
	
	  return regeneratorRuntime.wrap(function halfEdgesGenerator$(_context2) {
	    while (1) {
	      switch (_context2.prev = _context2.next) {
	        case 0:
	          _iteratorNormalCompletion2 = true;
	          _didIteratorError2 = false;
	          _iteratorError2 = undefined;
	          _context2.prev = 3;
	          _iterator2 = face.loops[Symbol.iterator]();
	
	        case 5:
	          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
	            _context2.next = 36;
	            break;
	          }
	
	          loop = _step2.value;
	          _iteratorNormalCompletion3 = true;
	          _didIteratorError3 = false;
	          _iteratorError3 = undefined;
	          _context2.prev = 10;
	          _iterator3 = loop.halfEdges[Symbol.iterator]();
	
	        case 12:
	          if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
	            _context2.next = 19;
	            break;
	          }
	
	          halfEdge = _step3.value;
	          _context2.next = 16;
	          return halfEdge;
	
	        case 16:
	          _iteratorNormalCompletion3 = true;
	          _context2.next = 12;
	          break;
	
	        case 19:
	          _context2.next = 25;
	          break;
	
	        case 21:
	          _context2.prev = 21;
	          _context2.t0 = _context2['catch'](10);
	          _didIteratorError3 = true;
	          _iteratorError3 = _context2.t0;
	
	        case 25:
	          _context2.prev = 25;
	          _context2.prev = 26;
	
	          if (!_iteratorNormalCompletion3 && _iterator3.return) {
	            _iterator3.return();
	          }
	
	        case 28:
	          _context2.prev = 28;
	
	          if (!_didIteratorError3) {
	            _context2.next = 31;
	            break;
	          }
	
	          throw _iteratorError3;
	
	        case 31:
	          return _context2.finish(28);
	
	        case 32:
	          return _context2.finish(25);
	
	        case 33:
	          _iteratorNormalCompletion2 = true;
	          _context2.next = 5;
	          break;
	
	        case 36:
	          _context2.next = 42;
	          break;
	
	        case 38:
	          _context2.prev = 38;
	          _context2.t1 = _context2['catch'](3);
	          _didIteratorError2 = true;
	          _iteratorError2 = _context2.t1;
	
	        case 42:
	          _context2.prev = 42;
	          _context2.prev = 43;
	
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	
	        case 45:
	          _context2.prev = 45;
	
	          if (!_didIteratorError2) {
	            _context2.next = 48;
	            break;
	          }
	
	          throw _iteratorError2;
	
	        case 48:
	          return _context2.finish(45);
	
	        case 49:
	          return _context2.finish(42);
	
	        case 50:
	        case 'end':
	          return _context2.stop();
	      }
	    }
	  }, _marked[1], this, [[3, 38, 42, 50], [10, 21, 25, 33], [26,, 28, 32], [43,, 45, 49]]);
	}

/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.HalfEdge = exports.Edge = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _topoObject = __webpack_require__(324);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Edge = exports.Edge = function (_TopoObject) {
	  _inherits(Edge, _TopoObject);
	
	  function Edge(curve) {
	    _classCallCheck(this, Edge);
	
	    var _this = _possibleConstructorReturn(this, (Edge.__proto__ || Object.getPrototypeOf(Edge)).call(this));
	
	    _this.curve = curve;
	    _this.halfEdge1 = null;
	    _this.halfEdge2 = null;
	    return _this;
	  }
	
	  _createClass(Edge, [{
	    key: 'link',
	    value: function link(halfEdge1, halfEdge2) {
	      halfEdge1.edge = this;
	      halfEdge2.edge = this;
	      this.halfEdge1 = halfEdge1;
	      this.halfEdge2 = halfEdge2;
	    }
	  }]);
	
	  return Edge;
	}(_topoObject.TopoObject);
	
	var HalfEdge = exports.HalfEdge = function (_TopoObject2) {
	  _inherits(HalfEdge, _TopoObject2);
	
	  function HalfEdge() {
	    _classCallCheck(this, HalfEdge);
	
	    var _this2 = _possibleConstructorReturn(this, (HalfEdge.__proto__ || Object.getPrototypeOf(HalfEdge)).call(this));
	
	    _this2.edge = null;
	    _this2.vertexA = null;
	    _this2.vertexB = null;
	    _this2.loop = null;
	    _this2.next = null;
	    _this2.prev = null;
	    return _this2;
	  }
	
	  _createClass(HalfEdge, [{
	    key: 'setAB',
	    value: function setAB(a, b) {
	      this.vertexA = a;
	      this.vertexB = b;
	      return this;
	    }
	  }, {
	    key: 'twin',
	    value: function twin() {
	      return this.edge.halfEdge1 == this ? this.edge.halfEdge2 : this.edge.halfEdge1;
	    }
	  }, {
	    key: 'splitHalfEdge',
	    value: function splitHalfEdge(vertex) {
	      var h = this;
	      var newEdge = new HalfEdge();
	      newEdge.vertexA = vertex;
	      newEdge.vertexB = h.vertexB;
	      h.vertexB = newEdge.vertexA;
	
	      h.vertexA.edges.add(newEdge);
	      h.vertexA.edges.delete(h);
	      vertex.edges.add(newEdge);
	
	      return newEdge;
	    }
	  }, {
	    key: 'split',
	    value: function split(vertex) {
	
	      var orig = this;
	      var twin = orig.twin();
	
	      if (orig.vertexA == vertex || orig.vertexB == vertex) {
	        return;
	      }
	
	      var newOrig = orig.splitHalfEdge(vertex);
	      var newTwin = twin.splitHalfEdge(vertex);
	
	      orig.edge.link(orig, newTwin);
	      new Edge(orig.edge.curve).link(twin, newOrig);
	
	      orig.loop.halfEdges.splice(orig.loop.halfEdges.indexOf(orig) + 1, 0, newOrig);
	      twin.loop.halfEdges.splice(twin.loop.halfEdges.indexOf(twin) + 1, 0, newTwin);
	
	      function insertToLL(orig, newOrig) {
	        orig.next.prev = newOrig;
	        newOrig.next = orig.next;
	        orig.next = newOrig;
	        newOrig.prev = orig;
	      }
	
	      insertToLL(orig, newOrig);
	      insertToLL(twin, newTwin);
	
	      newOrig.loop = orig.loop;
	      newTwin.loop = twin.loop;
	    }
	  }], [{
	    key: 'create',
	    value: function create(a, b, loop, edge) {
	      var e = new HalfEdge().setAB(a, b);
	      e.loop = loop;
	      e.edge = edge;
	      return e;
	    }
	  }]);
	
	  return HalfEdge;
	}(_topoObject.TopoObject);
	
	HalfEdge.fromVertices = function (a, b, curve) {
	  var halfEdge1 = new HalfEdge();
	  var halfEdge2 = new HalfEdge();
	
	  halfEdge1.setAB(a, b);
	  halfEdge2.setAB(b, a);
	
	  new Edge(curve).link(halfEdge1, halfEdge2);
	  return halfEdge1;
	};

/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Line = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _curve = __webpack_require__(366);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Line = exports.Line = function (_Curve) {
	  _inherits(Line, _Curve);
	
	  function Line(p0, v) {
	    _classCallCheck(this, Line);
	
	    var _this = _possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).call(this));
	
	    _this.p0 = p0;
	    _this.v = v;
	    _this._pointsCache = new Map();
	    return _this;
	  }
	
	  _createClass(Line, [{
	    key: 'intersectSurface',
	    value: function intersectSurface(surface) {
	      if (surface.isPlane) {
	        var s0 = surface.normal.multiply(surface.w);
	        return surface.normal.dot(s0.minus(this.p0)) / surface.normal.dot(this.v); // 4.7.4
	      } else {
	        return _get(Line.prototype.__proto__ || Object.getPrototypeOf(Line.prototype), 'intersectSurface', this).call(this, surface);
	      }
	    }
	  }, {
	    key: 'intersectCurve',
	    value: function intersectCurve(curve, surface) {
	      if (curve.isLine && surface.isPlane) {
	        var otherNormal = surface.normal.cross(curve.v)._normalize();
	        return otherNormal.dot(curve.p0.minus(this.p0)) / otherNormal.dot(this.v); // (4.8.3)    
	      }
	      return _get(Line.prototype.__proto__ || Object.getPrototypeOf(Line.prototype), 'intersectCurve', this).call(this, curve, surface);
	    }
	  }, {
	    key: 'parametricEquation',
	    value: function parametricEquation(t) {
	      return this.p0.plus(this.v.multiply(t));
	    }
	  }, {
	    key: 't',
	    value: function t(point) {
	      return point.minus(this.p0).dot(this.v);
	    }
	  }, {
	    key: 'pointOfSurfaceIntersection',
	    value: function pointOfSurfaceIntersection(surface) {
	      var point = this._pointsCache.get(surface);
	      if (!point) {
	        var t = this.intersectSurface(surface);
	        point = this.parametricEquation(t);
	        this._pointsCache.set(surface, point);
	      }
	      return point;
	    }
	  }, {
	    key: 'translate',
	    value: function translate(vector) {
	      return new Line(this.p0.plus(vector), this.v);
	    }
	  }, {
	    key: 'approximate',
	    value: function approximate(resolution, from, to, path) {}
	  }, {
	    key: 'offset',
	    value: function offset() {}
	  }]);
	
	  return Line;
	}(_curve.Curve);
	
	Line.prototype.isLine = true;
	
	Line.fromTwoPlanesIntersection = function (plane1, plane2) {
	  var n1 = plane1.normal;
	  var n2 = plane2.normal;
	  var v = n1.cross(n2)._normalize();
	  var pf1 = plane1.toParametricForm();
	  var pf2 = plane2.toParametricForm();
	  var r0diff = pf1.r0.minus(pf2.r0);
	  var ww = r0diff.minus(n2.multiply(r0diff.dot(n2)));
	  var p0 = pf2.r0.plus(ww.multiply(n1.dot(r0diff) / n1.dot(ww)));
	  return new Line(p0, v);
	};
	
	Line.fromSegment = function (a, b) {
	  return new Line(a, b.minus(a)._normalize());
	};

/***/ },
/* 366 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Curve = exports.Curve = function () {
	  function Curve() {
	    _classCallCheck(this, Curve);
	  }
	
	  _createClass(Curve, [{
	    key: 'isSameClass',
	    value: function isSameClass(other) {
	      return this.constructor.name == other.constructor.name;
	    }
	  }, {
	    key: 'parametricEquation',
	    value: function parametricEquation(t) {
	      throw 'not implemented';
	    }
	  }, {
	    key: 'translate',
	    value: function translate(vector) {
	      throw 'not implemented';
	    }
	  }, {
	    key: 'toNurbs',
	    value: function toNurbs(domainA, domainB) {
	      throw 'not implemented';
	    }
	  }, {
	    key: 'approximate',
	    value: function approximate(resolution, from, to, path) {}
	  }]);
	
	  return Curve;
	}();
	
	Curve.prototype.isLine = false;
	
	var CompositeCurve = exports.CompositeCurve = function () {
	  function CompositeCurve() {
	    _classCallCheck(this, CompositeCurve);
	
	    this.curves = [];
	    this.points = [];
	    this.groups = [];
	  }
	
	  _createClass(CompositeCurve, [{
	    key: 'add',
	    value: function add(curve, point, group) {
	      this.curves.push(curve);
	      this.points.push(point);
	      this.groups.push(group);
	    }
	  }]);

	  return CompositeCurve;
	}();

/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ApproxCurve = exports.ApproxSurface = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _surface = __webpack_require__(368);
	
	var _line = __webpack_require__(365);
	
	var _curve = __webpack_require__(366);
	
	var _l3space = __webpack_require__(308);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ApproxSurface = exports.ApproxSurface = function (_Surface) {
	  _inherits(ApproxSurface, _Surface);
	
	  function ApproxSurface(mesh) {
	    _classCallCheck(this, ApproxSurface);
	
	    var _this = _possibleConstructorReturn(this, (ApproxSurface.__proto__ || Object.getPrototypeOf(ApproxSurface)).call(this));
	
	    _this.mesh = mesh;
	    return _this;
	  }
	
	  return ApproxSurface;
	}(_surface.Surface);
	
	var ApproxCurve = exports.ApproxCurve = function (_Curve) {
	  _inherits(ApproxCurve, _Curve);
	
	  function ApproxCurve(points, proto) {
	    _classCallCheck(this, ApproxCurve);
	
	    var _this2 = _possibleConstructorReturn(this, (ApproxCurve.__proto__ || Object.getPrototypeOf(ApproxCurve)).call(this));
	
	    _this2.points = points;
	    _this2.segments = [];
	    _this2.tShifts = [0];
	    for (var i = 1; i < points.length; ++i) {
	      var a = points[i - 1];
	      var b = points[i];
	      var line = _line.Line.fromSegment(a, b);
	      _this2.segments.push(line);
	      _this2.tShifts.push(_this2.tShifts[_this2.tShifts.length - 1] + line.t(b));
	    }
	    _this2.proto = proto;
	    return _this2;
	  }
	
	  _createClass(ApproxCurve, [{
	    key: 't',
	    value: function t(point) {
	      for (var i = 0; i < this.points.length; ++i) {
	        if (math.vectorsEqual(this.points[i], point)) {
	          return this.tShifts[i];
	        }
	      }
	
	      for (var _i = 0; _i < this.segments.length; ++_i) {
	        var line = this.segments[_i];
	        var subT = line.t(point);
	        if (subT > 0 && subT < this.tShifts[_i + 1]) {
	          return this.tShifts[_i] + subT;
	        }
	      }
	      return NaN;
	    }
	  }, {
	    key: 'parametricEquation',
	    value: function parametricEquation(t) {
	      for (var i = 0; i < this.points.length; ++i) {
	        if (math.equal(t, this.tShifts[i])) {
	          return this.points[i];
	        }
	      }
	      for (var _i2 = 1; _i2 < this.points.length; ++_i2) {
	        if (t > this.tShifts[_i2 - 1] && t < this.tShifts[_i2]) {
	          return this.segments[_i2 - 1].parametricEquation(t - this.tShifts[_i2 - 1]);
	        }
	      }
	      return null;
	    }
	  }, {
	    key: 'getChunk',
	    value: function getChunk(p1, p2) {
	      var result = [];
	      this.getChunkImpl(p1, p2, result, true);
	      return result;
	    }
	  }, {
	    key: 'getChunkImpl',
	    value: function getChunkImpl(p1, p2, result, includeBounds) {
	      var t1 = this.t(p1);
	      var t2 = this.t(p2);
	      if (t1 > t2) {
	        var tmp = p1;
	        p1 = p2;
	        p2 = tmp;
	      }
	      return this.getChunkDirectional(p1, p2, result, includeBounds);
	    }
	  }, {
	    key: 'getChunkDirectional',
	    value: function getChunkDirectional(p1, p2, result, includeBounds) {
	      var inState = false;
	      for (var i = 1; i < this.points.length; ++i) {
	        var a = this.points[i - 1];
	        var b = this.points[i];
	        var line = this.segments[i - 1];
	        if (inState) {
	          result.push(a);
	        }
	        if (!inState) {
	          if (math.vectorsEqual(a, p1)) {
	            if (includeBounds) result.push(p1);
	            inState = true;
	          } else if (math.equal(b, p1)) {
	            //nothing
	          } else {
	            var t = line.t(p1);
	            if (t > 0 && t < this.tShifts[i] - this.tShifts[i - 1]) {
	              if (includeBounds) result.push(p1);
	              inState = true;
	            }
	          }
	        }
	        if (inState) {
	          if (math.vectorsEqual(b, p2)) {
	            if (includeBounds) result.push(p2);
	            break;
	          } else if (math.equal(a, p2)) {
	            //nothing, can't be here
	          } else {
	            var _t = line.t(p2);
	            if (_t > 0 && _t < this.tShifts[i] - this.tShifts[i - 1]) {
	              if (includeBounds) result.push(p2);
	              break;
	            }
	          }
	        }
	      }
	    }
	  }, {
	    key: 'translate',
	    value: function translate(vector) {
	      return new ApproxCurve(this.points.map(function (p) {
	        return p.plus(vector);
	      }), this.proto);
	    }
	  }, {
	    key: 'approximate',
	    value: function approximate(resolution, from, to, path) {
	      this.getChunkImpl(from, to, path, false);
	    }
	  }]);

	  return ApproxCurve;
	}(_curve.Curve);

/***/ },
/* 368 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Surface = exports.Surface = function () {
	  function Surface() {
	    _classCallCheck(this, Surface);
	  }
	
	  //--------------------------------------------------------------------------------------------------------------------
	
	  _createClass(Surface, [{
	    key: 'classifyCognateCurve',
	    value: function classifyCognateCurve(curve, tol) {
	      throw 'not implemented';
	    }
	  }, {
	    key: 'classifyCurve',
	    value: function classifyCurve(curve, tol) {
	      if (this.isCognateCurve(curve)) {
	        return this.classifyCognateCurve(curve, tol);
	      }
	      return this.toNurbs().classifyCognateCurve(curve.toNurbs(), tol);
	    }
	  }, {
	    key: 'intersectForSameClass',
	
	
	    //--------------------------------------------------------------------------------------------------------------------
	
	    value: function intersectForSameClass() {
	      throw 'not implemented';
	    }
	  }, {
	    key: 'intersect',
	    value: function intersect(other, tol) {
	      if (this.isSameClass(other)) {
	        return this.intersectForSameClass(other, tol);
	      }
	      return this.toNurbs().intersectForSameClass(other.toNurbs(), tol);
	    }
	  }, {
	    key: 'coplanarUnsignedForSameClass',
	
	
	    //--------------------------------------------------------------------------------------------------------------------
	
	    value: function coplanarUnsignedForSameClass(other, tol) {
	      throw 'not implemented';
	    }
	  }, {
	    key: 'coplanarUnsigned',
	    value: function coplanarUnsigned(other, tol) {
	      if (this.isSameClass(other)) {
	        return this.coplanarUnsignedForSameClass(other, tol);
	      }
	      return this.toNurbs().coplanarUnsignedForSameClass(other.toNurbs());
	    }
	
	    //--------------------------------------------------------------------------------------------------------------------
	
	  }, {
	    key: 'equalsForSameClass',
	    value: function equalsForSameClass(other, tol) {
	      throw 'not implemented';
	    }
	  }, {
	    key: 'equals',
	    value: function equals(other, tol) {
	      if (this.isSameClass(other)) {
	        return this.equalsForSameClass(other, tol);
	      }
	      return this.toNurbs().equalsForSameClass(other.toNurbs());
	    }
	
	    //--------------------------------------------------------------------------------------------------------------------
	
	  }, {
	    key: 'toNurbs',
	    value: function toNurbs() {
	      throw 'not implemented';
	    }
	  }, {
	    key: 'isSameClass',
	    value: function isSameClass(other) {
	      return this.constructor.name == other.constructor.name;
	    }
	  }, {
	    key: 'isCognateCurve',
	    value: function isCognateCurve(curve) {
	      return false;
	    }
	  }]);
	
	  return Surface;
	}();
	
	Surface.prototype.isPlane = false;

/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.NurbsSurface = exports.NurbsCurve = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _verbNurbs = __webpack_require__(370);
	
	var _verbNurbs2 = _interopRequireDefault(_verbNurbs);
	
	var _l3space = __webpack_require__(308);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	var _point = __webpack_require__(322);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NurbsCurve = exports.NurbsCurve = function () {
	  function NurbsCurve(verbCurve) {
	    _classCallCheck(this, NurbsCurve);
	
	    this.verb = verbCurve;
	  }
	
	  _createClass(NurbsCurve, [{
	    key: 'translate',
	    value: function translate(vector) {
	      var tr = new _l3space.Matrix3().translate(vector.x, vector.y, vector.z).toArray();
	      return new NurbsCurve(this.verb.transform(tr));
	    }
	  }, {
	    key: 'approximate',
	    value: function approximate(resolution, from, to, out) {
	      var chunks = this.verb.divideByArcLength(10);
	      var startU = this.verb.closestParam(from.toArray());
	      var endU = this.verb.closestParam(to.toArray());
	      var reverse = startU > endU;
	      if (reverse) {
	        var tmp = startU;
	        startU = endU;
	        endU = tmp;
	        chunks.reverse();
	      }
	
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = chunks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var sample = _step.value;
	
	          var u = sample.u;
	          if (u > startU + math.TOLERANCE && u < endU - math.TOLERANCE) {
	            out.push(new _point.Point().set3(this.verb.point(u)));
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    }
	  }, {
	    key: 'approximateU',
	    value: function approximateU(resolution, paramFrom, paramTo, consumer) {
	      var u = paramFrom;
	      var endU = paramTo;
	      var step = this.verb.paramAtLength(resolution);
	      if (u > endU) {
	        step *= -1;
	      }
	      u += step;
	      for (; step > 0 ? u < endU : u > endU; u += step) {
	        consumer(u);
	      }
	    }
	  }, {
	    key: 'tangentAtPoint',
	    value: function tangentAtPoint(point) {
	      return new _point.Point().set3(this.verb.tangent(this.verb.closestParam(point.data())));
	    }
	  }, {
	    key: 'closestDistanceToPoint',
	    value: function closestDistanceToPoint(point) {
	      var closest = this.verb.closestPoint(point.data());
	      return math.distance3(point.x, point.y, point.z, closest[0], closest[1], closest[2]);
	    }
	  }, {
	    key: 'tangent',
	    value: function tangent(point) {
	      return new _point.Point().set3(this.verb.tangent(this.verb.closestParam(point.data())));
	    }
	  }, {
	    key: 'intersect',
	    value: function intersect(other, tolerance) {
	      return _verbNurbs2.default.geom.Intersect.curves(this.verb, other.verb, tolerance).map(function (i) {
	        return new _point.Point().set3(i.point0);
	      });
	    }
	  }], [{
	    key: 'createByPoints',
	    value: function createByPoints(points, degeree) {
	      points = points.map(function (p) {
	        return p.data();
	      });
	      return new NurbsCurve(new _verbNurbs2.default.geom.NurbsCurve.byPoints(points, degeree));
	    }
	  }]);
	
	  return NurbsCurve;
	}();
	
	NurbsCurve.createLinearNurbs = function (a, b) {
	  return new NurbsCurve(new _verbNurbs2.default.geom.Line(a.data(), b.data()));
	};
	
	NurbsCurve.prototype.createLinearNurbs = function (a, b) {
	  return NurbsCurve.createLinearNurbs(a, b);
	};
	
	var NurbsSurface = exports.NurbsSurface = function () {
	  function NurbsSurface(verbSurface) {
	    _classCallCheck(this, NurbsSurface);
	
	    this.verb = verbSurface;
	  }
	
	  _createClass(NurbsSurface, [{
	    key: 'isCognateCurve',
	    value: function isCognateCurve(curve) {
	      return curve.constructor.name == 'NurbsCurve';
	    }
	  }, {
	    key: 'toNurbs',
	    value: function toNurbs() {
	      return this;
	    }
	  }, {
	    key: 'coplanarUnsignedForSameClass',
	    value: function coplanarUnsignedForSameClass(other, tol) {
	      //throw 'not implemented'
	      return false;
	    }
	  }, {
	    key: 'intersectForSameClass',
	    value: function intersectForSameClass(other, tol) {
	      var curves = _verbNurbs2.default.geom.Intersect.surfaces(this.verb, other.verb, tol);
	      return curves.map(function (curve) {
	        return new NurbsCurve(curve);
	      });
	    }
	  }, {
	    key: 'classifyCognateCurve',
	    value: function classifyCognateCurve(line, tol) {
	      var parallel = math.areEqual(line.v.dot(this.normal), 0, tol);
	      var pointOnPlane = math.areEqual(this.normal.dot(line.p0), this.w, tol);
	      return {
	        hit: !parallel || pointOnPlane,
	        parallel: parallel
	      };
	    }
	  }]);

	  return NurbsSurface;
	}();

/***/ },
/* 370 */
/***/ function(module, exports) {

	module.exports = verb;

/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Plane = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _surface = __webpack_require__(368);
	
	var _point = __webpack_require__(322);
	
	var _line = __webpack_require__(365);
	
	var _l3space = __webpack_require__(308);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Plane = exports.Plane = function (_Surface) {
	  _inherits(Plane, _Surface);
	
	  function Plane(normal, w) {
	    _classCallCheck(this, Plane);
	
	    var _this = _possibleConstructorReturn(this, (Plane.__proto__ || Object.getPrototypeOf(Plane)).call(this));
	
	    _this.normal = normal;
	    _this.w = w;
	    return _this;
	  }
	
	  _createClass(Plane, [{
	    key: 'isCognateCurve',
	    value: function isCognateCurve(curve) {
	      return curve.constructor.name == 'Line';
	    }
	  }, {
	    key: 'calculateBasis',
	    value: function calculateBasis() {
	      return (0, _l3space.BasisForPlane)(this.normal);
	    }
	  }, {
	    key: 'basis',
	    value: function basis() {
	      if (!this._basis) {
	        this._basis = this.calculateBasis();
	      }
	      return this._basis;
	    }
	  }, {
	    key: 'intersectForSameClass',
	    value: function intersectForSameClass(other) {
	      return new _line.Line.fromTwoPlanesIntersection(this, other);
	    }
	  }, {
	    key: 'translate',
	    value: function translate(vector) {
	      return new Plane(this.normal, this.normal.dot(this.normal.multiply(this.w)._plus(vector)));
	    }
	  }, {
	    key: 'invert',
	    value: function invert() {
	      return new Plane(this.normal.multiply(-1), -this.w);
	    }
	  }, {
	    key: 'get2DTransformation',
	    value: function get2DTransformation() {
	      if (!this.__2dTr) {
	        this.__2dTr = this.get3DTransformation().invert();
	      }
	      return this.__2dTr;
	    }
	  }, {
	    key: 'get3DTransformation',
	    value: function get3DTransformation() {
	      if (!this.__3dTr) {
	        var basis = new _l3space.Matrix3().setBasis(this.basis());
	        var translate = new _l3space.Matrix3();
	        translate.tz = this.w;
	        this.__3dTr = basis.combine(translate);
	        //      this.__3dTr.tz = this.w;
	      }
	      return this.__3dTr;
	    }
	  }, {
	    key: 'coplanarUnsignedForSameClass',
	    value: function coplanarUnsignedForSameClass(other, tol) {
	      return math.areVectorsEqual(this.normal.multiply(this.w), other.normal.multiply(other.w), tol);
	      //TODO: store this.normal.multiply(this.w) in a field since it's constant value
	    }
	  }, {
	    key: 'equalsForSameClass',
	    value: function equalsForSameClass(other, tol) {
	      return math.areVectorsEqual(this.normal, other.normal, tol) && math.areEqual(this.w, other.w, tol);
	    }
	  }, {
	    key: 'toParametricForm',
	    value: function toParametricForm() {
	      if (!this.__parametricForm) {
	        var basis = (0, _l3space.BasisForPlane)(this.normal);
	        this.__parametricForm = new ParametricPlane(this.normal.multiply(this.w), basis.x, basis.y);
	      }
	      return this.__parametricForm;
	    }
	  }, {
	    key: 'toUV',
	    value: function toUV(point) {
	      return this.get2DTransformation().apply(point);
	    }
	  }, {
	    key: 'fromUV',
	    value: function fromUV(u, v) {
	      return this.get3DTransformation()._apply(new _point.Point(u, v, 0));
	    }
	  }, {
	    key: 'domainU',
	    value: function domainU() {
	      return [Number.MIN_VALUE, Number.MAX_VALUE];
	    }
	  }, {
	    key: 'domainV',
	    value: function domainV() {
	      return [Number.MIN_VALUE, Number.MAX_VALUE];
	    }
	  }, {
	    key: 'classifyCognateCurve',
	    value: function classifyCognateCurve(line, tol) {
	      var parallel = math.areEqual(line.v.dot(this.normal), 0, tol);
	      var pointOnPlane = math.areEqual(this.normal.dot(line.p0), this.w, tol);
	      return {
	        hit: !parallel || pointOnPlane,
	        parallel: parallel
	      };
	    }
	  }]);
	
	  return Plane;
	}(_surface.Surface);
	
	Plane.prototype.isPlane = true;
	
	var ParametricPlane = function () {
	  function ParametricPlane(r0, r1, r2) {
	    _classCallCheck(this, ParametricPlane);
	
	    this.r0 = r0;
	    this.r1 = r1;
	    this.r2 = r2;
	  }
	
	  _createClass(ParametricPlane, [{
	    key: 'equation',
	    value: function equation(u, v) {
	      return this.r0 + this.r1.multiply(u) + this.r2.multiply(v);
	    }
	  }]);

	  return ParametricPlane;
	}();

/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TileEdge = exports.Tile = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	exports.initTiles = initTiles;
	exports.refine = refine;
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Tree = function () {
	  function Tree() {
	    _classCallCheck(this, Tree);
	
	    this.children = null;
	  }
	
	  _createClass(Tree, [{
	    key: 'isLeaf',
	    value: function isLeaf() {
	      return this.children == null;
	    }
	  }, {
	    key: 'leafs',
	    value: function leafs(callback) {
	      if (this.isLeaf()) {
	        callback(this);
	      } else {
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	          for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var child = _step.value;
	
	            child.leafs(callback);
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	      }
	    }
	  }]);
	
	  return Tree;
	}();
	
	var Tile = exports.Tile = function (_Tree) {
	  _inherits(Tile, _Tree);
	
	  function Tile(surface, bottom, right, top, left) {
	    _classCallCheck(this, Tile);
	
	    var _this = _possibleConstructorReturn(this, (Tile.__proto__ || Object.getPrototypeOf(Tile)).call(this));
	
	    _this.surface = surface;
	    _this.edges = [bottom, right, top, left];
	    _this.edges.forEach(function (e) {
	      return e.tile = _this;
	    });
	    return _this;
	  }
	
	  _createClass(Tile, [{
	    key: 'divideHalf',
	    value: function divideHalf(vert) {
	      var shift = vert ? 0 : 1;
	
	      var bottom = this.edges[0 + shift];
	      var right = this.edges[1 + shift];
	      var up = this.edges[2 + shift];
	      var left = this.edges[(3 + shift) % 4];
	
	      var bottomDivs = bottom.split();
	      var upDivs = up.split();
	      var newEdge = new TileEdge(bottomDivs[0].b, upDivs[0].b);
	      if (vert) {
	        this.children = [new Tile(this.surface, bottomDivs[0], newEdge, upDivs[1], left), new Tile(this.surface, bottomDivs[1], right, upDivs[0], newEdge.twin)];
	      } else {
	        this.children = [new Tile(this.surface, left, bottomDivs[0], newEdge, upDivs[1]), new Tile(this.surface, newEdge.twin, bottomDivs[1], right, upDivs[0])];
	      }
	    }
	  }, {
	    key: 'divideVertically',
	    value: function divideVertically() {
	      this.divideHalf(true);
	    }
	  }, {
	    key: 'divideHorizontally',
	    value: function divideHorizontally() {
	      this.divideHalf(false);
	    }
	  }, {
	    key: 'divideBoth',
	    value: function divideBoth() {
	      throw 'not implemented';
	    }
	  }, {
	    key: 'center',
	    value: function center() {
	      if (!this._center) {
	        this._center = new UVPoint(mid(this.edges[0].a.u, this.edges[0].b.u), mid(this.edges[1].a.v, this.edges[1].b.v), this.surface);
	      }
	      return this._center;
	    }
	  }]);
	
	  return Tile;
	}(Tree);
	
	var TileEdge = exports.TileEdge = function (_Tree2) {
	  _inherits(TileEdge, _Tree2);
	
	  function TileEdge(a, b, outer, twin) {
	    _classCallCheck(this, TileEdge);
	
	    var _this2 = _possibleConstructorReturn(this, (TileEdge.__proto__ || Object.getPrototypeOf(TileEdge)).call(this));
	
	    _this2.tile = null; // to be set by a Tile
	    _this2.a = a;
	    _this2.b = b;
	    _this2.outer = outer;
	    if (twin == undefined) {
	      twin = new TileEdge(b, a, outer, _this2);
	    }
	    _this2.twin = twin;
	    return _this2;
	  }
	
	  _createClass(TileEdge, [{
	    key: 'split',
	    value: function split() {
	      if (this.children == null) {
	        var midPoint = new UVPoint(mid(this.a.u, this.b.u), mid(this.a.v, this.b.v), this.tile.surface);
	        this.children = [new TileEdge(this.a, midPoint, this.outer), new TileEdge(midPoint, this.b, this.outer)];
	        this.twin.children = [this.children[1].twin, this.children[0].twin];
	      }
	      return this.children;
	    }
	  }]);
	
	  return TileEdge;
	}(Tree);
	
	var UVPoint = function () {
	  function UVPoint(u, v, surface) {
	    _classCallCheck(this, UVPoint);
	
	    this.u = u;
	    this.v = v;
	    this.surface = surface;
	  }
	
	  _createClass(UVPoint, [{
	    key: 'normal',
	    value: function normal() {
	      if (!this._normal) {
	        this._normal = new _vector2.default().set3(this.surface.normal(this.u, this.v))._normalize();
	      }
	      return this._normal;
	    }
	  }]);
	
	  return UVPoint;
	}();
	
	function initTiles(surface, opts) {
	
	  var data = surface._data;
	  var nSplitsU = data.controlPoints.length - 1;
	  var nSplitsV = data.controlPoints[0].length - 1;
	
	  if (opts.maxUSplits && nSplitsU > opts.maxUSplits) {
	    nSplitsU = opts.maxUSplits;
	  }
	
	  if (opts.maxVSplits && nSplitsV > opts.maxVSplits) {
	    nSplitsV = opts.maxVSplits;
	  }
	
	  var umax = data.knotsU[data.knotsU.length - 1];
	  var umin = data.knotsU[0];
	  var vmax = data.knotsV[data.knotsV.length - 1];
	  var vmin = data.knotsV[0];
	  var du = (umax - umin) / nSplitsU;
	  var dv = (vmax - vmin) / nSplitsV;
	
	  var table = [];
	
	  for (var vIdx = 0; vIdx < nSplitsV + 1; ++vIdx) {
	    var row = [];
	    table.push(row);
	    for (var uIdx = 0; uIdx < nSplitsU + 1; ++uIdx) {
	      var u = umin + du * uIdx;
	      var v = vmin + dv * vIdx;
	      row.push(new UVPoint(u, v, surface));
	    }
	    if (row.length <= 1) {
	      return [];
	    }
	  }
	
	  if (table.length <= 1) {
	    return [];
	  }
	
	  var tiles = [];
	
	  for (var _vIdx = 0; _vIdx < nSplitsV; ++_vIdx) {
	    var _row = [];
	    tiles.push(_row);
	    for (var _uIdx = 0; _uIdx < nSplitsU; ++_uIdx) {
	
	      var bottomOuter = _vIdx == 0 ? 'bottom' : undefined;
	      var leftOuter = _uIdx == 0 ? 'left' : undefined;
	      var topOuter = _vIdx == nSplitsV - 1 ? 'top' : undefined;
	      var rightOuter = _uIdx == nSplitsU - 1 ? 'right' : undefined;
	
	      var left = _uIdx != 0 ? _row[_uIdx - 1].edges[1].twin : new TileEdge(table[_vIdx + 1][_uIdx], table[_vIdx][_uIdx], leftOuter);
	      var bottom = _vIdx != 0 ? tiles[_vIdx - 1][_uIdx].edges[2].twin : new TileEdge(table[_vIdx][_uIdx], table[_vIdx][_uIdx + 1], bottomOuter);
	      var right = new TileEdge(table[_vIdx][_uIdx + 1], table[_vIdx + 1][_uIdx + 1], rightOuter);
	      var top = new TileEdge(table[_vIdx + 1][_uIdx + 1], table[_vIdx + 1][_uIdx], topOuter);
	      _row.push(new Tile(surface, bottom, right, top, left));
	    }
	  }
	  return tiles;
	}
	
	function mid(a, b) {
	  return a == b ? a : (a + b) / 2.0;
	}
	
	function refine(tiles, opts) {
	  opts = opts || {};
	  var uMax = opts.uMax === undefined ? 10 : opts.uMax;
	  var vMax = opts.vMax === undefined ? 10 : opts.vMax;
	  var normTol = 8.5e-2;
	
	  function curvature(a, b) {
	    return a.normal().minus(b.normal()).lengthSquared();
	  }
	
	  function edgeCurvature(e) {
	    return curvature(e.a, e.b);
	  }
	
	  function check(tile, uLevel, vLevel) {
	
	    var horizLimit = vLevel >= vMax;
	    var vertLimit = uLevel >= uMax;
	
	    var splitHoriz = !horizLimit && edgeCurvature(tile.edges[1]) > normTol || edgeCurvature(tile.edges[3]) > normTol;
	    var splitVert = false;
	    if (!splitHoriz && !vertLimit) {
	      splitVert = edgeCurvature(tile.edges[0]) > normTol || edgeCurvature(tile.edges[2]) > normTol;
	      if (!splitVert) {
	        var center = tile.center();
	        splitVert = curvature(center, tile.edges[0].a) > normTol || curvature(center, tile.edges[1].a) > normTol || curvature(center, tile.edges[2].a) > normTol || curvature(center, tile.edges[3].a) > normTol;
	      }
	    }
	
	    if (splitHoriz) {
	      tile.divideHorizontally();
	      vLevel++;
	    } else if (splitVert) {
	      tile.divideVertically();
	      uLevel++;
	    }
	
	    if (tile.children != null) {
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        for (var _iterator2 = tile.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var subTile = _step2.value;
	
	          check(subTile, uLevel, vLevel);
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	    }
	  }
	
	  var _iteratorNormalCompletion3 = true;
	  var _didIteratorError3 = false;
	  var _iteratorError3 = undefined;
	
	  try {
	    for (var _iterator3 = tiles[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	      var row = _step3.value;
	      var _iteratorNormalCompletion4 = true;
	      var _didIteratorError4 = false;
	      var _iteratorError4 = undefined;
	
	      try {
	        for (var _iterator4 = row[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	          var tile = _step4.value;
	
	          check(tile, 0, 0);
	        }
	      } catch (err) {
	        _didIteratorError4 = true;
	        _iteratorError4 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion4 && _iterator4.return) {
	            _iterator4.return();
	          }
	        } finally {
	          if (_didIteratorError4) {
	            throw _iteratorError4;
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError3 = true;
	    _iteratorError3 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion3 && _iterator3.return) {
	        _iterator3.return();
	      }
	    } finally {
	      if (_didIteratorError3) {
	        throw _iteratorError3;
	      }
	    }
	  }
	}

/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (_ref) {
	  var curve = _ref.curve,
	      start = _ref.start;
	
	
	  var aE = start.prev;
	  var bE = start;
	
	  //  let aStop = end;
	  //  let bStop = end.next;
	
	  while (aE.vertexA !== bE.vertexB) {
	
	    var aTip = curve.closestParam(aE.vertexA.point.data());
	    var bTip = curve.closestParam(bE.vertexB.point.data());
	
	    if (math.equal(aTip, bTip)) {
	      //swap vertex everywhere
	      updateVertex(bE, bE, aE.vertexA);
	    } else if (aTip > bTip) {
	      aE.split(bE.vertexB);
	      aE = aE.next;
	    } else if (aTip < bTip) {
	      bE.split(aE.vertexA);
	    } else {
	      throw 'illegal state';
	    }
	    connect(aE, bE);
	    aE = aE.prev;
	    bE = bE.next;
	  }
	};
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	var _edge = __webpack_require__(364);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function connect(aE, bE) {
	  new _edge.Edge(aE.edge.curve).link(aE.twin(), bE.twin());
	}
	
	function updateVertex(edge, stopEdge, vertex) {
	  if (edge === stopEdge) return;
	  var twin = edge.twin();
	  edge.vertexB = twin.vertexA = vertex;
	  updateVertex(twin.prev, stopEdge, vertex);
	}

/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TOLERANCE_HALF = exports.TOLERANCE_SQ = exports.TOLERANCE = undefined;
	exports.union = union;
	exports.intersect = intersect;
	exports.subtract = subtract;
	exports.invert = invert;
	exports.BooleanAlgorithm = BooleanAlgorithm;
	exports.mergeVertices = mergeVertices;
	exports.loopsToFaces = loopsToFaces;
	exports.classifyPointInsideLoop = classifyPointInsideLoop;
	
	var _brepBuilder = __webpack_require__(360);
	
	var BREPBuilder = _interopRequireWildcard(_brepBuilder);
	
	var _brepValidator = __webpack_require__(375);
	
	var _edge3 = __webpack_require__(364);
	
	var _loop5 = __webpack_require__(362);
	
	var _face3 = __webpack_require__(363);
	
	var _shell = __webpack_require__(361);
	
	var _vertex = __webpack_require__(323);
	
	var _line = __webpack_require__(365);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var TOLERANCE = exports.TOLERANCE = 1e-8;
	var TOLERANCE_SQ = exports.TOLERANCE_SQ = TOLERANCE * TOLERANCE;
	var TOLERANCE_HALF = exports.TOLERANCE_HALF = TOLERANCE * 0.5;
	
	var DEBUG = {
	  OPERANDS_MODE: false,
	  LOOP_DETECTION: false,
	  FACE_FACE_INTERSECTION: false,
	  FACE_EDGE_INTERSECTION: false,
	  SEWING: false,
	  EDGE_MERGING: false,
	  NOOP: function NOOP() {}
	};
	
	var TYPE = {
	  UNION: 0,
	  INTERSECT: 1,
	  SUBTRACT: 2
	};
	
	function union(shell1, shell2) {
	  __DEBUG_OPERANDS(shell1, shell2);
	  return BooleanAlgorithm(shell1, shell2, TYPE.UNION);
	}
	
	function intersect(shell1, shell2) {
	  __DEBUG_OPERANDS(shell1, shell2);
	  return BooleanAlgorithm(shell1, shell2, TYPE.INTERSECT);
	}
	
	function subtract(shell1, shell2) {
	  __DEBUG_OPERANDS(shell1, shell2);
	  invert(shell2);
	  return BooleanAlgorithm(shell1, shell2, TYPE.SUBTRACT);
	}
	
	function invert(shell) {
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = shell.faces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var face = _step.value;
	
	      face.surface = face.surface.invert();
	      face.data.INVERTED = !face.data.INVERTED;
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        for (var _iterator2 = face.loops[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var loop = _step2.value;
	
	          invertLoop(loop);
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  _brepValidator.BREPValidator.validateToConsole(shell);
	}
	
	function invertLoop(loop) {
	  BREPBuilder.invertLoop(loop);
	}
	
	function BooleanAlgorithm(shell1, shell2, type) {
	
	  POINT_TO_VERT.clear();
	
	  var facesData = [];
	
	  mergeVertices(shell1, shell2);
	
	  initSolveData(shell1, facesData);
	  initSolveData(shell2, facesData);
	
	  markOverlappingFaces(shell1, shell2);
	  intersectFaces(shell1, shell2, type !== TYPE.UNION);
	
	  var _iteratorNormalCompletion3 = true;
	  var _didIteratorError3 = false;
	  var _iteratorError3 = undefined;
	
	  try {
	    for (var _iterator3 = facesData[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	      var faceData = _step3.value;
	
	      splitNewEdgesIfNeeded(faceData);
	    }
	  } catch (err) {
	    _didIteratorError3 = true;
	    _iteratorError3 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion3 && _iterator3.return) {
	        _iterator3.return();
	      }
	    } finally {
	      if (_didIteratorError3) {
	        throw _iteratorError3;
	      }
	    }
	  }
	
	  var _iteratorNormalCompletion4 = true;
	  var _didIteratorError4 = false;
	  var _iteratorError4 = undefined;
	
	  try {
	    for (var _iterator4 = facesData[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	      var _faceData = _step4.value;
	
	      disassemble(_faceData);
	    }
	  } catch (err) {
	    _didIteratorError4 = true;
	    _iteratorError4 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion4 && _iterator4.return) {
	        _iterator4.return();
	      }
	    } finally {
	      if (_didIteratorError4) {
	        throw _iteratorError4;
	      }
	    }
	  }
	
	  mergeOverlappingFaces(shell1, shell2);
	  var _iteratorNormalCompletion5 = true;
	  var _didIteratorError5 = false;
	  var _iteratorError5 = undefined;
	
	  try {
	    for (var _iterator5 = facesData[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	      var _faceData2 = _step5.value;
	
	      initGraph(_faceData2);
	    }
	  } catch (err) {
	    _didIteratorError5 = true;
	    _iteratorError5 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion5 && _iterator5.return) {
	        _iterator5.return();
	      }
	    } finally {
	      if (_didIteratorError5) {
	        throw _iteratorError5;
	      }
	    }
	  }
	
	  facesData = facesData.filter(function (fd) {
	    return fd.merged !== true;
	  });
	
	  var allFaces = [];
	  var newLoops = new Set();
	  var _iteratorNormalCompletion6 = true;
	  var _didIteratorError6 = false;
	  var _iteratorError6 = undefined;
	
	  try {
	    for (var _iterator6 = facesData[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	      var _faceData3 = _step6.value;
	
	      var face = _faceData3.face;
	      var loops = detectLoops(_faceData3.face);
	      var _iteratorNormalCompletion7 = true;
	      var _didIteratorError7 = false;
	      var _iteratorError7 = undefined;
	
	      try {
	        for (var _iterator7 = loops[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	          var loop = _step7.value;
	          var _iteratorNormalCompletion8 = true;
	          var _didIteratorError8 = false;
	          var _iteratorError8 = undefined;
	
	          try {
	            for (var _iterator8 = loop.halfEdges[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
	              var edge = _step8.value;
	
	              var isNew = EdgeSolveData.get(edge).newEdgeFlag === true;
	              if (isNew) newLoops.add(loop);
	            }
	          } catch (err) {
	            _didIteratorError8 = true;
	            _iteratorError8 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion8 && _iterator8.return) {
	                _iterator8.return();
	              }
	            } finally {
	              if (_didIteratorError8) {
	                throw _iteratorError8;
	              }
	            }
	          }
	        }
	      } catch (err) {
	        _didIteratorError7 = true;
	        _iteratorError7 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion7 && _iterator7.return) {
	            _iterator7.return();
	          }
	        } finally {
	          if (_didIteratorError7) {
	            throw _iteratorError7;
	          }
	        }
	      }
	
	      loopsToFaces(face, loops, allFaces);
	    }
	  } catch (err) {
	    _didIteratorError6 = true;
	    _iteratorError6 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion6 && _iterator6.return) {
	        _iterator6.return();
	      }
	    } finally {
	      if (_didIteratorError6) {
	        throw _iteratorError6;
	      }
	    }
	  }
	
	  var faces = sew(allFaces);
	  faces = filterFaces(faces, newLoops);
	  var result = new _shell.Shell();
	  faces.forEach(function (face) {
	    face.shell = result;
	    result.faces.push(face);
	  });
	
	  cleanUpSolveData(result);
	  _brepValidator.BREPValidator.validateToConsole(result);
	
	  __DEBUG__.ClearVolumes();
	  __DEBUG__.Clear();
	  return result;
	}
	
	function detectLoops(face) {
	  var faceData = face.data[MY];
	  if (DEBUG.LOOP_DETECTION) {
	    __DEBUG__.Clear();
	    __DEBUG__.AddFace(face, 0x00ff00);
	    DEBUG.NOOP();
	  }
	
	  var loops = [];
	  var seen = new Set();
	  var edges = [];
	  var _iteratorNormalCompletion9 = true;
	  var _didIteratorError9 = false;
	  var _iteratorError9 = undefined;
	
	  try {
	    for (var _iterator9 = face.edges[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
	      var e = _step9.value;
	      edges.push(e);
	    }
	  } catch (err) {
	    _didIteratorError9 = true;
	    _iteratorError9 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion9 && _iterator9.return) {
	        _iterator9.return();
	      }
	    } finally {
	      if (_didIteratorError9) {
	        throw _iteratorError9;
	      }
	    }
	  }
	
	  while (true) {
	    var edge = edges.pop();
	    if (!edge) {
	      break;
	    }
	    if (seen.has(edge)) {
	      continue;
	    }
	    var loop = new _loop5.Loop();
	    loop.face = face;
	    var surface = EdgeSolveData.get(edge).transferedSurface;
	    if (!surface) {
	      surface = face.surface;
	    }
	    while (edge) {
	      if (DEBUG.LOOP_DETECTION) {
	        __DEBUG__.AddHalfEdge(edge);
	      }
	      loop.halfEdges.push(edge);
	      seen.add(edge);
	      var candidates = faceData.vertexToEdge.get(edge.vertexB);
	      if (!candidates) {
	        break;
	      }
	      edge = findMaxTurningLeft(edge, candidates, surface.normal);
	      if (seen.has(edge)) {
	        break;
	      }
	    }
	
	    if (loop.halfEdges[0].vertexA == loop.halfEdges[loop.halfEdges.length - 1].vertexB) {
	      var _iteratorNormalCompletion10 = true;
	      var _didIteratorError10 = false;
	      var _iteratorError10 = undefined;
	
	      try {
	        for (var _iterator10 = loop.halfEdges[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
	          var halfEdge = _step10.value;
	
	          halfEdge.loop = loop;
	        }
	      } catch (err) {
	        _didIteratorError10 = true;
	        _iteratorError10 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion10 && _iterator10.return) {
	            _iterator10.return();
	          }
	        } finally {
	          if (_didIteratorError10) {
	            throw _iteratorError10;
	          }
	        }
	      }
	
	      BREPBuilder.linkSegments(loop.halfEdges);
	      loops.push(loop);
	    }
	  }
	  return loops;
	}
	
	function initGraph(faceData) {
	  faceData.vertexToEdge.clear();
	  var _iteratorNormalCompletion11 = true;
	  var _didIteratorError11 = false;
	  var _iteratorError11 = undefined;
	
	  try {
	    for (var _iterator11 = faceData.face.edges[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
	      var he = _step11.value;
	
	      addToListInMap(faceData.vertexToEdge, he.vertexA, he);
	    }
	  } catch (err) {
	    _didIteratorError11 = true;
	    _iteratorError11 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion11 && _iterator11.return) {
	        _iterator11.return();
	      }
	    } finally {
	      if (_didIteratorError11) {
	        throw _iteratorError11;
	      }
	    }
	  }
	}
	
	function sew(allFaces) {
	
	  var sewed = new Set();
	  var sewedFaces = [];
	  var analyzedNeighbors = new Map();
	  var _iteratorNormalCompletion12 = true;
	  var _didIteratorError12 = false;
	  var _iteratorError12 = undefined;
	
	  try {
	    FACES: for (var _iterator12 = allFaces[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
	      var face = _step12.value;
	
	      if (DEBUG.SEWING) {
	        __DEBUG__.Clear();
	        __DEBUG__.AddFace(face, 0x00ff00);
	      }
	      var edges = [];
	      var _iteratorNormalCompletion13 = true;
	      var _didIteratorError13 = false;
	      var _iteratorError13 = undefined;
	
	      try {
	        for (var _iterator13 = face.edges[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
	          var e = _step13.value;
	          edges.push(e);
	        }
	      } catch (err) {
	        _didIteratorError13 = true;
	        _iteratorError13 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion13 && _iterator13.return) {
	            _iterator13.return();
	          }
	        } finally {
	          if (_didIteratorError13) {
	            throw _iteratorError13;
	          }
	        }
	      }
	
	      edges.sort(function (e1, e2) {
	        return EdgeSolveData.get(e1).newEdgeFlag === true ? 0 : 1;
	      });
	      var _iteratorNormalCompletion14 = true;
	      var _didIteratorError14 = false;
	      var _iteratorError14 = undefined;
	
	      try {
	        for (var _iterator14 = face.edges[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
	          var h1 = _step14.value;
	
	          if (DEBUG.SEWING) {
	            __DEBUG__.AddHalfEdge(h1);
	          }
	
	          if (sewed.has(h1)) {
	            continue;
	          }
	          var neighborhood = findNeighborhood(allFaces, face, h1);
	          if (neighborhood.all.length == 1) {
	            continue FACES;
	          }
	
	          var h2 = void 0;
	          if (neighborhood.all.length == 2 && neighborhood.side2.length == 1) {
	            h2 = neighborhood.side2[0];
	          } else {
	            h2 = analyzedNeighbors.get(h1);
	            if (h2 === undefined) {
	              // null indicates edge can't be sewed
	              neighborhoodAnalysis(neighborhood, analyzedNeighbors);
	            }
	            h2 = analyzedNeighbors.get(h1);
	          }
	
	          if (h2 == null) {
	            continue FACES;
	          }
	          if (sewed.has(h2)) {
	            throw 'illegal state. already sewed';
	          }
	
	          var edge = new _edge3.Edge(h1.edge.curve);
	
	          edge.halfEdge1 = h1;
	          edge.halfEdge2 = h2;
	          h1.edge = edge;
	          h2.edge = edge;
	          sewed.add(h1);
	          sewed.add(h2);
	        }
	      } catch (err) {
	        _didIteratorError14 = true;
	        _iteratorError14 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion14 && _iterator14.return) {
	            _iterator14.return();
	          }
	        } finally {
	          if (_didIteratorError14) {
	            throw _iteratorError14;
	          }
	        }
	      }
	
	      sewedFaces.push(face);
	    }
	  } catch (err) {
	    _didIteratorError12 = true;
	    _iteratorError12 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion12 && _iterator12.return) {
	        _iterator12.return();
	      }
	    } finally {
	      if (_didIteratorError12) {
	        throw _iteratorError12;
	      }
	    }
	  }
	
	  return sewedFaces;
	}
	
	function edgeV(edge) {
	  return edge.vertexB.point.minus(edge.vertexA.point)._normalize();
	}
	
	function neighborhoodAnalysis(neighborhood, analized) {
	
	  function encloses(e1, e2, testeeE) {
	    var f1 = e1.loop.face;
	    var f2 = e2.loop.face;
	    var testee = testeeE.loop.face;
	
	    var normal = edgeV(e1);
	    var t1 = f1.surface.normal.cross(normal)._normalize();
	    var t2 = f2.surface.normal.cross(edgeV(e2))._normalize();
	    var t3 = testee.surface.normal.cross(edgeV(testeeE))._normalize();
	
	    //__DEBUG__.AddSegment(e1.vertexA.point, e1.vertexA.point.plus(normal.multiply(100)), 0xffffff);
	    //__DEBUG__.AddSegment(e1.vertexA.point, e1.vertexA.point.plus(t1.multiply(100)), 0x00ff00);
	    //__DEBUG__.AddSegment(e1.vertexA.point, e1.vertexA.point.plus(t2.multiply(100)), 0x00ffff);
	    //__DEBUG__.AddSegment(e1.vertexA.point, e1.vertexA.point.plus(t3.multiply(100)), 0xff0000);
	
	    var angle = leftTurningMeasure(t1, t2, normal);
	    var testAngle = leftTurningMeasure(t1, t3, normal);
	    return testAngle > angle;
	  }
	
	  var paired = new Set();
	  var _iteratorNormalCompletion15 = true;
	  var _didIteratorError15 = false;
	  var _iteratorError15 = undefined;
	
	  try {
	    for (var _iterator15 = neighborhood.side1[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
	      var e1 = _step15.value;
	      var _iteratorNormalCompletion17 = true;
	      var _didIteratorError17 = false;
	      var _iteratorError17 = undefined;
	
	      try {
	        SIDE_2: for (var _iterator17 = neighborhood.side2[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
	          var e2 = _step17.value;
	
	          if (analized.has(e2)) continue;
	          var _iteratorNormalCompletion18 = true;
	          var _didIteratorError18 = false;
	          var _iteratorError18 = undefined;
	
	          try {
	            for (var _iterator18 = neighborhood.all[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
	              var t = _step18.value;
	
	              if (t == e1 || t == e2) {
	                continue;
	              }
	              if (encloses(e1, e2, t)) {
	                continue SIDE_2;
	              }
	            }
	          } catch (err) {
	            _didIteratorError18 = true;
	            _iteratorError18 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion18 && _iterator18.return) {
	                _iterator18.return();
	              }
	            } finally {
	              if (_didIteratorError18) {
	                throw _iteratorError18;
	              }
	            }
	          }
	
	          analized.set(e1, e2);
	          analized.set(e2, e1);
	          paired.add(e1);
	          paired.add(e2);
	        }
	      } catch (err) {
	        _didIteratorError17 = true;
	        _iteratorError17 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion17 && _iterator17.return) {
	            _iterator17.return();
	          }
	        } finally {
	          if (_didIteratorError17) {
	            throw _iteratorError17;
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError15 = true;
	    _iteratorError15 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion15 && _iterator15.return) {
	        _iterator15.return();
	      }
	    } finally {
	      if (_didIteratorError15) {
	        throw _iteratorError15;
	      }
	    }
	  }
	
	  var _iteratorNormalCompletion16 = true;
	  var _didIteratorError16 = false;
	  var _iteratorError16 = undefined;
	
	  try {
	    for (var _iterator16 = neighborhood.all[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
	      var e = _step16.value;
	
	      if (!paired.has(e)) {
	        analized.set(e, null);
	      }
	    }
	  } catch (err) {
	    _didIteratorError16 = true;
	    _iteratorError16 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion16 && _iterator16.return) {
	        _iterator16.return();
	      }
	    } finally {
	      if (_didIteratorError16) {
	        throw _iteratorError16;
	      }
	    }
	  }
	}
	
	function findNeighborhood(allFaces, skipFace, forEdge) {
	  var result = {
	    side1: [forEdge],
	    side2: [],
	    all: [forEdge]
	  };
	
	  var _iteratorNormalCompletion19 = true;
	  var _didIteratorError19 = false;
	  var _iteratorError19 = undefined;
	
	  try {
	    for (var _iterator19 = allFaces[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
	      var face = _step19.value;
	
	      if (face == skipFace) continue;
	      var _iteratorNormalCompletion20 = true;
	      var _didIteratorError20 = false;
	      var _iteratorError20 = undefined;
	
	      try {
	        for (var _iterator20 = face.edges[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
	          var e = _step20.value;
	
	          if (areEdgesOpposite(e, forEdge)) {
	            result.side2.push(e);
	            result.all.push(e);
	          } else if (e != forEdge && areEdgesEqual(e, forEdge)) {
	            result.side1.push(e);
	            result.all.push(e);
	          }
	        }
	      } catch (err) {
	        _didIteratorError20 = true;
	        _iteratorError20 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion20 && _iterator20.return) {
	            _iterator20.return();
	          }
	        } finally {
	          if (_didIteratorError20) {
	            throw _iteratorError20;
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError19 = true;
	    _iteratorError19 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion19 && _iterator19.return) {
	        _iterator19.return();
	      }
	    } finally {
	      if (_didIteratorError19) {
	        throw _iteratorError19;
	      }
	    }
	  }
	
	  return result;
	}
	
	function mergeVertices(shell1, shell2) {
	  var toSwap = new Map();
	  var _iteratorNormalCompletion21 = true;
	  var _didIteratorError21 = false;
	  var _iteratorError21 = undefined;
	
	  try {
	    for (var _iterator21 = shell1.vertices[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
	      var v1 = _step21.value;
	      var _iteratorNormalCompletion23 = true;
	      var _didIteratorError23 = false;
	      var _iteratorError23 = undefined;
	
	      try {
	        for (var _iterator23 = shell2.vertices[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
	          var v2 = _step23.value;
	
	          if (math.areVectorsEqual(v1.point, v2.point, TOLERANCE)) {
	            toSwap.set(v2, v1);
	          }
	        }
	      } catch (err) {
	        _didIteratorError23 = true;
	        _iteratorError23 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion23 && _iterator23.return) {
	            _iterator23.return();
	          }
	        } finally {
	          if (_didIteratorError23) {
	            throw _iteratorError23;
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError21 = true;
	    _iteratorError21 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion21 && _iterator21.return) {
	        _iterator21.return();
	      }
	    } finally {
	      if (_didIteratorError21) {
	        throw _iteratorError21;
	      }
	    }
	  }
	
	  var _iteratorNormalCompletion22 = true;
	  var _didIteratorError22 = false;
	  var _iteratorError22 = undefined;
	
	  try {
	    for (var _iterator22 = shell2.faces[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
	      var face = _step22.value;
	      var _iteratorNormalCompletion24 = true;
	      var _didIteratorError24 = false;
	      var _iteratorError24 = undefined;
	
	      try {
	        for (var _iterator24 = face.edges[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
	          var h = _step24.value;
	
	          var aSwap = toSwap.get(h.vertexA);
	          var bSwap = toSwap.get(h.vertexB);
	          if (aSwap) {
	            h.vertexA = aSwap;
	          }
	          if (bSwap) {
	            h.vertexB = bSwap;
	          }
	        }
	      } catch (err) {
	        _didIteratorError24 = true;
	        _iteratorError24 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion24 && _iterator24.return) {
	            _iterator24.return();
	          }
	        } finally {
	          if (_didIteratorError24) {
	            throw _iteratorError24;
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError22 = true;
	    _iteratorError22 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion22 && _iterator22.return) {
	        _iterator22.return();
	      }
	    } finally {
	      if (_didIteratorError22) {
	        throw _iteratorError22;
	      }
	    }
	  }
	}
	
	function markOverlappingFaces(shell1, shell2) {
	  var _iteratorNormalCompletion25 = true;
	  var _didIteratorError25 = false;
	  var _iteratorError25 = undefined;
	
	  try {
	    for (var _iterator25 = shell1.faces[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
	      var face1 = _step25.value;
	      var _iteratorNormalCompletion26 = true;
	      var _didIteratorError26 = false;
	      var _iteratorError26 = undefined;
	
	      try {
	        for (var _iterator26 = shell2.faces[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
	          var face2 = _step26.value;
	
	          if (face1.surface.coplanarUnsigned(face2.surface, TOLERANCE)) {
	            markOverlapping(face1, face2);
	          }
	        }
	      } catch (err) {
	        _didIteratorError26 = true;
	        _iteratorError26 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion26 && _iterator26.return) {
	            _iterator26.return();
	          }
	        } finally {
	          if (_didIteratorError26) {
	            throw _iteratorError26;
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError25 = true;
	    _iteratorError25 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion25 && _iterator25.return) {
	        _iterator25.return();
	      }
	    } finally {
	      if (_didIteratorError25) {
	        throw _iteratorError25;
	      }
	    }
	  }
	}
	
	function markOverlapping(face1, face2) {
	  var data1 = face1.data[MY];
	  var data2 = face2.data[MY];
	  data1.overlaps.add(face2);
	  data2.overlaps.add(face1);
	}
	
	function mergeOverlappingFaces(shell1, shell2) {
	  var merged = new Set();
	  var _iteratorNormalCompletion27 = true;
	  var _didIteratorError27 = false;
	  var _iteratorError27 = undefined;
	
	  try {
	    for (var _iterator27 = shell1.faces[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
	      var face1 = _step27.value;
	
	      if (merged.has(face1)) continue;
	      var data1 = face1.data[MY];
	      if (data1.overlaps.size != 0) {
	        var others = data1.overlaps.values().next().value.data[MY].overlaps;
	        var _iteratorNormalCompletion28 = true;
	        var _didIteratorError28 = false;
	        var _iteratorError28 = undefined;
	
	        try {
	          for (var _iterator28 = others[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
	            var face3 = _step28.value;
	
	            if (face1 == face3) {
	              continue;
	            }
	            doMergeOverlappingFaces(face1, face3, true);
	            merged.add(face3);
	          }
	        } catch (err) {
	          _didIteratorError28 = true;
	          _iteratorError28 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion28 && _iterator28.return) {
	              _iterator28.return();
	            }
	          } finally {
	            if (_didIteratorError28) {
	              throw _iteratorError28;
	            }
	          }
	        }
	
	        var _iteratorNormalCompletion29 = true;
	        var _didIteratorError29 = false;
	        var _iteratorError29 = undefined;
	
	        try {
	          for (var _iterator29 = data1.overlaps[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {
	            var face2 = _step29.value;
	
	            doMergeOverlappingFaces(face1, face2, false);
	            face2.data[MY].merged = true;
	          }
	        } catch (err) {
	          _didIteratorError29 = true;
	          _iteratorError29 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion29 && _iterator29.return) {
	              _iterator29.return();
	            }
	          } finally {
	            if (_didIteratorError29) {
	              throw _iteratorError29;
	            }
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError27 = true;
	    _iteratorError27 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion27 && _iterator27.return) {
	        _iterator27.return();
	      }
	    } finally {
	      if (_didIteratorError27) {
	        throw _iteratorError27;
	      }
	    }
	  }
	}
	
	function doMergeOverlappingFaces(face1, face2, keepNew) {
	  var data2 = face2.data[MY];
	
	  var allEdges = [];
	  var _iteratorNormalCompletion30 = true;
	  var _didIteratorError30 = false;
	  var _iteratorError30 = undefined;
	
	  try {
	    for (var _iterator30 = face1.edges[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
	      var e = _step30.value;
	
	      allEdges.push(e);
	    }
	  } catch (err) {
	    _didIteratorError30 = true;
	    _iteratorError30 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion30 && _iterator30.return) {
	        _iterator30.return();
	      }
	    } finally {
	      if (_didIteratorError30) {
	        throw _iteratorError30;
	      }
	    }
	  }
	
	  var _iteratorNormalCompletion31 = true;
	  var _didIteratorError31 = false;
	  var _iteratorError31 = undefined;
	
	  try {
	    for (var _iterator31 = face2.edges[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {
	      var _e = _step31.value;
	
	      var coi = findCoincidentEdge(_e, allEdges);
	      if (coi == null) {
	        EdgeSolveData.createIfEmpty(_e).transferedSurface = face2.surface;
	        allEdges.push(_e);
	      } else {
	        if (EdgeSolveData.get(coi).newEdgeFlag === true) {
	          if (keepNew) {
	            EdgeSolveData.createIfEmpty(_e).newEdgeFlag = true;
	          } else {
	            EdgeSolveData.createIfEmpty(_e).transferedSurface = face2.surface;
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError31 = true;
	    _iteratorError31 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion31 && _iterator31.return) {
	        _iterator31.return();
	      }
	    } finally {
	      if (_didIteratorError31) {
	        throw _iteratorError31;
	      }
	    }
	  }
	
	  function sort(edges) {
	    function edgeOrder(e) {
	      if (EdgeSolveData.get(e).transferedSurface !== undefined) {
	        return EdgeSolveData.get(e).newEdgeFlag === true ? 2 : 1;
	      } else if (EdgeSolveData.get(e).newEdgeFlag === true) {
	        return 3;
	      } else return 0;
	    }
	    edges.sort(function (e1, e2) {
	      return edgeOrder(e1) - edgeOrder(e2);
	    });
	  }
	
	  nullifyOppositeEdges(allEdges);
	  allEdges = allEdges.filter(function (e) {
	    return e != null;
	  });
	  sort(allEdges);
	  squash(face1, allEdges);
	  data2.merged = true;
	}
	
	function squash(face, edges) {
	  face.outerLoop = new _loop5.Loop();
	  face.outerLoop.face = face;
	  edges.forEach(function (he) {
	    return face.outerLoop.halfEdges.push(he);
	  });
	  face.innerLoops = [];
	}
	
	function areEdgesEqual(e1, e2) {
	  return e1.vertexA == e2.vertexA && e1.vertexB == e2.vertexB;
	}
	
	function areEdgesOpposite(e1, e2) {
	  return e1.vertexA == e2.vertexB && e1.vertexB == e2.vertexA;
	}
	
	function splitNewEdgesIfNeeded(faceData) {
	  var _iteratorNormalCompletion32 = true;
	  var _didIteratorError32 = false;
	  var _iteratorError32 = undefined;
	
	  try {
	    for (var _iterator32 = faceData.face.edges[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
	      var oe = _step32.value;
	
	      var _loop = function _loop(i) {
	        var ne = faceData.newEdges[i];
	        if (math.areEqual(Math.abs(ne.edge.curve.v.dot(oe.edge.curve.v)), 1, TOLERANCE) && math.areEqual(Math.abs(ne.edge.curve.v.dot(ne.vertexA.point.minus(oe.vertexA.point)._normalize())), 1, TOLERANCE)) {
	          var check = function check(vertex) {
	            var line = _line.Line.fromSegment(ne.vertexA.point, ne.vertexB.point);
	            var length = math.distanceAB3(ne.vertexA.point, ne.vertexB.point);
	            if (ne.vertexA != vertex && ne.vertexB != vertex) {
	              var t = line.t(vertex.point);
	              if (t >= 0 && t <= length) {
	                splitEdgeByVertex(ne, vertex);
	              }
	            }
	          };
	
	          check(oe.vertexA);
	          check(oe.vertexB);
	        }
	      };
	
	      for (var i = 0; i < faceData.newEdges.length; ++i) {
	        _loop(i);
	      }
	    }
	  } catch (err) {
	    _didIteratorError32 = true;
	    _iteratorError32 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion32 && _iterator32.return) {
	        _iterator32.return();
	      }
	    } finally {
	      if (_didIteratorError32) {
	        throw _iteratorError32;
	      }
	    }
	  }
	}
	
	function disassemble(faceData) {
	  merge(faceData.face, faceData.newEdges);
	}
	
	function merge(face, newEdges) {
	
	  var allEdges = [];
	  if (DEBUG.EDGE_MERGING) {
	    __DEBUG__.Clear();
	    __DEBUG__.AddFace(face, 0x00ff00);
	  }
	
	  var _iteratorNormalCompletion33 = true;
	  var _didIteratorError33 = false;
	  var _iteratorError33 = undefined;
	
	  try {
	    for (var _iterator33 = face.edges[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {
	      var _e2 = _step33.value;
	
	      if (findCoincidentEdge(_e2, allEdges) == null) {
	        allEdges.push(_e2);
	      }
	    }
	  } catch (err) {
	    _didIteratorError33 = true;
	    _iteratorError33 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion33 && _iterator33.return) {
	        _iterator33.return();
	      }
	    } finally {
	      if (_didIteratorError33) {
	        throw _iteratorError33;
	      }
	    }
	  }
	
	  nullifyOppositeEdges(newEdges);
	
	  var _iteratorNormalCompletion34 = true;
	  var _didIteratorError34 = false;
	  var _iteratorError34 = undefined;
	
	  try {
	    for (var _iterator34 = newEdges[Symbol.iterator](), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {
	      var _e3 = _step34.value;
	
	      if (_e3 == null) continue;
	      var existingEdge = findCoincidentEdge(_e3, allEdges);
	      if (existingEdge == null) {
	        allEdges.push(_e3);
	      } else {
	        EdgeSolveData.createIfEmpty(existingEdge).newEdgeFlag = true;
	      }
	    }
	  } catch (err) {
	    _didIteratorError34 = true;
	    _iteratorError34 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion34 && _iterator34.return) {
	        _iterator34.return();
	      }
	    } finally {
	      if (_didIteratorError34) {
	        throw _iteratorError34;
	      }
	    }
	  }
	
	  nullifyOppositeEdges(allEdges);
	
	  allEdges = allEdges.filter(function (e) {
	    return e != null;
	  });
	  //put new edges to the tail
	  bringNewEdgesToTheTail(allEdges);
	  squash(face, allEdges);
	  if (DEBUG.EDGE_MERGING) {
	    var _iteratorNormalCompletion35 = true;
	    var _didIteratorError35 = false;
	    var _iteratorError35 = undefined;
	
	    try {
	      for (var _iterator35 = allEdges[Symbol.iterator](), _step35; !(_iteratorNormalCompletion35 = (_step35 = _iterator35.next()).done); _iteratorNormalCompletion35 = true) {
	        var e = _step35.value;
	        __DEBUG__.AddHalfEdge(e, 0xffff00);
	      }
	    } catch (err) {
	      _didIteratorError35 = true;
	      _iteratorError35 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion35 && _iterator35.return) {
	          _iterator35.return();
	        }
	      } finally {
	        if (_didIteratorError35) {
	          throw _iteratorError35;
	        }
	      }
	    }
	  }
	}
	
	function bringNewEdgesToTheTail(edges) {
	  function edgeOrder(e) {
	    return EdgeSolveData.get(e).newEdgeFlag === true ? 1 : 0;
	  }
	  edges.sort(function (e1, e2) {
	    return edgeOrder(e1) - edgeOrder(e2);
	  });
	}
	
	function nullifyOppositeEdges(edges) {
	  main: for (var i = 0; i < edges.length; i++) {
	    if (edges[i] == null) continue;
	    for (var j = 0; j < edges.length; j++) {
	      if (i == j) continue;
	      if (edges[j] == null) continue;
	      if (areEdgesOpposite(edges[i], edges[j])) {
	        edges[i] = null;
	        edges[j] = null;
	        continue main;
	      }
	    }
	  }
	}
	
	function isEdgeInvalid(e) {
	  return EdgeSolveData.get(e).invalid === true;
	}
	
	function chooseBetweenSimilarEdges(e1, e2) {
	  // assert e1.vertexB == e2.vertexB
	  var v = e1.vertexB;
	  var face1 = e1.twin().face;
	  var face2 = e2.twin().face;
	  var data1 = face1.data[MY];
	  var data2 = face2.data[MY];
	  var cont1 = data1.vertexToEdge(v).filter(function (e) {
	    return data1.newEdges.indexOf(e) == -1;
	  })[0];
	  var cont2 = data2.vertexToEdge(v).filter(function (e) {
	    return data2.newEdges.indexOf(e) == -1;
	  })[0];
	  if (cont1 && areEdgesOpposite(cont1, e1)) {
	    deleteEdge(e2.edge);
	  } else if (cont2 && areEdgesOpposite(cont2, e1)) {
	    // e1 ~ e2 , doesn't matter
	    deleteEdge(e1.edge);
	  }
	}
	
	function findCoincidentEdgeOnFace(edge, face) {
	  var _iteratorNormalCompletion36 = true;
	  var _didIteratorError36 = false;
	  var _iteratorError36 = undefined;
	
	  try {
	    for (var _iterator36 = face.loops[Symbol.iterator](), _step36; !(_iteratorNormalCompletion36 = (_step36 = _iterator36.next()).done); _iteratorNormalCompletion36 = true) {
	      var loop = _step36.value;
	
	      var coi = findCoincidentEdge(edge, loop.halfEdges);
	      if (coi != null) {
	        return coi;
	      }
	    }
	  } catch (err) {
	    _didIteratorError36 = true;
	    _iteratorError36 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion36 && _iterator36.return) {
	        _iterator36.return();
	      }
	    } finally {
	      if (_didIteratorError36) {
	        throw _iteratorError36;
	      }
	    }
	  }
	
	  return null;
	}
	
	function findCoincidentEdge(edge, edges) {
	  var _iteratorNormalCompletion37 = true;
	  var _didIteratorError37 = false;
	  var _iteratorError37 = undefined;
	
	  try {
	    for (var _iterator37 = edges[Symbol.iterator](), _step37; !(_iteratorNormalCompletion37 = (_step37 = _iterator37.next()).done); _iteratorNormalCompletion37 = true) {
	      var he = _step37.value;
	
	      if (areEdgesEqual(edge, he)) {
	        return he;
	      }
	    }
	  } catch (err) {
	    _didIteratorError37 = true;
	    _iteratorError37 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion37 && _iterator37.return) {
	        _iterator37.return();
	      }
	    } finally {
	      if (_didIteratorError37) {
	        throw _iteratorError37;
	      }
	    }
	  }
	
	  return null;
	}
	
	function findOppositeEdge(edge, edges) {
	  var _iteratorNormalCompletion38 = true;
	  var _didIteratorError38 = false;
	  var _iteratorError38 = undefined;
	
	  try {
	    for (var _iterator38 = edges[Symbol.iterator](), _step38; !(_iteratorNormalCompletion38 = (_step38 = _iterator38.next()).done); _iteratorNormalCompletion38 = true) {
	      var he = _step38.value;
	
	      if (areEdgesOpposite(edge, he)) {
	        return he;
	      }
	    }
	  } catch (err) {
	    _didIteratorError38 = true;
	    _iteratorError38 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion38 && _iterator38.return) {
	        _iterator38.return();
	      }
	    } finally {
	      if (_didIteratorError38) {
	        throw _iteratorError38;
	      }
	    }
	  }
	
	  return null;
	}
	
	function filterFaces(faces, newLoops, validLoops) {
	  var validFaces = new Set(faces);
	  var result = new Set();
	  var _iteratorNormalCompletion39 = true;
	  var _didIteratorError39 = false;
	  var _iteratorError39 = undefined;
	
	  try {
	    var _loop2 = function _loop2() {
	      var face = _step39.value;
	
	      traverseFaces(face, validFaces, function (it) {
	        if (result.has(it) || isFaceContainNewLoop(it, newLoops)) {
	          result.add(face);
	          return true;
	        }
	      });
	    };
	
	    for (var _iterator39 = faces[Symbol.iterator](), _step39; !(_iteratorNormalCompletion39 = (_step39 = _iterator39.next()).done); _iteratorNormalCompletion39 = true) {
	      _loop2();
	    }
	  } catch (err) {
	    _didIteratorError39 = true;
	    _iteratorError39 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion39 && _iterator39.return) {
	        _iterator39.return();
	      }
	    } finally {
	      if (_didIteratorError39) {
	        throw _iteratorError39;
	      }
	    }
	  }
	
	  return result;
	}
	
	function isFaceContainNewLoop(face, newLoops) {
	  var _iteratorNormalCompletion40 = true;
	  var _didIteratorError40 = false;
	  var _iteratorError40 = undefined;
	
	  try {
	    for (var _iterator40 = face.loops[Symbol.iterator](), _step40; !(_iteratorNormalCompletion40 = (_step40 = _iterator40.next()).done); _iteratorNormalCompletion40 = true) {
	      var loop = _step40.value;
	
	      if (newLoops.has(loop)) {
	        return true;
	      }
	    }
	  } catch (err) {
	    _didIteratorError40 = true;
	    _iteratorError40 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion40 && _iterator40.return) {
	        _iterator40.return();
	      }
	    } finally {
	      if (_didIteratorError40) {
	        throw _iteratorError40;
	      }
	    }
	  }
	
	  return false;
	}
	
	function traverseFaces(face, validFaces, callback) {
	  var stack = [face];
	  var seen = new Set();
	  while (stack.length !== 0) {
	    face = stack.pop();
	    if (seen.has(face)) continue;
	    seen.add(face);
	    if (callback(face) === true) {
	      return;
	    }
	    var _iteratorNormalCompletion41 = true;
	    var _didIteratorError41 = false;
	    var _iteratorError41 = undefined;
	
	    try {
	      for (var _iterator41 = face.loops[Symbol.iterator](), _step41; !(_iteratorNormalCompletion41 = (_step41 = _iterator41.next()).done); _iteratorNormalCompletion41 = true) {
	        var loop = _step41.value;
	
	        if (!validFaces.has(face)) continue;
	        var _iteratorNormalCompletion42 = true;
	        var _didIteratorError42 = false;
	        var _iteratorError42 = undefined;
	
	        try {
	          for (var _iterator42 = loop.halfEdges[Symbol.iterator](), _step42; !(_iteratorNormalCompletion42 = (_step42 = _iterator42.next()).done); _iteratorNormalCompletion42 = true) {
	            var halfEdge = _step42.value;
	
	            var twin = halfEdge.twin();
	            if (validFaces.has(twin.loop.face)) {
	              stack.push(twin.loop.face);
	            }
	          }
	        } catch (err) {
	          _didIteratorError42 = true;
	          _iteratorError42 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion42 && _iterator42.return) {
	              _iterator42.return();
	            }
	          } finally {
	            if (_didIteratorError42) {
	              throw _iteratorError42;
	            }
	          }
	        }
	      }
	    } catch (err) {
	      _didIteratorError41 = true;
	      _iteratorError41 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion41 && _iterator41.return) {
	          _iterator41.return();
	        }
	      } finally {
	        if (_didIteratorError41) {
	          throw _iteratorError41;
	        }
	      }
	    }
	  }
	}
	
	function loopsToFaces(originFace, loops, out) {
	  var originSurface = originFace.surface;
	  var invertedSurface = null;
	  function invertSurface(surface) {
	    if (surface == originSurface) {
	      if (invertedSurface == null) {
	        invertedSurface = originSurface.invert();
	      }
	      return invertedSurface;
	    } else {
	      return originSurface;
	    }
	  }
	
	  function createFaces(nestedLoop, surface, level) {
	    if (!nestedLoop.loop.isCCW(surface)) {
	      surface = invertSurface(surface);
	    }
	
	    var loop = nestedLoop.loop;
	    var newFace = new _face3.Face(surface);
	    Object.assign(newFace.data, originFace.data);
	    newFace.outerLoop = loop;
	    loop.face = newFace;
	    out.push(newFace);
	
	    var _iteratorNormalCompletion43 = true;
	    var _didIteratorError43 = false;
	    var _iteratorError43 = undefined;
	
	    try {
	      for (var _iterator43 = nestedLoop.nesting[Symbol.iterator](), _step43; !(_iteratorNormalCompletion43 = (_step43 = _iterator43.next()).done); _iteratorNormalCompletion43 = true) {
	        var child = _step43.value;
	
	        if (child.level == level + 2) {
	          createFaces(child, surface, level + 2);
	        } else if (child.level == level + 1) {
	          if (!child.loop.isCCW(surface)) {
	            child.loop.face = newFace;
	            newFace.innerLoops.push(child.loop);
	          } else {
	            createFaces(child, surface, level + 1);
	          }
	        }
	      }
	    } catch (err) {
	      _didIteratorError43 = true;
	      _iteratorError43 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion43 && _iterator43.return) {
	          _iterator43.return();
	        }
	      } finally {
	        if (_didIteratorError43) {
	          throw _iteratorError43;
	        }
	      }
	    }
	  }
	  var beforeLength = out.length;
	  var nestedLoops = getNestedLoops(originFace, loops);
	  var _iteratorNormalCompletion44 = true;
	  var _didIteratorError44 = false;
	  var _iteratorError44 = undefined;
	
	  try {
	    for (var _iterator44 = nestedLoops[Symbol.iterator](), _step44; !(_iteratorNormalCompletion44 = (_step44 = _iterator44.next()).done); _iteratorNormalCompletion44 = true) {
	      var nestedLoop = _step44.value;
	
	      if (nestedLoop.level == 0) {
	        createFaces(nestedLoop, originSurface, 0);
	      }
	    }
	  } catch (err) {
	    _didIteratorError44 = true;
	    _iteratorError44 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion44 && _iterator44.return) {
	        _iterator44.return();
	      }
	    } finally {
	      if (_didIteratorError44) {
	        throw _iteratorError44;
	      }
	    }
	  }
	
	  if (out.length > beforeLength) {
	    out[beforeLength].id = originFace.id;
	  }
	}
	
	function getNestedLoops(face, brepLoops) {
	  function NestedLoop(loop) {
	    this.loop = loop;
	    this.nesting = [];
	    this.level = 0;
	  }
	
	  var loops = brepLoops.map(function (loop) {
	    return new NestedLoop(loop);
	  });
	  function contains(loop, other) {
	    var _iteratorNormalCompletion45 = true;
	    var _didIteratorError45 = false;
	    var _iteratorError45 = undefined;
	
	    try {
	      for (var _iterator45 = other.asPolygon()[Symbol.iterator](), _step45; !(_iteratorNormalCompletion45 = (_step45 = _iterator45.next()).done); _iteratorNormalCompletion45 = true) {
	        var point = _step45.value;
	
	        if (!classifyPointInsideLoop(point, loop, face.surface).inside) {
	          return false;
	        }
	      }
	    } catch (err) {
	      _didIteratorError45 = true;
	      _iteratorError45 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion45 && _iterator45.return) {
	          _iterator45.return();
	        }
	      } finally {
	        if (_didIteratorError45) {
	          throw _iteratorError45;
	        }
	      }
	    }
	
	    return true;
	  }
	  for (var i = 0; i < loops.length; ++i) {
	    var loop = loops[i];
	    for (var j = 0; j < loops.length; ++j) {
	      if (i == j) continue;
	      var other = loops[j];
	      if (contains(loop.loop, other.loop)) {
	        loop.nesting.push(other);
	        other.level++;
	      }
	    }
	  }
	  return loops.filter(function (l) {
	    return l.level == 0;
	  });
	}
	
	function initSolveData(shell, facesData) {
	  var _iteratorNormalCompletion46 = true;
	  var _didIteratorError46 = false;
	  var _iteratorError46 = undefined;
	
	  try {
	    for (var _iterator46 = shell.faces[Symbol.iterator](), _step46; !(_iteratorNormalCompletion46 = (_step46 = _iterator46.next()).done); _iteratorNormalCompletion46 = true) {
	      var _face = _step46.value;
	
	      var solveData = new FaceSolveData(_face);
	      facesData.push(solveData);
	      _face.data[MY] = solveData;
	      var _iteratorNormalCompletion47 = true;
	      var _didIteratorError47 = false;
	      var _iteratorError47 = undefined;
	
	      try {
	        for (var _iterator47 = _face.edges[Symbol.iterator](), _step47; !(_iteratorNormalCompletion47 = (_step47 = _iterator47.next()).done); _iteratorNormalCompletion47 = true) {
	          var he = _step47.value;
	
	          EdgeSolveData.clear(he);
	        }
	      } catch (err) {
	        _didIteratorError47 = true;
	        _iteratorError47 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion47 && _iterator47.return) {
	            _iterator47.return();
	          }
	        } finally {
	          if (_didIteratorError47) {
	            throw _iteratorError47;
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError46 = true;
	    _iteratorError46 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion46 && _iterator46.return) {
	        _iterator46.return();
	      }
	    } finally {
	      if (_didIteratorError46) {
	        throw _iteratorError46;
	      }
	    }
	  }
	}
	
	function cleanUpSolveData(shell) {
	  var _iteratorNormalCompletion48 = true;
	  var _didIteratorError48 = false;
	  var _iteratorError48 = undefined;
	
	  try {
	    for (var _iterator48 = shell.faces[Symbol.iterator](), _step48; !(_iteratorNormalCompletion48 = (_step48 = _iterator48.next()).done); _iteratorNormalCompletion48 = true) {
	      var _face2 = _step48.value;
	
	      delete _face2.data[MY];
	      var _iteratorNormalCompletion49 = true;
	      var _didIteratorError49 = false;
	      var _iteratorError49 = undefined;
	
	      try {
	        for (var _iterator49 = _face2.edges[Symbol.iterator](), _step49; !(_iteratorNormalCompletion49 = (_step49 = _iterator49.next()).done); _iteratorNormalCompletion49 = true) {
	          var he = _step49.value;
	
	          EdgeSolveData.clear(he);
	        }
	      } catch (err) {
	        _didIteratorError49 = true;
	        _iteratorError49 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion49 && _iterator49.return) {
	            _iterator49.return();
	          }
	        } finally {
	          if (_didIteratorError49) {
	            throw _iteratorError49;
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError48 = true;
	    _iteratorError48 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion48 && _iterator48.return) {
	        _iterator48.return();
	      }
	    } finally {
	      if (_didIteratorError48) {
	        throw _iteratorError48;
	      }
	    }
	  }
	}
	
	function findMaxTurningLeft(pivotEdge, edges, normal) {
	  edges = edges.slice();
	  function edgeVector(edge) {
	    return edge.vertexB.point.minus(edge.vertexA.point)._normalize();
	  }
	  var pivot = pivotEdge.vertexA.point.minus(pivotEdge.vertexB.point)._normalize();
	  edges.sort(function (e1, e2) {
	    return leftTurningMeasure(pivot, edgeVector(e1), normal) - leftTurningMeasure(pivot, edgeVector(e2), normal);
	  });
	  return edges[edges.length - 1];
	}
	
	function leftTurningMeasure(v1, v2, normal) {
	  var measure = v1.dot(v2);
	  if (v1.cross(v2).dot(normal) < 0) {
	    measure = -(2 + measure);
	  }
	  measure -= 1; //shift to the zero
	
	  //make it positive all the way
	  return -measure;
	}
	
	function intersectFaces(shell1, shell2, inverseCrossEdgeDirection) {
	  var _loop3 = function _loop3(i) {
	    var face1 = shell1.faces[i];
	    if (DEBUG.FACE_FACE_INTERSECTION) {
	      __DEBUG__.Clear();__DEBUG__.AddFace(face1, 0x00ff00);
	      DEBUG.NOOP();
	    }
	
	    var _loop4 = function _loop4(j) {
	      var face2 = shell2.faces[j];
	      if (DEBUG.FACE_FACE_INTERSECTION) {
	        __DEBUG__.Clear();__DEBUG__.AddFace(face1, 0x00ff00);
	        __DEBUG__.AddFace(face2, 0x0000ff);
	        if (face1.refId == 0 && face2.refId == 0) {
	          DEBUG.NOOP();
	        }
	      }
	
	      if (face1.data[MY].overlaps.has(face2)) {
	        return 'continue';
	      }
	      var curve = face1.surface.intersect(face2.surface);
	
	      var nodes = [];
	      collectNodesOfIntersectionOfFace(face2, face1, nodes);
	      collectNodesOfIntersectionOfFace(face1, face2, nodes);
	
	      var newEdges = [];
	      var direction = face1.surface.normal.cross(face2.surface.normal);
	      if (inverseCrossEdgeDirection) {
	        direction._multiply(-1);
	      }
	      calculateNodeNormals(nodes, curve);
	      filterNodes(nodes);
	      split(nodes, newEdges, curve, direction);
	
	      newEdges.forEach(function (e) {
	        addNewEdge(face1, e.halfEdge1);
	        addNewEdge(face2, e.halfEdge2);
	      });
	    };
	
	    for (var j = 0; j < shell2.faces.length; j++) {
	      var _ret4 = _loop4(j);
	
	      if (_ret4 === 'continue') continue;
	    }
	  };
	
	  for (var i = 0; i < shell1.faces.length; i++) {
	    _loop3(i);
	  }
	}
	
	function addNewEdge(face, halfEdge) {
	  var data = face.data[MY];
	  data.newEdges.push(halfEdge);
	  halfEdge.loop = data.loopOfNew;
	  EdgeSolveData.createIfEmpty(halfEdge).newEdgeFlag = true;
	  //addToListInMap(data.vertexToEdge, halfEdge.vertexA, halfEdge);
	  return true;
	}
	
	function calculateNodeNormals(nodes, curve) {
	  for (var i = 0; i < nodes.length; i++) {
	    var n = nodes[i];
	    if (n != null) {
	      n.normal = nodeNormal(n.point, n.edge, curve, n.dir);
	      if (n.normal == 0) {
	        nodes[i] = null;
	      }
	    }
	  }
	}
	
	function filterNodes(nodes) {
	  for (var i = 0; i < nodes.length; i++) {
	    var node1 = nodes[i];
	    if (node1 == null) continue;
	    for (var j = 0; j < nodes.length; j++) {
	      if (i == j) continue;
	      var node2 = nodes[j];
	      if (node2 != null) {
	        if (node2.vertex == node1.vertex) {
	          if (node1.normal + node2.normal == 0) {
	            nodes[i] = null;
	          }
	          nodes[j] = null;
	        }
	      }
	    }
	  }
	}
	
	function faceContainsSimilarEdge(face, halfEdge) {
	  var _iteratorNormalCompletion50 = true;
	  var _didIteratorError50 = false;
	  var _iteratorError50 = undefined;
	
	  try {
	    for (var _iterator50 = face.loops[Symbol.iterator](), _step50; !(_iteratorNormalCompletion50 = (_step50 = _iterator50.next()).done); _iteratorNormalCompletion50 = true) {
	      var loop = _step50.value;
	      var _iteratorNormalCompletion51 = true;
	      var _didIteratorError51 = false;
	      var _iteratorError51 = undefined;
	
	      try {
	        for (var _iterator51 = loop.halfEdges[Symbol.iterator](), _step51; !(_iteratorNormalCompletion51 = (_step51 = _iterator51.next()).done); _iteratorNormalCompletion51 = true) {
	          var he = _step51.value;
	
	          if (areEdgesEqual(halfEdge, he) || areEdgesOpposite(halfEdge, he)) {
	            return true;
	          }
	        }
	      } catch (err) {
	        _didIteratorError51 = true;
	        _iteratorError51 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion51 && _iterator51.return) {
	            _iterator51.return();
	          }
	        } finally {
	          if (_didIteratorError51) {
	            throw _iteratorError51;
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError50 = true;
	    _iteratorError50 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion50 && _iterator50.return) {
	        _iterator50.return();
	      }
	    } finally {
	      if (_didIteratorError50) {
	        throw _iteratorError50;
	      }
	    }
	  }
	
	  return false;
	}
	
	function collectNodesOfIntersectionOfFace(splittingFace, face, nodes) {
	  var _iteratorNormalCompletion52 = true;
	  var _didIteratorError52 = false;
	  var _iteratorError52 = undefined;
	
	  try {
	    for (var _iterator52 = face.loops[Symbol.iterator](), _step52; !(_iteratorNormalCompletion52 = (_step52 = _iterator52.next()).done); _iteratorNormalCompletion52 = true) {
	      var loop = _step52.value;
	
	      collectNodesOfIntersection(splittingFace, loop, nodes);
	    }
	  } catch (err) {
	    _didIteratorError52 = true;
	    _iteratorError52 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion52 && _iterator52.return) {
	        _iterator52.return();
	      }
	    } finally {
	      if (_didIteratorError52) {
	        throw _iteratorError52;
	      }
	    }
	  }
	}
	
	function collectNodesOfIntersection(face, loop, nodes) {
	  var _iteratorNormalCompletion53 = true;
	  var _didIteratorError53 = false;
	  var _iteratorError53 = undefined;
	
	  try {
	    for (var _iterator53 = loop.halfEdges[Symbol.iterator](), _step53; !(_iteratorNormalCompletion53 = (_step53 = _iterator53.next()).done); _iteratorNormalCompletion53 = true) {
	      var edge = _step53.value;
	
	      var edgeSolveData = EdgeSolveData.get(edge);
	      if (edgeSolveData.skipFace.has(face)) {
	        continue;
	      }
	      var preExistVertex = edgeSolveData.splitByFace.get(face);
	      if (preExistVertex) {
	        nodes.push(new Node(preExistVertex, edge, face));
	        continue;
	      }
	      intersectFaceWithEdge(face, edge, nodes);
	    }
	  } catch (err) {
	    _didIteratorError53 = true;
	    _iteratorError53 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion53 && _iterator53.return) {
	        _iterator53.return();
	      }
	    } finally {
	      if (_didIteratorError53) {
	        throw _iteratorError53;
	      }
	    }
	  }
	}
	
	function split(nodes, result, onCurve, direction) {
	  for (var i = 0; i < nodes.length; i++) {
	    var inNode = nodes[i];
	    //if (i == 0)  __DEBUG__.AddPoint(inNode.vertex.point);
	
	    if (inNode == null) continue;
	    nodes[i] = null;
	    var closestIdx = findCloserOnCurve(nodes, inNode, onCurve);
	    if (closestIdx == -1) {
	      continue;
	    }
	    var outNode = nodes[closestIdx];
	    //if (i == 1)  __DEBUG__.AddPoint(outNode.vertex.point);
	    //if (i == 1)  __DEBUG__.AddSegment(inNode.point, inNode.point.plus(inNode.normal.multiply(1000)));
	    //__DEBUG__.AddSegment(new Vector(),  outNode.normal.multiply(100));
	
	    if (outNode.normal * inNode.normal > 0) {
	      continue;
	    }
	
	    nodes[closestIdx] = null;
	
	    //__DEBUG__.AddPoint(inNode.vertex.point);
	    //__DEBUG__.AddPoint(outNode.vertex.point);
	
	
	    var halfEdge1 = new _edge3.HalfEdge();
	    halfEdge1.vertexA = inNode.vertex;
	    halfEdge1.vertexB = outNode.vertex;
	
	    var halfEdge2 = new _edge3.HalfEdge();
	    halfEdge2.vertexB = halfEdge1.vertexA;
	    halfEdge2.vertexA = halfEdge1.vertexB;
	
	    //__DEBUG__.AddHalfEdge(halfEdge1);
	    //__DEBUG__.AddSegment(new Vector(),  direction.multiply(100));
	
	
	    splitEdgeByVertex(inNode.edge, halfEdge1.vertexA, inNode.splittingFace);
	    splitEdgeByVertex(outNode.edge, halfEdge1.vertexB, outNode.splittingFace);
	
	    var sameDirection = direction.dot(outNode.point.minus(inNode.point)) > 0;
	
	    var halfEdgeSameDir = sameDirection ? halfEdge1 : halfEdge2;
	    var halfEdgeNegativeDir = sameDirection ? halfEdge2 : halfEdge1;
	
	    // cross edge should go with negative dir for the first face and positive for the second
	    var edge = new _edge3.Edge(onCurve);
	    edge.halfEdge1 = halfEdgeNegativeDir;
	    edge.halfEdge2 = halfEdgeSameDir;
	    halfEdgeNegativeDir.edge = edge;
	    halfEdgeSameDir.edge = edge;
	
	    //check for corner case when to faces only intersects in edges
	    if (!containsEdges(result, edge)) {
	      result.push(edge);
	    }
	  }
	}
	
	function containsEdges(edges, edge) {
	  var _iteratorNormalCompletion54 = true;
	  var _didIteratorError54 = false;
	  var _iteratorError54 = undefined;
	
	  try {
	    for (var _iterator54 = edges[Symbol.iterator](), _step54; !(_iteratorNormalCompletion54 = (_step54 = _iterator54.next()).done); _iteratorNormalCompletion54 = true) {
	      var e = _step54.value;
	
	      if (isSameEdge(e, edge)) {
	        return true;
	      }
	    }
	  } catch (err) {
	    _didIteratorError54 = true;
	    _iteratorError54 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion54 && _iterator54.return) {
	        _iterator54.return();
	      }
	    } finally {
	      if (_didIteratorError54) {
	        throw _iteratorError54;
	      }
	    }
	  }
	
	  return false;
	}
	
	function isSameEdge(e1, e2) {
	  return areEdgesEqual(e1.halfEdge1, e2.halfEdge1);
	}
	
	function splitEdgeByVertex(originHalfEdge, vertex, splittingFace) {
	
	  function splitHalfEdge(h) {
	    var newEdge = new _edge3.HalfEdge();
	    newEdge.vertexA = vertex;
	    newEdge.vertexB = h.vertexB;
	    h.vertexB = newEdge.vertexA;
	    return newEdge;
	  }
	
	  var orig = originHalfEdge;
	  var twin = orig.twin();
	
	  if (orig.vertexA == vertex || orig.vertexB == vertex) {
	    return;
	  }
	
	  var newOrig = splitHalfEdge(orig);
	  var newTwin = splitHalfEdge(twin);
	
	  BREPBuilder.linkHalfEdges(orig.edge, orig, newTwin);
	  BREPBuilder.linkHalfEdges(new _edge3.Edge(orig.edge.curve), twin, newOrig);
	
	  orig.loop.halfEdges.splice(orig.loop.halfEdges.indexOf(orig) + 1, 0, newOrig);
	  twin.loop.halfEdges.splice(twin.loop.halfEdges.indexOf(twin) + 1, 0, newTwin);
	
	  newOrig.loop = orig.loop;
	  newTwin.loop = twin.loop;
	
	  EdgeSolveData.transfer(orig, newOrig);
	  EdgeSolveData.transfer(twin, newTwin);
	
	  //EdgeSolveData.createIfEmpty(twin).splitByFace.set(splittingFace, vertex);
	  //EdgeSolveData.createIfEmpty(newTwin).skipFace.add(splittingFace);
	}
	
	function findCloserOnCurve(nodes, toNode, curve) {
	  var hero = -1;
	  var heroDistance = Number.MAX_VALUE;
	  var origin = curve.t(toNode.point);
	  for (var i = 0; i < nodes.length; i++) {
	    var node = nodes[i];
	    if (node == null) continue;
	    var distance = (origin - curve.t(node.point)) * node.normal;
	    if (distance < 0) continue;
	    if (distance < heroDistance) {
	      hero = i;
	      heroDistance = distance;
	    }
	  }
	  return hero;
	}
	
	var POINT_TO_VERT = new Map();
	function newVertex(point) {
	  var vertex = POINT_TO_VERT.get(point);
	  if (!vertex) {
	    vertex = new _vertex.Vertex(point);
	    duplicatePointTest(point);
	    POINT_TO_VERT.set(point, vertex);
	  }
	  return vertex;
	}
	
	function intersectFaceWithEdge(face, edge, result) {
	
	  if (DEBUG.FACE_EDGE_INTERSECTION) {
	    __DEBUG__.Clear();
	    __DEBUG__.AddFace(face, 0x00ffff);
	    __DEBUG__.AddFace(edge.loop.face, 0xffffff);
	    __DEBUG__.AddHalfEdge(edge, 0xffff00);
	    DEBUG.NOOP();
	  }
	
	  var p0 = edge.vertexA.point;
	  var ab = edge.vertexB.point.minus(p0);
	  var length = ab.length();
	  var v = ab._multiply(1 / length);
	
	  if (math.areEqual(edge.edge.curve.v.dot(face.surface.normal), 0, TOLERANCE)) {
	    if (math.areEqual(face.surface.normal.dot(edge.vertexA.point), face.surface.w, TOLERANCE)) {
	      classifyAndAdd(edge.vertexA.point, true, false);
	      classifyAndAdd(edge.vertexB.point, false, true);
	    }
	  } else {
	
	    var pointOfIntersection = edge.edge.curve.pointOfSurfaceIntersection(face.surface);
	    var t = new _line.Line(p0, v).t(pointOfIntersection);
	    var pInsideSeg = t >= 0 && t <= length;
	
	    var coiA = math.areVectorsEqual(edge.vertexA.point, pointOfIntersection, TOLERANCE);
	    var coiB = math.areVectorsEqual(edge.vertexB.point, pointOfIntersection, TOLERANCE);
	    if (coiA) pointOfIntersection = edge.vertexA.point;
	    if (coiB) pointOfIntersection = edge.vertexB.point;
	    if (coiA || coiB || pInsideSeg) {
	      classifyAndAdd(pointOfIntersection, coiA, coiB);
	    }
	  }
	  function classifyAndAdd(pointOfIntersection, coiA, coiB) {
	    var classRes = classifyPointToFace(pointOfIntersection, face);
	    if (classRes.inside) {
	      var vertexOfIntersection = void 0;
	      if (classRes.vertex) {
	        vertexOfIntersection = classRes.vertex;
	      } else if (coiA) {
	        vertexOfIntersection = edge.vertexA;
	        //console.log("point A on surface");
	      } else if (coiB) {
	        vertexOfIntersection = edge.vertexB;
	        //console.log("point B on surface");
	      } else {
	        vertexOfIntersection = newVertex(pointOfIntersection);
	      }
	
	      var node = new Node(vertexOfIntersection, edge);
	
	      result.push(node);
	      if (classRes.edge) {
	        splitEdgeByVertex(classRes.edge, vertexOfIntersection, edge.loop.face);
	      }
	    }
	  }
	}
	
	function deleteEdge(edge) {
	  if (edge.halfEdge1 != null) {
	    deleteHalfEdge(edge.halfEdge1);
	  }
	  if (edge.halfEdge2 != null) {
	    deleteHalfEdge(edge.halfEdge2);
	  }
	}
	
	function deleteHalfEdge(he) {
	  EdgeSolveData.createIfEmpty(he).invalid = true;
	  removeFromListInMap(he.loop.face.data[MY].vertexToEdge, he.vertexA, he);
	}
	
	function classifyPointToFace(point, face) {
	  function ccwCorrection(result, loop) {
	    if (!loop.isCCW(face.surface)) {
	      result.inside = !result.inside;
	    }
	    return result;
	  }
	
	  var uvPt = face.surface.toUV(point);
	  var outer = classifyPointInsideLoop(point, face.outerLoop, face.surface, uvPt);
	
	  if (outer.inside) {
	    if (outer.vertex || outer.edge) {
	      return outer;
	    }
	  }
	
	  var _iteratorNormalCompletion55 = true;
	  var _didIteratorError55 = false;
	  var _iteratorError55 = undefined;
	
	  try {
	    for (var _iterator55 = face.innerLoops[Symbol.iterator](), _step55; !(_iteratorNormalCompletion55 = (_step55 = _iterator55.next()).done); _iteratorNormalCompletion55 = true) {
	      var innerLoop = _step55.value;
	
	      var inner = classifyPointInsideLoop(point, innerLoop, face.surface, uvPt);
	      if (inner.vertex || inner.edge) {
	        return inner;
	      }
	      if (inner.inside) {
	        return ccwCorrection(outer, innerLoop);
	      }
	    }
	  } catch (err) {
	    _didIteratorError55 = true;
	    _iteratorError55 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion55 && _iterator55.return) {
	        _iterator55.return();
	      }
	    } finally {
	      if (_didIteratorError55) {
	        throw _iteratorError55;
	      }
	    }
	  }
	
	  return ccwCorrection(outer, face.outerLoop);
	}
	
	function nodeNormal(point, edge, curve, edgeTangent) {
	  if (edgeTangent == null) {
	    edgeTangent = edgeNormal(edge); // todo @ point
	  }
	  var curveTangent = curve.v; //todo @ point
	  var dot = edgeTangent.dot(curveTangent);
	  if (math.areEqual(dot, 0, TOLERANCE)) {
	    dot = 0;
	  } else {
	    if (dot < 0) dot = -1;else dot = 1;
	  }
	  return dot;
	}
	
	function edgeNormal(edge) {
	  return edge.loop.face.surface.normal.cross(edge.vertexB.point.minus(edge.vertexA.point))._normalize();
	}
	
	function intersectCurveWithEdge(curve, edge, surface, result) {
	  var p0 = edge.vertexA.point;
	  var ab = edge.vertexB.point.minus(p0);
	  var length = ab.length();
	  var v = ab._multiply(1 / length);
	  var edgeLine = new _line.Line(p0, v);
	  var t = edgeLine.intersectCurve(curve, surface);
	  if (t >= 0 && t <= length) {
	    var pointOfIntersection = edgeLine.parametricEquation(t);
	    result.push(new Node(pointOfIntersection, edge));
	  }
	}
	
	function EdgeSolveData() {
	  this.splitByFace = new Map();
	  this.skipFace = new Set();
	}
	
	EdgeSolveData.EMPTY = new EdgeSolveData();
	
	EdgeSolveData.get = function (edge) {
	  if (!edge.data[MY]) {
	    return EdgeSolveData.EMPTY;
	  }
	  return edge.data[MY];
	};
	
	EdgeSolveData.createIfEmpty = function (edge) {
	  if (!edge.data[MY]) {
	    edge.data[MY] = new EdgeSolveData();
	  }
	  return edge.data[MY];
	};
	
	EdgeSolveData.clear = function (edge) {
	  delete edge.data[MY];
	};
	
	EdgeSolveData.transfer = function (from, to) {
	  to.data[MY] = from.data[MY];
	};
	
	function Node(vertex, splitsEdge, splittingFace) {
	  this.vertex = vertex;
	  this.normal = 0;
	  this.point = vertex.point;
	  this.edge = splitsEdge;
	  this.dir = null;
	  this.splittingFace = splittingFace;
	  //__DEBUG__.AddPoint(this.point);
	}
	
	var __DEBUG_POINT_DUPS = [];
	function duplicatePointTest(point, data) {
	  data = data || {};
	  var res = false;
	  var _iteratorNormalCompletion56 = true;
	  var _didIteratorError56 = false;
	  var _iteratorError56 = undefined;
	
	  try {
	    for (var _iterator56 = __DEBUG_POINT_DUPS[Symbol.iterator](), _step56; !(_iteratorNormalCompletion56 = (_step56 = _iterator56.next()).done); _iteratorNormalCompletion56 = true) {
	      var entry = _step56.value;
	
	      var other = entry[0];
	      if (math.areVectorsEqual(point, other, TOLERANCE)) {
	        res = true;
	        break;
	      }
	    }
	  } catch (err) {
	    _didIteratorError56 = true;
	    _iteratorError56 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion56 && _iterator56.return) {
	        _iterator56.return();
	      }
	    } finally {
	      if (_didIteratorError56) {
	        throw _iteratorError56;
	      }
	    }
	  }
	
	  __DEBUG_POINT_DUPS.push([point, data]);
	  if (res) {
	    __DEBUG__.AddPoint(point);
	    console.error('DUPLICATE DETECTED: ' + point);
	  }
	  return res;
	}
	
	var SolveData = function SolveData() {
	  _classCallCheck(this, SolveData);
	
	  this.faceData = [];
	};
	
	var FaceSolveData = function FaceSolveData(face) {
	  _classCallCheck(this, FaceSolveData);
	
	  this.face = face;
	  this.loopOfNew = new _loop5.Loop();
	  this.newEdges = this.loopOfNew.halfEdges;
	  this.vertexToEdge = new Map();
	  this.overlaps = new Set();
	  this.loopOfNew.face = face;
	};
	
	function classifyPointInsideLoop(pt, loop, surface, uvPt) {
	
	  function VertexResult(vertex) {
	    this.inside = true;
	    this.vertex = vertex;
	  }
	
	  function EdgeResult(edge) {
	    this.inside = true;
	    this.edge = edge;
	  }
	
	  if (!uvPt) {
	    uvPt = surface.toUV(pt);
	  }
	
	  function isLine(edge) {
	    return !edge.edge || !edge.edge.curve || edge.edge.curve.isLine;
	  }
	
	  var uvCoords = new Map();
	  var _iteratorNormalCompletion57 = true;
	  var _didIteratorError57 = false;
	  var _iteratorError57 = undefined;
	
	  try {
	    for (var _iterator57 = loop.halfEdges[Symbol.iterator](), _step57; !(_iteratorNormalCompletion57 = (_step57 = _iterator57.next()).done); _iteratorNormalCompletion57 = true) {
	      var _edge = _step57.value;
	
	      var uv = surface.toUV(_edge.vertexA.point);
	      if (math.areEqual(uvPt.y, uv.y, TOLERANCE) && math.areEqual(uvPt.x, uv.x, TOLERANCE)) {
	        return new VertexResult(_edge.vertexA);
	      }
	      uvCoords.set(_edge.vertexA, uv);
	    }
	  } catch (err) {
	    _didIteratorError57 = true;
	    _iteratorError57 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion57 && _iterator57.return) {
	        _iterator57.return();
	      }
	    } finally {
	      if (_didIteratorError57) {
	        throw _iteratorError57;
	      }
	    }
	  }
	
	  var grads = [];
	  var _iteratorNormalCompletion58 = true;
	  var _didIteratorError58 = false;
	  var _iteratorError58 = undefined;
	
	  try {
	    for (var _iterator58 = loop.halfEdges[Symbol.iterator](), _step58; !(_iteratorNormalCompletion58 = (_step58 = _iterator58.next()).done); _iteratorNormalCompletion58 = true) {
	      var _edge2 = _step58.value;
	
	      var _a = uvCoords.get(_edge2.vertexA);
	      var _b = uvCoords.get(_edge2.vertexB);
	      var dy = void 0;
	      if (isLine(_edge2)) {
	        dy = _b.y - _a.y;
	      } else {
	        var tangent = _edge2.edge.curve.tangent(_edge2.vertexA.point);
	        dy = surface.toUV(tangent).y;
	        if (_edge2.edge.invertedToCurve) {
	          dy *= -1;
	        }
	      }
	      if (math.areEqual(dy, 0, TOLERANCE)) {
	        grads.push(0);
	      } else if (dy > 0) {
	        grads.push(1);
	      } else {
	        grads.push(-1);
	      }
	    }
	  } catch (err) {
	    _didIteratorError58 = true;
	    _iteratorError58 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion58 && _iterator58.return) {
	        _iterator58.return();
	      }
	    } finally {
	      if (_didIteratorError58) {
	        throw _iteratorError58;
	      }
	    }
	  }
	
	  function nextGrad(start) {
	    for (var i = 0; i < grads.length; ++i) {
	      var idx = (i + start + 1) % grads.length;
	      if (grads[idx] != 0) {
	        return grads[idx];
	      }
	    }
	  }
	
	  function prevGrad(start) {
	    for (var i = 0; i < grads.length; ++i) {
	      var idx = (start - i - 1 + grads.length) % grads.length;
	      if (grads[idx] != 0) {
	        return grads[idx];
	      }
	    }
	  }
	
	  var skip = new Set();
	
	  var ray = null;
	  var inside = false;
	  for (var i = 0; i < loop.halfEdges.length; ++i) {
	
	    var edge = loop.halfEdges[i];
	
	    var shouldBeSkipped = skip.has(edge.vertexA) || skip.has(edge.vertexB);
	
	    var a = uvCoords.get(edge.vertexA);
	    var b = uvCoords.get(edge.vertexB);
	
	    var aEq = math.areEqual(uvPt.y, a.y, TOLERANCE);
	    var bEq = math.areEqual(uvPt.y, b.y, TOLERANCE);
	
	    if (aEq) {
	      skip.add(edge.vertexA);
	    }
	    if (bEq) {
	      skip.add(edge.vertexB);
	    }
	
	    if (math.areVectorsEqual(a, b, TOLERANCE)) {
	      console.error('unable to classify invalid polygon');
	    }
	
	    if (isLine(edge)) {
	      var edgeLowPt = a;
	      var edgeHighPt = b;
	
	      var edgeDx = edgeHighPt.x - edgeLowPt.x;
	      var edgeDy = edgeHighPt.y - edgeLowPt.y;
	
	      if (aEq && bEq) {
	        if (edgeHighPt.x <= uvPt.x && uvPt.x <= edgeLowPt.x || edgeLowPt.x <= uvPt.x && uvPt.x <= edgeHighPt.x) {
	          return new EdgeResult(edge);
	        } else {
	          continue;
	        }
	      }
	
	      if (shouldBeSkipped) {
	        continue;
	      }
	
	      if (edgeDy < 0) {
	        edgeLowPt = b;edgeDx = -edgeDx;
	        edgeHighPt = a;edgeDy = -edgeDy;
	      }
	      if (!aEq && !bEq && (uvPt.y < edgeLowPt.y || uvPt.y > edgeHighPt.y)) {
	        continue;
	      }
	
	      if (bEq) {
	        if (grads[i] * nextGrad(i) < 0) {
	          continue;
	        }
	      } else if (aEq) {
	        if (grads[i] * prevGrad(i) < 0) {
	          continue;
	        }
	      }
	
	      var perpEdge = edgeDx * (uvPt.y - edgeLowPt.y) - edgeDy * (uvPt.x - edgeLowPt.x);
	      if (math.areEqual(perpEdge, 0, TOLERANCE)) return new EdgeResult(edge); // uvPt is on contour ?
	      if (perpEdge < 0) {
	        continue;
	      }
	      inside = !inside; // true intersection left of uvPt
	    } else {
	
	      if (aEq && bEq) {
	        if (math.areEqual(edge.edge.curve.closestDistanceToPoint(pt), 0, TOLERANCE)) {
	          return new EdgeResult(edge);
	        } else {
	          continue;
	        }
	      }
	
	      if (shouldBeSkipped) {
	        continue;
	      }
	
	      if (bEq) {
	        if (grads[i] * nextGrad(i) < 0) {
	          continue;
	        }
	      } else if (aEq) {
	        if (grads[i] * prevGrad(i) < 0) {
	          continue;
	        }
	      }
	
	      if (math.areEqual(edge.edge.curve.closestDistanceToPoint(pt), 0, TOLERANCE)) {
	        return new EdgeResult(edge);
	      }
	
	      if (ray == null) {
	
	        var rayEnd = pt.copy();
	        //fixme!!
	        rayEnd.x = 1000000; //surface.fromUV(surface.domainU()[1]).x;
	        ray = edge.edge.curve.createLinearNurbs(pt, rayEnd);
	      }
	
	      var hits = edge.edge.curve.intersect(ray);
	
	      var _iteratorNormalCompletion59 = true;
	      var _didIteratorError59 = false;
	      var _iteratorError59 = undefined;
	
	      try {
	        for (var _iterator59 = hits[Symbol.iterator](), _step59; !(_iteratorNormalCompletion59 = (_step59 = _iterator59.next()).done); _iteratorNormalCompletion59 = true) {
	          var hit = _step59.value;
	
	          //if ray just touches
	          var onlyTouches = math.areEqual(edge.edge.curve.tangent(hit).normalize().y, 0, TOLERANCE);
	          if (!onlyTouches) {
	            inside = !inside;
	          }
	        }
	      } catch (err) {
	        _didIteratorError59 = true;
	        _iteratorError59 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion59 && _iterator59.return) {
	            _iterator59.return();
	          }
	        } finally {
	          if (_didIteratorError59) {
	            throw _iteratorError59;
	          }
	        }
	      }
	    }
	  }
	
	  return { inside: inside };
	}
	
	function addToListInMap(map, key, value) {
	  var list = map.get(key);
	  if (!list) {
	    list = [];
	    map.set(key, list);
	  }
	  list.push(value);
	}
	
	function removeFromListInMap(map, key, value) {
	  var list = map.get(key);
	  if (list) {
	    var idx = list.indexOf(value);
	    if (idx != -1) {
	      list.splice(idx, 1);
	    }
	  }
	}
	
	function __DEBUG_OPERANDS(shell1, shell2) {
	  if (DEBUG.OPERANDS_MODE) {
	    __DEBUG__.HideSolids();
	    __DEBUG__.AddVolume(shell1, 0x800080);
	    __DEBUG__.AddVolume(shell2, 0xfff44f);
	  }
	}
	
	var MY = '__BOOLEAN_ALGORITHM_DATA__';

/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.BREPValidator = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var BREPValidator = exports.BREPValidator = function () {
	  function BREPValidator() {
	    _classCallCheck(this, BREPValidator);
	
	    this.errors = [];
	  }
	
	  _createClass(BREPValidator, [{
	    key: 'validateShell',
	    value: function validateShell(shell) {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = shell.faces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var face = _step.value;
	
	          if (face.shell !== shell) {
	            this.addError(new FaceRefersToWrongShell(face, shell));
	          }
	          this.validateFace(face);
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    }
	  }, {
	    key: 'validateFace',
	    value: function validateFace(face) {
	      if (face !== face.outerLoop.face) {
	        this.addError(new LoopRefersToWrongFace(face.outerLoop, face));
	      }
	      this.validateLoop(face.outerLoop);
	    }
	  }, {
	    key: 'validateLoop',
	    value: function validateLoop(loop) {
	      var halfEdges = loop.halfEdges;
	      var n = halfEdges.length;
	      if (n == 0) {
	        return;
	      }
	
	      for (var i = 0; i < n; i++) {
	        var j = (i + 1) % n;
	        var curr = halfEdges[i];
	        var next = halfEdges[j];
	        if (curr.loop !== loop) {
	          this.addError(new HalfEdgeRefersToWrongLoop(loop, curr));
	        }
	        if (curr.vertexB !== next.vertexA) {
	          this.addError(new VerticesOfHalfEdgeArentConnected(curr, next));
	        }
	        if (curr.next != next) {
	          this.addError(new HalfEdgeNextPointerIncorrect(curr, next));
	        }
	        if (next.prev != curr) {
	          this.addError(new HalfEdgePrevPointerIncorrect(next, curr));
	        }
	        if (!curr.edge) {
	          this.addError(new EdgeForHalfEdgeIsntSet(curr));
	        } else {
	          var twin = curr.twin();
	          if (curr.edge !== twin.edge) {
	            this.addError(new EdgeOfTwinDifferent(curr, twin));
	          }
	          if (twin.vertexB != curr.vertexA) {
	            this.addError(new TwinStartVertexIncorrect(curr, twin));
	          }
	          if (twin.vertexA != curr.vertexB) {
	            this.addError(new TwinEndVertexIncorrect(curr, twin));
	          }
	        }
	      }
	    }
	  }, {
	    key: 'addError',
	    value: function addError(validationError) {
	      this.errors.push(validationError);
	    }
	  }]);
	
	  return BREPValidator;
	}();
	
	BREPValidator.validateToConsole = function (shell) {
	  var brepValidator = new BREPValidator();
	
	  brepValidator.validateShell(shell);
	  var _iteratorNormalCompletion2 = true;
	  var _didIteratorError2 = false;
	  var _iteratorError2 = undefined;
	
	  try {
	    for (var _iterator2 = brepValidator.errors[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	      var brepError = _step2.value;
	
	      console.warn(brepError.message());
	    }
	  } catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion2 && _iterator2.return) {
	        _iterator2.return();
	      }
	    } finally {
	      if (_didIteratorError2) {
	        throw _iteratorError2;
	      }
	    }
	  }
	
	  if (brepValidator.errors.length == 0) {
	    console.log('BREP is Valid.');
	  }
	};
	
	var FaceRefersToWrongShell = function () {
	  function FaceRefersToWrongShell(face, shell) {
	    _classCallCheck(this, FaceRefersToWrongShell);
	
	    this.face = face;
	    this.shell = shell;
	  }
	
	  _createClass(FaceRefersToWrongShell, [{
	    key: 'message',
	    value: function message() {
	      return "face refers to a shell it doesn't belong to";
	    }
	  }]);
	
	  return FaceRefersToWrongShell;
	}();
	
	var VerticesOfHalfEdgeArentConnected = function () {
	  function VerticesOfHalfEdgeArentConnected(loop, halfEdge1, halfEdge2) {
	    _classCallCheck(this, VerticesOfHalfEdgeArentConnected);
	
	    this.loop = loop;
	    this.halfEdge1 = halfEdge1;
	    this.halfEdge2 = halfEdge2;
	  }
	
	  _createClass(VerticesOfHalfEdgeArentConnected, [{
	    key: 'message',
	    value: function message() {
	      return 'starting point of the following half edge should identically the same as ending of a half edge';
	    }
	  }]);
	
	  return VerticesOfHalfEdgeArentConnected;
	}();
	
	var HalfEdgeRefersToWrongLoop = function () {
	  function HalfEdgeRefersToWrongLoop(loop, face) {
	    _classCallCheck(this, HalfEdgeRefersToWrongLoop);
	
	    this.loop = loop;
	    this.face = face;
	  }
	
	  _createClass(HalfEdgeRefersToWrongLoop, [{
	    key: 'message',
	    value: function message() {
	      return 'half edge refers to different loop it belongs to';
	    }
	  }]);
	
	  return HalfEdgeRefersToWrongLoop;
	}();
	
	var LoopRefersToWrongFace = function () {
	  function LoopRefersToWrongFace(loop, halfEdge) {
	    _classCallCheck(this, LoopRefersToWrongFace);
	
	    this.loop = loop;
	    this.halfEdge = halfEdge;
	  }
	
	  _createClass(LoopRefersToWrongFace, [{
	    key: 'message',
	    value: function message() {
	      return 'loop refers to different face it belongs to';
	    }
	  }]);
	
	  return LoopRefersToWrongFace;
	}();
	
	var HalfEdgeNextPointerIncorrect = function () {
	  function HalfEdgeNextPointerIncorrect(halfEdge, nextHalfEdge) {
	    _classCallCheck(this, HalfEdgeNextPointerIncorrect);
	
	    this.halfEdge = halfEdge;
	    this.nextHalfEdge = nextHalfEdge;
	  }
	
	  _createClass(HalfEdgeNextPointerIncorrect, [{
	    key: 'message',
	    value: function message() {
	      return "half edge's next pointer doesn't refer to real next half edge";
	    }
	  }]);
	
	  return HalfEdgeNextPointerIncorrect;
	}();
	
	var HalfEdgePrevPointerIncorrect = function () {
	  function HalfEdgePrevPointerIncorrect(halfEdge, prevHalfEdge) {
	    _classCallCheck(this, HalfEdgePrevPointerIncorrect);
	
	    this.halfEdge = halfEdge;
	    this.prevHalfEdge = prevHalfEdge;
	  }
	
	  _createClass(HalfEdgePrevPointerIncorrect, [{
	    key: 'message',
	    value: function message() {
	      return "half edge's prev pointer doesn't refer to prior half edge";
	    }
	  }]);
	
	  return HalfEdgePrevPointerIncorrect;
	}();
	
	var TwinStartVertexIncorrect = function () {
	  function TwinStartVertexIncorrect(halfEdge, twin) {
	    _classCallCheck(this, TwinStartVertexIncorrect);
	
	    this.halfEdge = halfEdge;
	    this.twin = twin;
	  }
	
	  _createClass(TwinStartVertexIncorrect, [{
	    key: 'message',
	    value: function message() {
	      return "a twin has incorrect start vertex, should be identical to the end vertex of the half edge";
	    }
	  }]);
	
	  return TwinStartVertexIncorrect;
	}();
	
	var TwinEndVertexIncorrect = function () {
	  function TwinEndVertexIncorrect(halfEdge, twin) {
	    _classCallCheck(this, TwinEndVertexIncorrect);
	
	    this.halfEdge = halfEdge;
	    this.twin = twin;
	  }
	
	  _createClass(TwinEndVertexIncorrect, [{
	    key: 'message',
	    value: function message() {
	      return "a twin has incorrect end vertex, should be identical to the start vertex of the half edge";
	    }
	  }]);
	
	  return TwinEndVertexIncorrect;
	}();
	
	var EdgeForHalfEdgeIsntSet = function () {
	  function EdgeForHalfEdgeIsntSet(halfEdge) {
	    _classCallCheck(this, EdgeForHalfEdgeIsntSet);
	
	    this.halfEdge = halfEdge;
	  }
	
	  _createClass(EdgeForHalfEdgeIsntSet, [{
	    key: 'message',
	    value: function message() {
	      return "half edge doesn't refer to an edge";
	    }
	  }]);
	
	  return EdgeForHalfEdgeIsntSet;
	}();
	
	var EdgeOfTwinDifferent = function () {
	  function EdgeOfTwinDifferent(halfEdge, twin) {
	    _classCallCheck(this, EdgeOfTwinDifferent);
	
	    this.halfEdge = halfEdge;
	    this.twin = twin;
	  }
	
	  _createClass(EdgeOfTwinDifferent, [{
	    key: 'message',
	    value: function message() {
	      return "edge of twin doesn't match to the half edge's edge";
	    }
	  }]);

	  return EdgeOfTwinDifferent;
	}();

/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	exports.ReadSketch = ReadSketch;
	exports.ReadSketchPoint = ReadSketchPoint;
	exports.ReadSketchFromFace = ReadSketchFromFace;
	exports.FetchContours = FetchContours;
	
	var _sketchModel = __webpack_require__(377);
	
	var sm = _interopRequireWildcard(_sketchModel);
	
	var _l3space = __webpack_require__(308);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _graph = __webpack_require__(307);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	var _hashmap = __webpack_require__(306);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SketchGeom = function () {
	  function SketchGeom() {
	    _classCallCheck(this, SketchGeom);
	
	    this.connections = [];
	    this.loops = [];
	    this.constructionSegments = [];
	    this._contours = null;
	  }
	
	  _createClass(SketchGeom, [{
	    key: 'fetchContours',
	    value: function fetchContours() {
	      if (this._contours == null) {
	        this._contours = FetchContours(this);
	      }
	      return this._contours;
	    }
	  }, {
	    key: 'findById',
	    value: function findById(id) {
	      function _find() {
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	          for (var _iterator = arguments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var arr = _step.value;
	            var _iteratorNormalCompletion2 = true;
	            var _didIteratorError2 = false;
	            var _iteratorError2 = undefined;
	
	            try {
	              for (var _iterator2 = arr[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                var segment = _step2.value;
	
	                if (segment.id === id) {
	                  return segment;
	                }
	              }
	            } catch (err) {
	              _didIteratorError2 = true;
	              _iteratorError2 = err;
	            } finally {
	              try {
	                if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                  _iterator2.return();
	                }
	              } finally {
	                if (_didIteratorError2) {
	                  throw _iteratorError2;
	                }
	              }
	            }
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	
	        return null;
	      }
	      return _find(this.connections, this.loops, this.constructionSegments);
	    }
	  }]);
	
	  return SketchGeom;
	}();
	
	function ReadSketch(sketch, faceId, readConstructionSegments) {
	  function getID(obj) {
	    return faceId + ":" + obj.id;
	  }
	  var out = new SketchGeom();
	  if (sketch.layers !== undefined) {
	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;
	
	    try {
	      for (var _iterator3 = sketch.layers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	        var layer = _step3.value;
	
	        var isConstructionLayer = layer.name == "_construction_";
	        if (isConstructionLayer && !readConstructionSegments) continue;
	        var _iteratorNormalCompletion4 = true;
	        var _didIteratorError4 = false;
	        var _iteratorError4 = undefined;
	
	        try {
	          for (var _iterator4 = layer.data[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	            var obj = _step4.value;
	
	            if (isConstructionLayer && obj._class !== 'TCAD.TWO.Segment') continue;
	            if (obj.edge !== undefined) continue;
	            if (!!obj.aux) continue;
	            if (obj._class === 'TCAD.TWO.Segment') {
	              var segA = ReadSketchPoint(obj.points[0]);
	              var segB = ReadSketchPoint(obj.points[1]);
	              var pushOn = isConstructionLayer ? out.constructionSegments : out.connections;
	              pushOn.push(new sm.Segment(getID(obj), segA, segB));
	            } else if (obj._class === 'TCAD.TWO.Arc') {
	              var arcA = ReadSketchPoint(obj.points[0]);
	              var arcB = ReadSketchPoint(obj.points[1]);
	              var arcCenter = ReadSketchPoint(obj.points[2]);
	              out.connections.push(new sm.Arc(getID(obj), arcA, arcB, arcCenter));
	            } else if (obj._class === 'TCAD.TWO.EllipticalArc') {
	              var ep1 = ReadSketchPoint(obj.ep1);
	              var ep2 = ReadSketchPoint(obj.ep2);
	              var a = ReadSketchPoint(obj.a);
	              var b = ReadSketchPoint(obj.b);
	              out.connections.push(new sm.EllipticalArc(getID(obj), ep1, ep2, a, b, obj.r));
	            } else if (obj._class === 'TCAD.TWO.BezierCurve') {
	              var _a = ReadSketchPoint(obj.a);
	              var _b = ReadSketchPoint(obj.b);
	              var cp1 = ReadSketchPoint(obj.cp1);
	              var cp2 = ReadSketchPoint(obj.cp2);
	              out.connections.push(new sm.BezierCurve(getID(obj), _a, _b, cp1, cp2));
	            } else if (obj._class === 'TCAD.TWO.Circle') {
	              var circleCenter = ReadSketchPoint(obj.c);
	              out.loops.push(new sm.Circle(getID(obj), circleCenter, obj.r));
	            } else if (obj._class === 'TCAD.TWO.Ellipse') {
	              var _ep = ReadSketchPoint(obj.ep1);
	              var _ep2 = ReadSketchPoint(obj.ep2);
	              out.loops.push(new sm.Ellipse(getID(obj), _ep, _ep2, obj.r));
	            }
	          }
	        } catch (err) {
	          _didIteratorError4 = true;
	          _iteratorError4 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion4 && _iterator4.return) {
	              _iterator4.return();
	            }
	          } finally {
	            if (_didIteratorError4) {
	              throw _iteratorError4;
	            }
	          }
	        }
	      }
	    } catch (err) {
	      _didIteratorError3 = true;
	      _iteratorError3 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion3 && _iterator3.return) {
	          _iterator3.return();
	        }
	      } finally {
	        if (_didIteratorError3) {
	          throw _iteratorError3;
	        }
	      }
	    }
	  }
	  return out;
	}
	
	function ReadSketchPoint(arr) {
	  return new _vector2.default(arr[1][1], arr[2][1], 0);
	}
	
	function ReadSketchFromFace(app, face) {
	  var savedFace = localStorage.getItem(app.faceStorageKey(face.id));
	  if (savedFace == null) return null;
	  return ReadSketch(JSON.parse(savedFace), face.id, true);
	}
	
	function FetchContours(geom) {
	  var contours = findClosedContours(geom.connections);
	  var _iteratorNormalCompletion5 = true;
	  var _didIteratorError5 = false;
	  var _iteratorError5 = undefined;
	
	  try {
	    for (var _iterator5 = geom.loops[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	      var loop = _step5.value;
	
	      var contour = new sm.Contour();
	      contour.add(loop);
	      contours.push(contour);
	    }
	  } catch (err) {
	    _didIteratorError5 = true;
	    _iteratorError5 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion5 && _iterator5.return) {
	        _iterator5.return();
	      }
	    } finally {
	      if (_didIteratorError5) {
	        throw _iteratorError5;
	      }
	    }
	  }
	
	  var _iteratorNormalCompletion6 = true;
	  var _didIteratorError6 = false;
	  var _iteratorError6 = undefined;
	
	  try {
	    for (var _iterator6 = contours[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	      var _contour = _step6.value;
	
	      if (!_contour.isCCW()) _contour.reverse();
	    }
	  } catch (err) {
	    _didIteratorError6 = true;
	    _iteratorError6 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion6 && _iterator6.return) {
	        _iterator6.return();
	      }
	    } finally {
	      if (_didIteratorError6) {
	        throw _iteratorError6;
	      }
	    }
	  }
	
	  return contours;
	}
	
	function findClosedContours(segments) {
	  var result = [];
	  findClosedContoursFromPairedCurves(segments, result);
	  findClosedContoursFromGraph(segments, result);
	  return result;
	}
	
	function findClosedContoursFromPairedCurves(segments, result) {
	  for (var i = 0; i < segments.length; i++) {
	    var s1 = segments[i];
	    for (var j = i; j < segments.length; j++) {
	      if (i == j) continue;
	      var s2 = segments[j];
	      if (s1.isCurve() && s2.isCurve()) {
	        var paired = false;
	        if (math.strictEqual2D(s1.a, s2.a) && math.strictEqual2D(s1.b, s2.b)) {
	          paired = true;
	          s2.invert();
	        } else if (math.strictEqual2D(s1.a, s2.b) && math.strictEqual2D(s1.b, s2.a)) {
	          paired = true;
	        }
	        if (paired) {
	          var contour = new sm.Contour();
	          contour.add(s1);
	          contour.add(s2);
	          result.push(contour);
	        }
	      }
	    }
	  }
	}
	
	function findClosedContoursFromGraph(segments, result) {
	
	  var dict = _hashmap.HashTable.forVector2d();
	  var edges = _hashmap.HashTable.forDoubleArray();
	
	  function edgeKey(a, b) {
	    return [a.x, a.y, b.x, b.y];
	  }
	
	  var points = [];
	  function memDir(a, b) {
	    var dirs = dict.get(a);
	    if (dirs === null) {
	      dirs = [];
	      dict.put(a, dirs);
	      points.push(a);
	    }
	    dirs.push(b);
	  }
	
	  var _iteratorNormalCompletion7 = true;
	  var _didIteratorError7 = false;
	  var _iteratorError7 = undefined;
	
	  try {
	    for (var _iterator7 = segments[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	      var seg = _step7.value;
	
	      var a = seg.a;
	      var b = seg.b;
	
	      memDir(a, b);
	      memDir(b, a);
	      edges.put(edgeKey(a, b), seg);
	    }
	  } catch (err) {
	    _didIteratorError7 = true;
	    _iteratorError7 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion7 && _iterator7.return) {
	        _iterator7.return();
	      }
	    } finally {
	      if (_didIteratorError7) {
	        throw _iteratorError7;
	      }
	    }
	  }
	
	  var graph = {
	
	    connections: function connections(e) {
	      var dirs = dict.get(e);
	      return dirs === null ? [] : dirs;
	    },
	
	    at: function at(index) {
	      return points[index];
	    },
	
	    size: function size() {
	      return points.length;
	    }
	  };
	
	  var loops = _graph.Graph.findAllLoops(graph, dict.hashCodeF, dict.equalsF);
	  var _iteratorNormalCompletion8 = true;
	  var _didIteratorError8 = false;
	  var _iteratorError8 = undefined;
	
	  try {
	    for (var _iterator8 = loops[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
	      var loop = _step8.value;
	
	      var contour = new sm.Contour();
	      for (var pi = 0; pi < loop.length; ++pi) {
	        var point = loop[pi];
	        var next = loop[(pi + 1) % loop.length];
	        var edge = edges.get(edgeKey(point, next));
	        if (edge === null) {
	          edge = edges.get(edgeKey(next, point));
	          edge.invert();
	        }
	        contour.add(edge);
	      }
	      result.push(contour);
	    }
	  } catch (err) {
	    _didIteratorError8 = true;
	    _iteratorError8 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion8 && _iterator8.return) {
	        _iterator8.return();
	      }
	    } finally {
	      if (_didIteratorError8) {
	        throw _iteratorError8;
	      }
	    }
	  }
	}

/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Contour = exports.Ellipse = exports.Circle = exports.EllipticalArc = exports.BezierCurve = exports.Arc = exports.Segment = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _curve = __webpack_require__(366);
	
	var _approx = __webpack_require__(367);
	
	var _nurbs = __webpack_require__(369);
	
	var _point = __webpack_require__(322);
	
	var _line = __webpack_require__(365);
	
	var _bezierCubic = __webpack_require__(312);
	
	var _math = __webpack_require__(304);
	
	var _l3space = __webpack_require__(308);
	
	var _verbNurbs = __webpack_require__(370);
	
	var _verbNurbs2 = _interopRequireDefault(_verbNurbs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var RESOLUTION = 20;
	
	var SketchPrimitive = function () {
	  function SketchPrimitive(id) {
	    _classCallCheck(this, SketchPrimitive);
	
	    this.id = id;
	    this.inverted = false;
	  }
	
	  _createClass(SketchPrimitive, [{
	    key: 'invert',
	    value: function invert() {
	      this.inverted = !this.inverted;
	    }
	  }, {
	    key: 'approximate',
	    value: function approximate(resolution) {
	      var approximation = this.approximateImpl(resolution);
	      if (this.inverted) {
	        approximation.reverse();
	      }
	      return approximation;
	    }
	  }, {
	    key: 'isCurve',
	    value: function isCurve() {
	      return this.constructor.name != 'Segment';
	    }
	  }, {
	    key: 'toNurbs',
	    value: function toNurbs(plane) {
	      var verbNurbs = this.toVerbNurbs(plane, to3DTrFunc(plane));
	      if (this.inverted) {
	        verbNurbs = verbNurbs.reverse();
	      }
	      return new _nurbs.NurbsCurve(verbNurbs);
	    }
	  }, {
	    key: 'toVerbNurbs',
	    value: function toVerbNurbs(plane, _3dtr) {
	      throw 'not implemented';
	    }
	  }]);
	
	  return SketchPrimitive;
	}();
	
	var Segment = exports.Segment = function (_SketchPrimitive) {
	  _inherits(Segment, _SketchPrimitive);
	
	  function Segment(id, a, b) {
	    _classCallCheck(this, Segment);
	
	    var _this = _possibleConstructorReturn(this, (Segment.__proto__ || Object.getPrototypeOf(Segment)).call(this, id));
	
	    _this.a = a;
	    _this.b = b;
	    return _this;
	  }
	
	  _createClass(Segment, [{
	    key: 'approximateImpl',
	    value: function approximateImpl(resolution) {
	      return [this.a, this.b];
	    }
	  }, {
	    key: 'toVerbNurbs',
	    value: function toVerbNurbs(plane, _3dtr) {
	      return new _verbNurbs2.default.geom.Line(_3dtr(this.a).data(), _3dtr(this.b).data());
	    }
	  }]);
	
	  return Segment;
	}(SketchPrimitive);
	
	var Arc = exports.Arc = function (_SketchPrimitive2) {
	  _inherits(Arc, _SketchPrimitive2);
	
	  function Arc(id, a, b, c) {
	    _classCallCheck(this, Arc);
	
	    var _this2 = _possibleConstructorReturn(this, (Arc.__proto__ || Object.getPrototypeOf(Arc)).call(this, id));
	
	    _this2.a = a;
	    _this2.b = b;
	    _this2.c = c;
	    return _this2;
	  }
	
	  _createClass(Arc, [{
	    key: 'approximateImpl',
	    value: function approximateImpl(resolution) {
	      return Arc.approximateArc(this.a, this.b, this.c, resolution);
	    }
	  }, {
	    key: 'toVerbNurbs',
	    value: function toVerbNurbs(plane, _3dtr) {
	      var basis = plane.basis();
	      var startAngle = (0, _math.makeAngle0_360)(Math.atan2(this.a.y - this.c.y, this.a.x - this.c.x));
	      var endAngle = (0, _math.makeAngle0_360)(Math.atan2(this.b.y - this.c.y, this.b.x - this.c.x));
	
	      var angle = endAngle - startAngle;
	      if (angle < 0) {
	        angle = Math.PI * 2 + angle;
	      }
	      function pointAtAngle(angle) {
	        var dx = basis[0].multiply(Math.cos(angle));
	        var dy = basis[1].multiply(Math.sin(angle));
	        return dx.plus(dy);
	      }
	      var xAxis = pointAtAngle(startAngle);
	      var yAxis = pointAtAngle(startAngle + Math.PI * 0.5);
	
	      var arc = new _verbNurbs2.default.geom.Arc(_3dtr(this.c).data(), xAxis.data(), yAxis.data(), (0, _math.distanceAB)(this.c, this.a), 0, Math.abs(angle));
	      return arc;
	    }
	  }], [{
	    key: 'approximateArc',
	    value: function approximateArc(ao, bo, c, resolution) {
	      var a = ao.minus(c);
	      var b = bo.minus(c);
	      var points = [ao];
	      var abAngle = Math.atan2(b.y, b.x) - Math.atan2(a.y, a.x);
	      if (abAngle > Math.PI * 2) abAngle = Math.PI / 2 - abAngle;
	      if (abAngle < 0) abAngle = Math.PI * 2 + abAngle;
	
	      var r = a.length();
	      resolution = 1;
	      //var step = Math.acos(1 - ((resolution * resolution) / (2 * r * r)));
	      var step = resolution / (2 * Math.PI);
	      var k = Math.round(abAngle / step);
	      var angle = Math.atan2(a.y, a.x) + step;
	
	      for (var i = 0; i < k - 1; ++i) {
	        points.push(new _point.Point(c.x + r * Math.cos(angle), c.y + r * Math.sin(angle)));
	        angle += step;
	      }
	      points.push(bo);
	      return points;
	    }
	  }]);
	
	  return Arc;
	}(SketchPrimitive);
	
	var BezierCurve = exports.BezierCurve = function (_SketchPrimitive3) {
	  _inherits(BezierCurve, _SketchPrimitive3);
	
	  function BezierCurve(id, a, b, cp1, cp2) {
	    _classCallCheck(this, BezierCurve);
	
	    var _this3 = _possibleConstructorReturn(this, (BezierCurve.__proto__ || Object.getPrototypeOf(BezierCurve)).call(this, id));
	
	    _this3.a = a;
	    _this3.b = b;
	    _this3.cp1 = cp1;
	    _this3.cp2 = cp2;
	    return _this3;
	  }
	
	  _createClass(BezierCurve, [{
	    key: 'approximateImpl',
	    value: function approximateImpl(resolution) {
	      return (0, _bezierCubic.LUT)(this.a, this.b, this.cp1, this.cp2, 10);
	    }
	  }]);
	
	  return BezierCurve;
	}(SketchPrimitive);
	
	var EllipticalArc = exports.EllipticalArc = function (_SketchPrimitive4) {
	  _inherits(EllipticalArc, _SketchPrimitive4);
	
	  function EllipticalArc(id, ep1, ep2, a, b, r) {
	    _classCallCheck(this, EllipticalArc);
	
	    var _this4 = _possibleConstructorReturn(this, (EllipticalArc.__proto__ || Object.getPrototypeOf(EllipticalArc)).call(this, id));
	
	    _this4.ep1 = ep1;
	    _this4.ep2 = ep2;
	    _this4.a = a;
	    _this4.b = b;
	    _this4.r = r;
	    return _this4;
	  }
	
	  _createClass(EllipticalArc, [{
	    key: 'approximateImpl',
	    value: function approximateImpl(resolution) {
	      return EllipticalArc.approxEllipticalArc(this.ep1, this.ep2, this.a, this.b, this.r, resolution);
	    }
	  }], [{
	    key: 'approxEllipticalArc',
	    value: function approxEllipticalArc(ep1, ep2, ao, bo, radiusY, resolution) {
	      var axisX = ep2.minus(ep1);
	      var radiusX = axisX.length() * 0.5;
	      axisX._normalize();
	      var c = ep1.plus(axisX.multiply(radiusX));
	      var a = ao.minus(c);
	      var b = bo.minus(c);
	      var points = [ao];
	      var rotation = Math.atan2(axisX.y, axisX.x);
	      var abAngle = Math.atan2(b.y, b.x) - Math.atan2(a.y, a.x);
	      if (abAngle > Math.PI * 2) abAngle = Math.PI / 2 - abAngle;
	      if (abAngle < 0) abAngle = Math.PI * 2 + abAngle;
	
	      var sq = function sq(a) {
	        return a * a;
	      };
	
	      resolution = 1;
	
	      var step = resolution / (2 * Math.PI);
	      var k = Math.round(abAngle / step);
	      var angle = Math.atan2(a.y, a.x) + step - rotation;
	
	      for (var i = 0; i < k - 1; ++i) {
	        var r = Math.sqrt(1 / (sq(Math.cos(angle) / radiusX) + sq(Math.sin(angle) / radiusY)));
	        points.push(new _point.Point(c.x + r * Math.cos(angle + rotation), c.y + r * Math.sin(angle + rotation)));
	        angle += step;
	      }
	      points.push(bo);
	      return points;
	    }
	  }]);
	
	  return EllipticalArc;
	}(SketchPrimitive);
	
	var Circle = exports.Circle = function (_SketchPrimitive5) {
	  _inherits(Circle, _SketchPrimitive5);
	
	  function Circle(id, c, r) {
	    _classCallCheck(this, Circle);
	
	    var _this5 = _possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this, id));
	
	    _this5.c = c;
	    _this5.r = r;
	    return _this5;
	  }
	
	  _createClass(Circle, [{
	    key: 'approximateImpl',
	    value: function approximateImpl(resolution) {
	      return Circle.approxCircle(this.c, this.r, resolution);
	    }
	  }, {
	    key: 'toVerbNurbs',
	    value: function toVerbNurbs(plane, _3dtr) {
	      var basis = plane.basis();
	      return new _verbNurbs2.default.geom.Circle(_3dtr(this.c).data(), basis[0].data(), basis[1].data(), this.r);
	    }
	  }], [{
	    key: 'approxCircle',
	    value: function approxCircle(c, r, resolution) {
	      var points = [];
	      resolution = 1;
	      //var step = Math.acos(1 - ((resolution * resolution) / (2 * r * r)));
	      var step = resolution / (2 * Math.PI);
	      var k = Math.round(2 * Math.PI / step);
	
	      for (var i = 0, angle = 0; i < k; ++i, angle += step) {
	        points.push(new _point.Point(c.x + r * Math.cos(angle), c.y + r * Math.sin(angle)));
	      }
	      points.push(points[0]); // close it
	      return points;
	    }
	  }]);
	
	  return Circle;
	}(SketchPrimitive);
	
	var Ellipse = exports.Ellipse = function (_SketchPrimitive6) {
	  _inherits(Ellipse, _SketchPrimitive6);
	
	  function Ellipse(id, ep1, ep2, r) {
	    _classCallCheck(this, Ellipse);
	
	    var _this6 = _possibleConstructorReturn(this, (Ellipse.__proto__ || Object.getPrototypeOf(Ellipse)).call(this, id));
	
	    _this6.ep1 = ep1;
	    _this6.ep2 = ep2;
	    _this6.r = r;
	    return _this6;
	  }
	
	  _createClass(Ellipse, [{
	    key: 'approximateImpl',
	    value: function approximateImpl(resolution) {
	      return EllipticalArc.approxEllipticalArc(this.ep1, this.ep2, this.ep1, this.ep1, this.r, resolution);
	    }
	  }]);
	
	  return Ellipse;
	}(SketchPrimitive);
	
	var USE_APPROX_FOR = new Set();
	//USE_APPROX_FOR.add('Arc');
	
	var USE_NURBS_FOR = new Set();
	USE_NURBS_FOR.add('Arc');
	USE_NURBS_FOR.add('Circle');
	//USE_NURBS_FOR.add('Ellipse');
	//USE_NURBS_FOR.add('EllipticalArc');
	//USE_NURBS_FOR.add('BezierCurve');
	
	var Contour = exports.Contour = function () {
	  function Contour() {
	    _classCallCheck(this, Contour);
	
	    this.segments = [];
	  }
	
	  _createClass(Contour, [{
	    key: 'add',
	    value: function add(obj) {
	      this.segments.push(obj);
	    }
	  }, {
	    key: 'transferOnSurface',
	    value: function transferOnSurface(surface, forceApproximation) {
	      var cc = new _curve.CompositeCurve();
	      var tr = to3DTrFunc(surface);
	
	      var prev = null;
	      var firstPoint = null;
	      for (var segIdx = 0; segIdx < this.segments.length; ++segIdx) {
	        var segment = this.segments[segIdx];
	        var approximation = segment.approximate(RESOLUTION);
	
	        approximation = approximation.map(function (p) {
	          return tr(p);
	        });
	
	        var n = approximation.length;
	        prev = prev == null ? approximation[0] : prev;
	        approximation[0] = prev; // this magic is to keep identity of same vectors
	        if (firstPoint == null) firstPoint = approximation[0];
	
	        if (segIdx == this.segments.length - 1) {
	          approximation[n - 1] = firstPoint;
	        }
	
	        if (!forceApproximation && USE_APPROX_FOR.has(segment.constructor.name)) {
	          cc.add(new _approx.ApproxCurve(approximation, segment), prev, segment);
	          prev = approximation[n - 1];
	        } else if (!forceApproximation && USE_NURBS_FOR.has(segment.constructor.name)) {
	          cc.add(segment.toNurbs(surface), prev, segment);
	          prev = approximation[n - 1];
	        } else {
	          for (var i = 1; i < n; ++i) {
	            var curr = approximation[i];
	            cc.add(new _line.Line.fromSegment(prev, curr), prev, segment);
	            prev = curr;
	          }
	        }
	      }
	      return cc;
	    }
	  }, {
	    key: 'approximate',
	    value: function approximate(resolution) {
	      var approximation = [];
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = this.segments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var segment = _step.value;
	
	          var segmentApproximation = segment.approximate(resolution);
	          //skip last one cuz it's guaranteed to be closed
	          for (var i = 0; i < segmentApproximation.length - 1; ++i) {
	            approximation.push(segmentApproximation[i]);
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      return approximation;
	    }
	  }, {
	    key: 'isCCW',
	    value: function isCCW() {
	      return (0, _math.isCCW)(this.approximate(10));
	    }
	  }, {
	    key: 'reverse',
	    value: function reverse() {
	      this.segments.reverse();
	      this.segments.forEach(function (s) {
	        return s.invert();
	      });
	    }
	  }]);
	
	  return Contour;
	}();
	
	function to3DTrFunc(surface) {
	  var _3dTransformation = surface.get3DTransformation();
	  return function (v) {
	    return _3dTransformation.apply(v);
	  };
	}

/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.BooleanOperation = BooleanOperation;
	exports.combineShells = combineShells;
	
	var _boolean = __webpack_require__(374);
	
	var _brepSceneObject = __webpack_require__(379);
	
	var _stitching = __webpack_require__(329);
	
	var _brepValidator = __webpack_require__(375);
	
	var _shell = __webpack_require__(361);
	
	var BoolOpMap = {
	  'subtract': _boolean.subtract,
	  'union': _boolean.union,
	  'intersect': _boolean.intersect
	};
	
	function BooleanOperation(face, solid, operand, operationType) {
	  var result = void 0;
	  if (solid instanceof _brepSceneObject.BREPSceneSolid) {
	    var op = BoolOpMap[operationType];
	    result = op(solid.shell, operand);
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = result.faces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var newFace = _step.value;
	
	        if (newFace.id == face.id) {
	          newFace.id = undefined;
	        }
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	  } else {
	    if (operationType != 'union') throw 'unable to cut plane';
	    result = operand;
	  }
	  (0, _stitching.update)(result);
	  var newSolid = new _brepSceneObject.BREPSceneSolid(result);
	  return {
	    outdated: [solid],
	    created: [newSolid]
	  };
	}
	
	function combineShells(shells) {
	  if (shells.length == 1) {
	    return shells[0];
	  }
	  var operand = new _shell.Shell();
	  shells.forEach(function (c) {
	    return c.faces.forEach(function (f) {
	      return operand.faces.push(f);
	    });
	  });
	  _brepValidator.BREPValidator.validateToConsole(operand);
	  return operand;
	}

/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.BREPSceneSolid = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	exports.triangulateToThree = triangulateToThree;
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _stitching = __webpack_require__(329);
	
	var _cadUtils = __webpack_require__(302);
	
	var _triangulation = __webpack_require__(320);
	
	var _sceneObject = __webpack_require__(326);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var SMOOTH_RENDERING = false; //true;
	
	var BREPSceneSolid = exports.BREPSceneSolid = function (_SceneSolid) {
	  _inherits(BREPSceneSolid, _SceneSolid);
	
	  function BREPSceneSolid(shell, type, skin) {
	    _classCallCheck(this, BREPSceneSolid);
	
	    var _this = _possibleConstructorReturn(this, (BREPSceneSolid.__proto__ || Object.getPrototypeOf(BREPSceneSolid)).call(this, type, undefined, skin));
	
	    _this.shell = shell;
	    _this.createGeometry();
	    return _this;
	  }
	
	  _createClass(BREPSceneSolid, [{
	    key: 'createGeometry',
	    value: function createGeometry() {
	      var geometry = new THREE.Geometry();
	      geometry.dynamic = true;
	      this.mesh = new THREE.Mesh(geometry, this.material);
	      this.cadGroup.add(this.mesh);
	      this.createFaces();
	      this.createEdges();
	      this.createVertices();
	    }
	  }, {
	    key: 'createFaces',
	    value: function createFaces() {
	      var geom = this.mesh.geometry;
	      var groups = triangulateToThree(this.shell, geom);
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = groups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var g = _step.value;
	
	          var sceneFace = new BREPSceneFace(g.brepFace, this);
	          this.sceneFaces.push(sceneFace);
	          for (var i = g.groupStart; i < g.groupEnd; i++) {
	            var face = geom.faces[i];
	            sceneFace.registerMeshFace(face);
	          }
	        }
	        //geom.mergeVertices();
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    }
	  }, {
	    key: 'createEdges',
	    value: function createEdges() {
	      var visited = new Set();
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        for (var _iterator2 = this.shell.faces[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var face = _step2.value;
	          var _iteratorNormalCompletion3 = true;
	          var _didIteratorError3 = false;
	          var _iteratorError3 = undefined;
	
	          try {
	            for (var _iterator3 = face.outerLoop.halfEdges[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	              var halfEdge = _step3.value;
	
	              if (!visited.has(halfEdge.edge)) {
	                visited.add(halfEdge.edge);
	                if (halfEdge.edge.data[_stitching.EDGE_AUX] === undefined) {
	                  var line = new THREE.Line(undefined, _sceneObject.WIREFRAME_MATERIAL);
	                  var contour = [halfEdge.vertexA.point];
	                  halfEdge.edge.curve.approximate(10, halfEdge.vertexA.point, halfEdge.vertexB.point, contour);
	                  contour.push(halfEdge.vertexB.point);
	                  var _iteratorNormalCompletion4 = true;
	                  var _didIteratorError4 = false;
	                  var _iteratorError4 = undefined;
	
	                  try {
	                    for (var _iterator4 = contour[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	                      var p = _step4.value;
	
	                      line.geometry.vertices.push(p.three());
	                    }
	                  } catch (err) {
	                    _didIteratorError4 = true;
	                    _iteratorError4 = err;
	                  } finally {
	                    try {
	                      if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                        _iterator4.return();
	                      }
	                    } finally {
	                      if (_didIteratorError4) {
	                        throw _iteratorError4;
	                      }
	                    }
	                  }
	
	                  this.wireframeGroup.add(line);
	                  line.__TCAD_EDGE = halfEdge.edge;
	                  halfEdge.edge.data['scene.edge'] = line;
	                }
	              }
	            }
	          } catch (err) {
	            _didIteratorError3 = true;
	            _iteratorError3 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                _iterator3.return();
	              }
	            } finally {
	              if (_didIteratorError3) {
	                throw _iteratorError3;
	              }
	            }
	          }
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	    }
	  }, {
	    key: 'createVertices',
	    value: function createVertices() {}
	  }]);
	
	  return BREPSceneSolid;
	}(_sceneObject.SceneSolid);
	
	var BREPSceneFace = function (_SceneFace) {
	  _inherits(BREPSceneFace, _SceneFace);
	
	  function BREPSceneFace(brepFace, solid) {
	    _classCallCheck(this, BREPSceneFace);
	
	    var _this2 = _possibleConstructorReturn(this, (BREPSceneFace.__proto__ || Object.getPrototypeOf(BREPSceneFace)).call(this, solid, brepFace.id));
	
	    brepFace.id = _this2.id;
	    _this2.brepFace = brepFace;
	    brepFace.data['scene.face'] = _this2;
	    return _this2;
	  }
	
	  _createClass(BREPSceneFace, [{
	    key: 'normal',
	    value: function normal() {
	      return this.brepFace.surface.normal;
	    }
	  }, {
	    key: 'depth',
	    value: function depth() {
	      return this.brepFace.surface.w;
	    }
	  }, {
	    key: 'surface',
	    value: function surface() {
	      return this.brepFace.surface;
	    }
	  }, {
	    key: 'getBounds',
	    value: function getBounds() {
	      var bounds = [];
	      var _iteratorNormalCompletion5 = true;
	      var _didIteratorError5 = false;
	      var _iteratorError5 = undefined;
	
	      try {
	        for (var _iterator5 = this.brepFace.loops[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	          var loop = _step5.value;
	
	          bounds.push(loop.asPolygon().map(function (p) {
	            return new _vector2.default().setV(p);
	          }));
	        }
	      } catch (err) {
	        _didIteratorError5 = true;
	        _iteratorError5 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion5 && _iterator5.return) {
	            _iterator5.return();
	          }
	        } finally {
	          if (_didIteratorError5) {
	            throw _iteratorError5;
	          }
	        }
	      }
	
	      return bounds;
	    }
	  }]);
	
	  return BREPSceneFace;
	}(_sceneObject.SceneFace);
	
	function triangulateToThree(shell, geom) {
	  var result = [];
	  var gIdx = 0;
	  function addFace(face) {
	    face.materialIndex = gIdx++;
	    geom.faces.push(face);
	  }
	  var _iteratorNormalCompletion6 = true;
	  var _didIteratorError6 = false;
	  var _iteratorError6 = undefined;
	
	  try {
	    var _loop = function _loop() {
	      var brepFace = _step6.value;
	
	      var groupStart = geom.faces.length;
	      if (brepFace.surface.constructor.name == 'Plane') {
	        (function () {
	          var polygons = (0, _triangulation.TriangulateFace)(brepFace);
	          var stitchedSurface = brepFace.data[_stitching.FACE_CHUNK];
	          var nurbs = stitchedSurface ? stitchedSurface.origin : undefined;
	          var normalOrNormals = threeV(brepFace.surface.normal);
	          for (var p = 0; p < polygons.length; ++p) {
	            var off = geom.vertices.length;
	            var poly = polygons[p];
	            var vLength = poly.length;
	            if (vLength < 3) continue;
	            var firstVertex = poly[0];
	            geom.vertices.push(firstVertex.point.three());
	            geom.vertices.push(poly[1].point.three());
	            for (var i = 2; i < vLength; i++) {
	              geom.vertices.push(poly[i].point.three());
	              var a = off;
	              var b = i - 1 + off;
	              var c = i + off;
	
	              if (nurbs && SMOOTH_RENDERING) {
	                (function () {
	                  var normal = function normal(v) {
	                    var uv = nurbs.closestParam(v.point.data());
	                    var vec = new THREE.Vector3();
	                    vec.set.apply(vec, nurbs.normal(uv[0], uv[1]));
	                    vec.normalize();
	                    if (brepFace.data.INVERTED) {
	                      vec.negate();
	                    }
	                    return vec;
	                  };
	
	                  normalOrNormals = [firstVertex, poly[i - 1], poly[i]].map(function (v) {
	                    return normal(v);
	                  });
	                })();
	              }
	              var face = new THREE.Face3(a, b, c, normalOrNormals);
	              addFace(face);
	            }
	            //view.setFaceColor(sceneFace, utils.isSmoothPiece(group.shared) ? 0xFF0000 : null);
	          }
	        })();
	      } else if (brepFace.surface.constructor.name == 'NurbsSurface') {
	        (function () {
	          var off = geom.vertices.length;
	          var tess = brepFace.surface.verb.tessellate({ maxDepth: 3 });
	          tess.points.forEach(function (p) {
	            return geom.vertices.push(new THREE.Vector3().fromArray(p));
	          });
	          var _iteratorNormalCompletion7 = true;
	          var _didIteratorError7 = false;
	          var _iteratorError7 = undefined;
	
	          try {
	            for (var _iterator7 = tess.faces[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	              var faceIndices = _step7.value;
	
	              var normalOrNormals = void 0;
	              if (SMOOTH_RENDERING) {
	                normalOrNormals = faceIndices.map(function (x) {
	                  var vn = tess.normals[x];
	                  return new THREE.Vector3(vn[0], vn[1], vn[2]);
	                });
	              } else {
	                normalOrNormals = (0, _cadUtils.normalOfCCWSeq)(faceIndices.map(function (i) {
	                  return new _vector2.default().set3(tess.points[i]);
	                })).three();
	              }
	
	              var face = new THREE.Face3(faceIndices[0] + off, faceIndices[1] + off, faceIndices[2] + off, normalOrNormals);
	              addFace(face);
	            }
	          } catch (err) {
	            _didIteratorError7 = true;
	            _iteratorError7 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion7 && _iterator7.return) {
	                _iterator7.return();
	              }
	            } finally {
	              if (_didIteratorError7) {
	                throw _iteratorError7;
	              }
	            }
	          }
	        })();
	      } else {
	        throw 'unsupported;';
	      }
	      result.push(new FaceGroup(brepFace, groupStart, geom.faces.length));
	    };
	
	    for (var _iterator6 = shell.faces[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	      _loop();
	    }
	  } catch (err) {
	    _didIteratorError6 = true;
	    _iteratorError6 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion6 && _iterator6.return) {
	        _iterator6.return();
	      }
	    } finally {
	      if (_didIteratorError6) {
	        throw _iteratorError6;
	      }
	    }
	  }
	
	  return result;
	}
	
	var FaceGroup = function FaceGroup(brepFace, groupStart, groupEnd) {
	  _classCallCheck(this, FaceGroup);
	
	  this.brepFace = brepFace;
	  this.groupStart = groupStart;
	  this.groupEnd = groupEnd;
	};
	
	function threeV(v) {
	  return new THREE.Vector3(v.x, v.y, v.z);
	}

/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Revolve = Revolve;
	exports.evalPivot = evalPivot;
	
	var _booleanOperation = __webpack_require__(378);
	
	var _sketchReader = __webpack_require__(376);
	
	var _brepBuilder = __webpack_require__(360);
	
	function Revolve(app, params) {
	
	  var face = app.findFace(params.face);
	  var solid = face.solid;
	  var surface = face.surface();
	
	  var sketch = (0, _sketchReader.ReadSketchFromFace)(app, face);
	  var pivot = evalPivot(params.pivot, sketch, surface);
	
	  var shells = [];
	  var contours = sketch.fetchContours();
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = contours[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var contour = _step.value;
	
	      var basePath = contour.transferOnSurface(surface);
	      var shell = (0, _brepBuilder.revolve)(basePath, surface, pivot.p0, pivot.v, params.angle);
	      shells.push(shell);
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  var operand = (0, _booleanOperation.combineShells)(shells);
	  return (0, _booleanOperation.BooleanOperation)(face, solid, operand, 'union');
	}
	
	function evalPivot(pivot, sketch, surface) {
	  var segment = sketch.findById(pivot);
	  if (segment == null) {
	    return null;
	  }
	  var tr = surface.get3DTransformation();
	  var p0 = tr.apply(segment.a);
	  var v = tr.apply(segment.b).minus(p0)._normalize();
	  return { p0: p0, v: v };
	}

/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.PlaneSceneObject = exports.INIT_BOUNDS = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _l3space = __webpack_require__(308);
	
	var _plane = __webpack_require__(371);
	
	var _sceneObject = __webpack_require__(326);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var INIT_WIDTH_H = 750 * 0.5;
	var INIT_HEIGHT_H = 750 * 0.5;
	
	var INIT_BOUNDS = exports.INIT_BOUNDS = [new _vector2.default(-INIT_WIDTH_H, -INIT_HEIGHT_H, 0), new _vector2.default(INIT_WIDTH_H, -INIT_HEIGHT_H, 0), new _vector2.default(INIT_WIDTH_H, INIT_HEIGHT_H, 0), new _vector2.default(-INIT_WIDTH_H, INIT_HEIGHT_H, 0)];
	
	var PlaneSceneObject = exports.PlaneSceneObject = function (_SceneSolid) {
	  _inherits(PlaneSceneObject, _SceneSolid);
	
	  function PlaneSceneObject(plane, skin) {
	    _classCallCheck(this, PlaneSceneObject);
	
	    var _this = _possibleConstructorReturn(this, (PlaneSceneObject.__proto__ || Object.getPrototypeOf(PlaneSceneObject)).call(this, 'PLANE', undefined, Object.assign({
	      side: THREE.DoubleSide,
	      transparent: true,
	      opacity: 0.5
	    }, skin)));
	
	    _this.plane = plane;
	    _this.sceneFace = new PlaneSceneFace(_this);
	    _this.sceneFaces.push(_this.sceneFace); // as part of the API
	    _this.updateBounds(INIT_BOUNDS);
	    return _this;
	  }
	
	  _createClass(PlaneSceneObject, [{
	    key: 'createGeometry',
	    value: function createGeometry() {
	      var _this2 = this;
	
	      var geometry = new THREE.Geometry();
	      geometry.dynamic = true;
	      this.bounds.forEach(function (v) {
	        return geometry.vertices.push(v.three());
	      });
	      geometry.faces.push(new THREE.Face3(0, 1, 2));
	      geometry.faces.push(new THREE.Face3(0, 2, 3));
	      geometry.faces.forEach(function (f) {
	        return _this2.sceneFace.registerMeshFace(f);
	      });
	      geometry.computeFaceNormals();
	      this.mesh = new THREE.Mesh(geometry, this.material);
	      this.cadGroup.add(this.mesh);
	    }
	  }, {
	    key: 'dropGeometry',
	    value: function dropGeometry() {
	      if (this.mesh) {
	        this.cadGroup.remove(this.mesh);
	        this.mesh.geometry.dispose();
	        this.sceneFace.meshFaces = [];
	      }
	    }
	  }, {
	    key: 'updateBounds',
	    value: function updateBounds(bounds2d) {
	      this.dropGeometry();
	      var tr = this.plane.get3DTransformation();
	      this.bounds = bounds2d.map(function (v) {
	        return tr.apply(v);
	      });
	      this.createGeometry();
	    }
	  }], [{
	    key: 'create',
	    value: function create(params, faceResolver) {
	      var face = null;
	      if (params.parallelTo) {
	        face = faceResolver(params.parallelTo);
	      }
	      var plane = null;
	      if (face == null) {
	        var normal = _l3space.STANDARD_BASES[params.orientation][2];
	        plane = new _plane.Plane(normal, params.depth);
	      } else {
	        plane = new _plane.Plane(face.normal(), params.depth);
	      }
	      return new PlaneSceneObject(plane);
	    }
	  }]);
	
	  return PlaneSceneObject;
	}(_sceneObject.SceneSolid);
	
	var PlaneSceneFace = function (_SceneFace) {
	  _inherits(PlaneSceneFace, _SceneFace);
	
	  function PlaneSceneFace(scenePlane) {
	    _classCallCheck(this, PlaneSceneFace);
	
	    return _possibleConstructorReturn(this, (PlaneSceneFace.__proto__ || Object.getPrototypeOf(PlaneSceneFace)).call(this, scenePlane));
	  }
	
	  _createClass(PlaneSceneFace, [{
	    key: 'normal',
	    value: function normal() {
	      return this.solid.plane.normal;
	    }
	  }, {
	    key: 'depth',
	    value: function depth() {
	      return this.solid.plane.w;
	    }
	  }, {
	    key: 'surface',
	    value: function surface() {
	      return this.solid.plane;
	    }
	  }, {
	    key: 'getBounds',
	    value: function getBounds() {
	      return [];
	    }
	  }]);

	  return PlaneSceneFace;
	}(_sceneObject.SceneFace);

/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.box = box;
	
	var _brepBuilder = __webpack_require__(360);
	
	var BREPBuilder = _interopRequireWildcard(_brepBuilder);
	
	var _l3space = __webpack_require__(308);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function box(w, h, d, tr) {
	  var wh = w * 0.5;
	  var hh = h * 0.5;
	  var dh = d * 0.5;
	  if (!tr) {
	    tr = IDENTITY;
	  }
	  return BREPBuilder.createPrism([tr._apply(BREPBuilder.point(-wh, -hh, dh)), tr._apply(BREPBuilder.point(wh, -hh, dh)), tr._apply(BREPBuilder.point(wh, hh, dh)), tr._apply(BREPBuilder.point(-wh, hh, dh))], d);
	}
	
	var IDENTITY = new _l3space.Matrix3();

/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Menu;
	
	var _utils = __webpack_require__(333);
	
	function Menu(menuActions, inputManager) {
	  var _this = this;
	
	  this.inputManager = inputManager;
	  this.node = $('<div>', {
	    'class': 'menu'
	  });
	  var container = $('<div>', { 'class': 'menu-container' });
	  this.node.append(container);
	  var separatorAllowed = false;
	
	  var _loop = function _loop() {
	    action = menuActions[i];
	
	    if (action.type == 'separator') {
	      container.append($('<div>', { 'class': 'menu-separator' }));
	      separatorAllowed = false;
	      return 'continue';
	    }
	    separatorAllowed = i != menuActions.length - 1;
	    var menuItem = $('<div>', { 'class': 'menu-item action-item' });
	    menuItem.data('action', action.id);
	    menuItem.addClass('icon16-left');
	    if (action.icon32 != undefined) {
	      menuItem.css({
	        'background-image': 'url(' + action.icon32 + ')'
	      });
	    } else if (action.cssIcons != undefined) {
	      menuItem.append($('<i>', { 'class': 'fa ' + (0, _utils.cssIconsToClasses)(action.cssIcons) })).append(' ');
	    } else {}
	    menuItem.append($('<span>', { text: action.label, class: 'menu-text' }));
	    hotkey = _this.inputManager.keymap[action.id];
	
	    if (hotkey) {
	      hotkey = hotkey.replace(/\s/g, '');
	      if (hotkey.length < 15) {
	        menuItem.append($('<span>', { text: hotkey, 'class': 'action-hotkey-info' }));
	      }
	    }
	
	    container.append(menuItem);
	    _this.inputManager.app.actionManager.subscribe(action.id, function (state) {
	      if (state.enabled) {
	        menuItem.removeClass('action-disabled');
	      } else {
	        menuItem.addClass('action-disabled');
	      }
	    });
	  };
	
	  for (var i = 0; i < menuActions.length; i++) {
	    var action;
	    var hotkey;
	
	    var _ret = _loop();
	
	    if (_ret === 'continue') continue;
	  }
	  this.node.hide();
	  $('body').append(this.node);
	};
	
	Menu.prototype.show = function (app, event) {
	  this.node.removeClass('menu-flat-top');
	  this.node.removeClass('menu-flat-bottom');
	  this.node.show(); //node should be visible to get right dimensions
	  var r = Math.round;
	  var button = _utils.EventData.get(event, 'initiator');
	  if (button != undefined) {
	    var off = button.offset();
	    var orientation = button.data('menuOrientation');
	    if (orientation == 'up') {
	      this.node.addClass('menu-flat-bottom');
	      this.node.offset({
	        left: r(off.left),
	        top: r(off.top - this.node.outerHeight())
	      });
	    } else if (orientation == 'down') {
	      this.node.addClass('menu-flat-top');
	      this.node.offset({
	        left: r(off.left),
	        top: r(off.top + button.outerHeight())
	      });
	    } else {
	      var mouseInfo = this.inputManager.mouseInfo;
	      var screenOff = $(document).outerHeight() - (mouseInfo.pageX + this.node.outerHeight());
	      if (screenOff > 0) {
	        screenOff = 0;
	      }
	      var x = mouseInfo.pageX;
	      if (x + this.node.outerWidth()) {}
	      this.node.offset({
	        left: mouseInfo.pageX,
	        top: mouseInfo.pageY + screenOff
	      });
	    }
	  } else {
	    var _mouseInfo = this.inputManager.mouseInfo;
	    this.node.offset({
	      left: r(_mouseInfo.pageX - this.node.outerWidth() / 2),
	      top: r(_mouseInfo.pageY - this.node.outerHeight() / 2)
	    });
	  }
	  this.inputManager.registerOpenMenu(this);
	};

/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ExtrudePreviewer = exports.ExtrudeWizard = exports.CutWizard = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _wizard = __webpack_require__(385);
	
	var _previewWizard = __webpack_require__(386);
	
	var _cutExtrude = __webpack_require__(359);
	
	var _triangulation = __webpack_require__(320);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _utils = __webpack_require__(330);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var METADATA = [['value', 'number', 50], ['prism', 'number', 1, { min: 0, step: 0.1, round: 1 }], ['angle', 'number', 0, {}], ['rotation', 'number', 0, { step: 5 }], ['face', 'face', _wizard.CURRENT_SELECTION]];
	
	var CutWizard = exports.CutWizard = function (_PreviewWizard) {
	  _inherits(CutWizard, _PreviewWizard);
	
	  function CutWizard(app, initialState) {
	    _classCallCheck(this, CutWizard);
	
	    return _possibleConstructorReturn(this, (CutWizard.__proto__ || Object.getPrototypeOf(CutWizard)).call(this, app, 'CUT', METADATA, initialState));
	  }
	
	  _createClass(CutWizard, [{
	    key: 'createPreviewObject',
	    value: function createPreviewObject(app, params) {
	      return CUT_PREVIEWER.create(app, params);
	    }
	  }, {
	    key: 'uiLabel',
	    value: function uiLabel(name) {
	      if ('value' == name) return 'depth';
	      return _get(CutWizard.prototype.__proto__ || Object.getPrototypeOf(CutWizard.prototype), 'uiLabel', this).call(this, name);
	    }
	  }]);
	
	  return CutWizard;
	}(_previewWizard.PreviewWizard);
	
	var ExtrudeWizard = exports.ExtrudeWizard = function (_PreviewWizard2) {
	  _inherits(ExtrudeWizard, _PreviewWizard2);
	
	  function ExtrudeWizard(app, initialState) {
	    _classCallCheck(this, ExtrudeWizard);
	
	    return _possibleConstructorReturn(this, (ExtrudeWizard.__proto__ || Object.getPrototypeOf(ExtrudeWizard)).call(this, app, 'EXTRUDE', METADATA, initialState));
	  }
	
	  _createClass(ExtrudeWizard, [{
	    key: 'createPreviewObject',
	    value: function createPreviewObject(app, params) {
	      return EXTRUDE_PREVIEWER.create(app, params);
	    }
	  }, {
	    key: 'uiLabel',
	    value: function uiLabel(name) {
	      if ('value' == name) return 'height';
	      return _get(ExtrudeWizard.prototype.__proto__ || Object.getPrototypeOf(ExtrudeWizard.prototype), 'uiLabel', this).call(this, name);
	    }
	  }]);
	
	  return ExtrudeWizard;
	}(_previewWizard.PreviewWizard);
	
	var ExtrudePreviewer = exports.ExtrudePreviewer = function (_SketchBasedPreviewer) {
	  _inherits(ExtrudePreviewer, _SketchBasedPreviewer);
	
	  function ExtrudePreviewer(inversed) {
	    _classCallCheck(this, ExtrudePreviewer);
	
	    var _this3 = _possibleConstructorReturn(this, (ExtrudePreviewer.__proto__ || Object.getPrototypeOf(ExtrudePreviewer)).call(this));
	
	    _this3.inversed = inversed;
	    return _this3;
	  }
	
	  _createClass(ExtrudePreviewer, [{
	    key: 'createImpl',
	    value: function createImpl(app, params, sketch, face) {
	      var encloseDetails = (0, _cutExtrude.getEncloseDetails)(params, sketch, face.surface(), !this.inversed, true);
	      var triangles = [];
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = encloseDetails[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var collectOnSurface = function collectOnSurface(points, normal) {
	            (0, _triangulation.TriangulatePolygons)([points], normal, function (v) {
	              return v.toArray();
	            }, function (arr) {
	              return new _vector2.default().set3(arr);
	            }).forEach(function (tr) {
	              return triangles.push(tr);
	            });
	          };
	
	          var d = _step.value;
	
	          var base = d.basePath.points;
	          var lid = d.lidPath.points;
	          var n = base.length;
	          for (var p = n - 1, q = 0; q < n; p = q++) {
	            triangles.push([base[p], base[q], lid[q]]);
	            triangles.push([lid[q], lid[p], base[p]]);
	          }
	
	          collectOnSurface(base, d.baseSurface.normal);
	          collectOnSurface(lid, d.lidSurface.normal);
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      return triangles;
	    }
	  }]);
	
	  return ExtrudePreviewer;
	}(_previewWizard.SketchBasedPreviewer);
	
	var EXTRUDE_PREVIEWER = new ExtrudePreviewer(false);
	var CUT_PREVIEWER = new ExtrudePreviewer(true);

/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.CURRENT_SELECTION = exports.Wizard = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _toolkit = __webpack_require__(300);
	
	var tk = _interopRequireWildcard(_toolkit);
	
	var _utils = __webpack_require__(330);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Wizard = exports.Wizard = function () {
	  function Wizard(app, opearation, metadata, initialState) {
	    _classCallCheck(this, Wizard);
	
	    this.app = app;
	    this.metadata = metadata;
	    this.formFields = {};
	    this.box = this.createUI(opearation, metadata);
	    this.overridingHistory = false;
	    if (initialState != undefined) {
	      this.setFormFields(initialState);
	    }
	  }
	
	  _createClass(Wizard, [{
	    key: 'createRequest',
	    value: function createRequest() {
	      return {
	        type: this.operation,
	        params: this.readFormFields()
	      };
	    }
	  }, {
	    key: 'uiLabel',
	    value: function uiLabel(name) {
	      return (0, _utils.camelCaseSplit)(name).map(function (w) {
	        return w.toLowerCase();
	      }).join(' ');
	    }
	  }, {
	    key: 'focus',
	    value: function focus() {
	      this.box.root.find('input, select').first().focus();
	    }
	  }, {
	    key: 'createUI',
	    value: function createUI(operation, metadata) {
	      var _this = this;
	
	      var box = new tk.Box($('#view-3d'));
	      var folder = new tk.Folder(operation);
	      tk.add(box, folder);
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = metadata[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var def = _step.value;
	
	          var name = def[0];
	          var type = def[1];
	          var defaultValue = def[2];
	          var params = def[3] || {};
	          var label = this.uiLabel(name);
	          var formItem = this.createFormField(name, label, type, params, defaultValue);
	          formItem.setter(defaultValue);
	          tk.add(folder, formItem.ui);
	          this.formFields[name] = formItem;
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      var buttons = new tk.ButtonRow(["Cancel", "OK"], [function () {
	        return _this.cancelClick();
	      }, function () {
	        return _this.okClick();
	      }]);
	      tk.add(folder, buttons);
	      box.root.keydown(function (e) {
	        switch (e.keyCode) {
	          case 27:
	            _this.cancelClick();break;
	          case 13:
	            _this.okClick();break;
	        }
	      });
	
	      return box;
	    }
	  }, {
	    key: 'cancelClick',
	    value: function cancelClick() {
	      this.dispose();
	    }
	  }, {
	    key: 'okClick',
	    value: function okClick() {
	      this.dispose();
	      this.apply();
	    }
	  }, {
	    key: 'apply',
	    value: function apply() {
	      this.app.craft.modify(this.createRequest(), this.overridingHistory);
	    }
	  }, {
	    key: 'onUIChange',
	    value: function onUIChange() {}
	  }, {
	    key: 'readFormFields',
	    value: function readFormFields() {
	      var params = {};
	      var keys = Object.keys(this.formFields);
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var key = _step2.value;
	
	          params[key] = this.formFields[key].getter();
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	
	      return params;
	    }
	  }, {
	    key: 'setFormFields',
	    value: function setFormFields(params) {
	      var keys = Object.keys(params);
	      var _iteratorNormalCompletion3 = true;
	      var _didIteratorError3 = false;
	      var _iteratorError3 = undefined;
	
	      try {
	        for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	          var name = _step3.value;
	
	          this.setFormField(name, params[name]);
	        }
	      } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion3 && _iterator3.return) {
	            _iterator3.return();
	          }
	        } finally {
	          if (_didIteratorError3) {
	            throw _iteratorError3;
	          }
	        }
	      }
	    }
	  }, {
	    key: 'setFormField',
	    value: function setFormField(name, value) {
	      var formField = this.formFields[name];
	      if (formField) {
	        formField.setter(value);
	      }
	    }
	  }, {
	    key: 'dispose',
	    value: function dispose() {
	      this.disposed = true;
	      this.box.close();
	    }
	  }, {
	    key: 'createFormField',
	    value: function createFormField(name, label, type, params, initValue) {
	      var _this2 = this;
	
	      if (type == 'number') {
	        var number = tk.config(new tk.Number(label, initValue, params.step, params.round), params);
	        number.input.on('t-change', function () {
	          return _this2.onUIChange(name);
	        });
	        return Field.fromInput(number, Field.TEXT_TO_NUMBER_COERCION);
	      } else if (type == 'choice') {
	        var ops = params.options;
	        var radio = new tk.InlineRadio(ops, ops, ops.indexOf(initValue));
	        radio.root.find('input[type=radio]').on('change', function () {
	          _this2.onUIChange(name);
	        });
	        return new Field(radio, function () {
	          return radio.getValue();
	        }, function (v) {
	          return radio.setValue(v);
	        });
	      } else if (type == 'face') {
	        return selectionWidget(name, label, initValue, this.app.viewer.selectionMgr, function (selection) {
	          return selection.id;
	        });
	      } else if (type == 'sketch.segment') {
	        return selectionWidget(name, label, initValue, this.app.viewer.sketchSelectionMgr, function (selection) {
	          return selection.__TCAD_SketchObject.id;
	        });
	      }
	    }
	  }]);
	
	  return Wizard;
	}();
	
	function selectionWidget(name, label, initValue, selectionManager, toId) {
	  var _this3 = this;
	
	  var obj = new tk.Text(label, initValue);
	  obj.input.on('change', function () {
	    return _this3.onUIChange(name);
	  });
	  return Field.fromInput(obj, undefined, function (objId) {
	    if (objId === CURRENT_SELECTION) {
	      var selection = selectionManager.selection[0];
	      return selection ? toId(selection) : '';
	    } else {
	      return objId;
	    }
	  });
	}
	
	function FaceSelectionListener() {
	  this.callbacks = [];
	}
	
	function Field(ui, getter, setter) {
	  this.ui = ui;
	  this.getter = getter;
	  this.setter = setter;
	}
	
	Field.NO_COERCION = function (v) {
	  return v;
	};
	Field.NUMBER_TO_TEXT_COERCION = function (v) {
	  return v + "";
	};
	Field.TEXT_TO_NUMBER_COERCION = function (v) {
	  return parseFloat(v);
	};
	
	Field.fromInput = function (inputEl, getterCoercer, setterCoercer) {
	  getterCoercer = getterCoercer || Field.NO_COERCION;
	  setterCoercer = setterCoercer || Field.NO_COERCION;
	  return new Field(inputEl, function () {
	    return getterCoercer(inputEl.input.val());
	  }, function (value) {
	    return inputEl.input.val(setterCoercer(value));
	  });
	};
	
	var CURRENT_SELECTION = exports.CURRENT_SELECTION = {};

/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.IMAGINARY_SURFACE_MATERIAL = exports.SketchBasedNurbsPreviewer = exports.SketchBasedPreviewer = exports.PreviewWizard = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _wizard = __webpack_require__(385);
	
	var _sketchReader = __webpack_require__(376);
	
	var _loop2 = __webpack_require__(362);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var PreviewWizard = exports.PreviewWizard = function (_Wizard) {
	  _inherits(PreviewWizard, _Wizard);
	
	  function PreviewWizard(app, opearation, metadata, initialState) {
	    _classCallCheck(this, PreviewWizard);
	
	    var _this = _possibleConstructorReturn(this, (PreviewWizard.__proto__ || Object.getPrototypeOf(PreviewWizard)).call(this, app, opearation, metadata, initialState));
	
	    _this.operation = opearation;
	    _this.previewGroup = new THREE.Object3D();
	    _this.previewObject = null;
	    _this.app.viewer.workGroup.add(_this.previewGroup);
	    _this.updatePreview();
	    return _this;
	  }
	
	  _createClass(PreviewWizard, [{
	    key: 'createPreviewObject',
	    value: function createPreviewObject() {
	      throw 'abstract';
	    }
	  }, {
	    key: 'updatePreview',
	    value: function updatePreview() {
	      this.destroyPreviewObject();
	      this.previewObject = this.createPreviewObject(this.app, this.readFormFields());
	      if (this.previewObject != null) {
	        this.previewGroup.add(this.previewObject);
	      }
	      this.app.viewer.render();
	    }
	  }, {
	    key: 'destroyPreviewObject',
	    value: function destroyPreviewObject() {
	      if (this.previewObject != null) {
	        this.previewGroup.remove(this.previewObject);
	        this.previewObject.geometry.dispose();
	        this.previewObject = null;
	      }
	    }
	  }, {
	    key: 'onUIChange',
	    value: function onUIChange() {
	      _get(PreviewWizard.prototype.__proto__ || Object.getPrototypeOf(PreviewWizard.prototype), 'onUIChange', this).call(this);
	      this.updatePreview();
	    }
	  }, {
	    key: 'dispose',
	    value: function dispose() {
	      this.destroyPreviewObject();
	      this.app.viewer.workGroup.remove(this.previewGroup);
	      this.app.viewer.render();
	      _get(PreviewWizard.prototype.__proto__ || Object.getPrototypeOf(PreviewWizard.prototype), 'dispose', this).call(this);
	    }
	  }]);
	
	  return PreviewWizard;
	}(_wizard.Wizard);
	
	PreviewWizard.createMesh = function (triangles) {
	  var geometry = new THREE.Geometry();
	
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = triangles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var tr = _step.value;
	
	      var a = geometry.vertices.length;
	      var b = a + 1;
	      var c = a + 2;
	      var face = new THREE.Face3(a, b, c);
	      tr.forEach(function (v) {
	        return geometry.vertices.push(v.three());
	      });
	      geometry.faces.push(face);
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  geometry.mergeVertices();
	  geometry.computeFaceNormals();
	
	  return new THREE.Mesh(geometry, IMAGINARY_SURFACE_MATERIAL);
	};
	
	var SketchBasedPreviewer = exports.SketchBasedPreviewer = function () {
	  function SketchBasedPreviewer() {
	    //this.fixToCCW = true;
	
	    _classCallCheck(this, SketchBasedPreviewer);
	  }
	
	  _createClass(SketchBasedPreviewer, [{
	    key: 'createImpl',
	    value: function createImpl(app, params, sketch, face) {
	      throw 'not implemented';
	    }
	  }, {
	    key: 'create',
	    value: function create(app, params) {
	      var face = app.findFace(params.face);
	      if (!face) return null;
	      var needSketchRead = !this.sketch || params.face != this.face;
	      if (needSketchRead) {
	        this.sketch = (0, _sketchReader.ReadSketchFromFace)(app, face);
	        //for (let polygon of this.sketch) {
	        //if (!Loop.isPolygonCCWOnSurface(polygon, face.surface()) && this.fixToCCW) {
	        //  polygon.reverse();
	        //}
	        //}
	        this.face = params.face;
	      }
	      var triangles = this.createImpl(app, params, this.sketch.fetchContours(), face);
	      return PreviewWizard.createMesh(triangles);
	    }
	  }]);
	
	  return SketchBasedPreviewer;
	}();
	
	var SketchBasedNurbsPreviewer = exports.SketchBasedNurbsPreviewer = function () {
	  function SketchBasedNurbsPreviewer() {
	    _classCallCheck(this, SketchBasedNurbsPreviewer);
	  }
	
	  _createClass(SketchBasedNurbsPreviewer, [{
	    key: 'createNurbses',
	    value: function createNurbses(app, params, sketch, face) {
	      throw 'not implemented';
	    }
	  }, {
	    key: 'createMesh',
	    value: function createMesh(app, params) {
	      var face = app.findFace(params.face);
	      if (!face) return null;
	      var needSketchRead = !this.sketch || params.face != this.face;
	      if (needSketchRead) {
	        this.sketch = (0, _sketchReader.ReadSketchFromFace)(app, face);
	        this.face = params.face;
	      }
	      var nurbses = this.createNurbses(app, params, this.sketch, face);
	      var geom = new THREE.Geometry();
	
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        var _loop = function _loop() {
	          var nurbs = _step2.value;
	
	          var off = geom.vertices.length;
	          var tess = nurbs.tessellate({ maxDepth: 3 });
	          var points = [];
	          tess.points.forEach(function (p) {
	            return geom.vertices.push(new THREE.Vector3().fromArray(p));
	          });
	          var _iteratorNormalCompletion3 = true;
	          var _didIteratorError3 = false;
	          var _iteratorError3 = undefined;
	
	          try {
	            for (var _iterator3 = tess.faces[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	              var faceIndices = _step3.value;
	
	              var normales = faceIndices.map(function (x) {
	                var vn = tess.normals[x];
	                return new THREE.Vector3(vn[0], vn[1], vn[2]);
	              });
	              var _face = new THREE.Face3(faceIndices[0] + off, faceIndices[1] + off, faceIndices[2] + off, normales);
	              geom.faces.push(_face);
	            }
	          } catch (err) {
	            _didIteratorError3 = true;
	            _iteratorError3 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                _iterator3.return();
	              }
	            } finally {
	              if (_didIteratorError3) {
	                throw _iteratorError3;
	              }
	            }
	          }
	        };
	
	        for (var _iterator2 = nurbses[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          _loop();
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	
	      return new THREE.Mesh(geom, IMAGINARY_SURFACE_MATERIAL);
	    }
	  }]);
	
	  return SketchBasedNurbsPreviewer;
	}();
	
	var IMAGINARY_SURFACE_MATERIAL = exports.IMAGINARY_SURFACE_MATERIAL = new THREE.MeshPhongMaterial({
	  vertexColors: THREE.FaceColors,
	  color: 0xFA8072,
	  transparent: true,
	  opacity: 0.5,
	  shininess: 0,
	  depthWrite: false,
	  depthTest: false,
	  side: THREE.DoubleSide
	});

/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.RevolvePreviewer = exports.RevolveWizard = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _wizard = __webpack_require__(385);
	
	var _previewWizard = __webpack_require__(386);
	
	var _triangulation = __webpack_require__(320);
	
	var _brepBuilder = __webpack_require__(360);
	
	var _revolve = __webpack_require__(380);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var METADATA = [['angle', 'number', 5, { min: -360, max: 360, step: 10 }], ['pivot', 'sketch.segment', _wizard.CURRENT_SELECTION], ['face', 'face', _wizard.CURRENT_SELECTION]];
	
	var RevolveWizard = exports.RevolveWizard = function (_PreviewWizard) {
	  _inherits(RevolveWizard, _PreviewWizard);
	
	  function RevolveWizard(app, initialState) {
	    _classCallCheck(this, RevolveWizard);
	
	    return _possibleConstructorReturn(this, (RevolveWizard.__proto__ || Object.getPrototypeOf(RevolveWizard)).call(this, app, 'REVOLVE', METADATA, initialState));
	  }
	
	  _createClass(RevolveWizard, [{
	    key: 'createPreviewObject',
	    value: function createPreviewObject(app, params) {
	      return REVOLVE_PREVIEWER.createMesh(app, params);
	    }
	  }]);
	
	  return RevolveWizard;
	}(_previewWizard.PreviewWizard);
	
	var RevolvePreviewer = exports.RevolvePreviewer = function (_SketchBasedNurbsPrev) {
	  _inherits(RevolvePreviewer, _SketchBasedNurbsPrev);
	
	  function RevolvePreviewer() {
	    _classCallCheck(this, RevolvePreviewer);
	
	    return _possibleConstructorReturn(this, (RevolvePreviewer.__proto__ || Object.getPrototypeOf(RevolvePreviewer)).apply(this, arguments));
	  }
	
	  _createClass(RevolvePreviewer, [{
	    key: 'createNurbses',
	    value: function createNurbses(app, params, sketch, face) {
	      var surface = face.surface();
	      var pivot = (0, _revolve.evalPivot)(params.pivot, sketch, surface);
	      var nurbses = [];
	      var contours = sketch.fetchContours();
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = contours[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var contour = _step.value;
	
	          var basePath = contour.transferOnSurface(surface);
	          (0, _brepBuilder.revolveToWallNurbs)(basePath, surface, pivot.p0, pivot.v, params.angle).forEach(function (nurbs) {
	            return nurbses.push(nurbs);
	          });
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      return nurbses;
	    }
	  }]);
	
	  return RevolvePreviewer;
	}(_previewWizard.SketchBasedNurbsPreviewer);
	
	var REVOLVE_PREVIEWER = new RevolvePreviewer();

/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.PlaneWizard = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _previewWizard = __webpack_require__(386);
	
	var _wizard = __webpack_require__(385);
	
	var _l3space = __webpack_require__(308);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var METADATA = [['orientation', 'choice', 'XY', { options: ['XY', 'XZ', 'ZY'] }], ['parallelTo', 'face', _wizard.CURRENT_SELECTION], ['depth', 'number', 0, {}]];
	
	var PlaneWizard = exports.PlaneWizard = function (_PreviewWizard) {
	  _inherits(PlaneWizard, _PreviewWizard);
	
	  function PlaneWizard(app, initialState) {
	    _classCallCheck(this, PlaneWizard);
	
	    return _possibleConstructorReturn(this, (PlaneWizard.__proto__ || Object.getPrototypeOf(PlaneWizard)).call(this, app, 'PLANE', METADATA, initialState));
	  }
	
	  _createClass(PlaneWizard, [{
	    key: 'createPreviewObject',
	    value: function createPreviewObject(app, params) {
	      var face = null;
	      if (params.parallelTo) {
	        face = this.app.findFace(params.parallelTo);
	      }
	      var basis = void 0;
	      var depth = params.depth;
	      if (face == null) {
	        basis = _l3space.STANDARD_BASES[params.orientation];
	      } else {
	        basis = face.basis();
	        depth += face.depth();
	      }
	
	      var w = 375,
	          h = 375;
	      var a = new _vector2.default(-w, -h, 0);
	      var b = new _vector2.default(w, -h, 0);
	      var c = new _vector2.default(w, h, 0);
	      var d = new _vector2.default(-w, h, 0);
	
	      var plane = _previewWizard.PreviewWizard.createMesh([[a, b, c], [a, c, d]]);
	
	      var m = new THREE.Matrix4();
	      m.makeBasis.apply(m, basis);
	      var wVec = new THREE.Vector3(0, 0, depth);
	      wVec.applyMatrix4(m);
	      m.setPosition(wVec);
	      plane.geometry.applyMatrix(m);
	      plane.geometry.computeFaceNormals();
	      return plane;
	    }
	  }]);

	  return PlaneWizard;
	}(_previewWizard.PreviewWizard);

/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.BoxWizard = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _previewWizard = __webpack_require__(386);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var METADATA = [['width', 'number', 500, { min: 0 }], ['height', 'number', 500, { min: 0 }], ['depth', 'number', 500, { min: 0 }]];
	
	var BoxWizard = exports.BoxWizard = function (_PreviewWizard) {
	  _inherits(BoxWizard, _PreviewWizard);
	
	  function BoxWizard(app, initialState) {
	    _classCallCheck(this, BoxWizard);
	
	    return _possibleConstructorReturn(this, (BoxWizard.__proto__ || Object.getPrototypeOf(BoxWizard)).call(this, app, 'BOX', METADATA, initialState));
	  }
	
	  _createClass(BoxWizard, [{
	    key: 'createPreviewObject',
	    value: function createPreviewObject(app, params) {
	      var geometry = new THREE.BoxGeometry(params.width, params.height, params.depth);
	      return new THREE.Mesh(geometry, _previewWizard.IMAGINARY_SURFACE_MATERIAL);
	    }
	  }]);

	  return BoxWizard;
	}(_previewWizard.PreviewWizard);

/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SphereWizard = SphereWizard;
	
	var _l3space = __webpack_require__(308);
	
	var _toolkit = __webpack_require__(300);
	
	var tk = _interopRequireWildcard(_toolkit);
	
	var _cadUtils = __webpack_require__(302);
	
	var _wizardCommons = __webpack_require__(391);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function SphereWizard(viewer, initParams) {
	  _wizardCommons.Wizard.call(this, viewer, initParams);
	  this.previewGroup = new THREE.Object3D();
	  this.viewer.scene.add(this.previewGroup);
	  this.previewGroup.add(this.sphere = this.createSphere());
	  this.synch();
	}
	
	SphereWizard.prototype = Object.create(_wizardCommons.Wizard.prototype);
	
	SphereWizard.prototype.DEFAULT_PARAMS = [500];
	
	SphereWizard.prototype.title = function () {
	  return "Add a Sphere";
	};
	
	SphereWizard.prototype.createSphere = function () {
	  var geometry = new THREE.SphereGeometry(1, 30, 28);
	  var material = new THREE.MeshLambertMaterial({ color: _cadUtils.FACE_COLOR, transparent: true, opacity: 0.9 });
	  return new THREE.Mesh(geometry, material);
	};
	
	SphereWizard.prototype.update = function (radius) {
	  this.sphere.scale.x = radius;
	  this.sphere.scale.y = radius;
	  this.sphere.scale.z = radius;
	  this.viewer.render();
	};
	
	SphereWizard.prototype.createUI = function (radius) {
	  this.ui.radius = tk.config(new tk.Number("Radius", radius), { min: 0 });
	  tk.add(this.ui.folder, this.ui.radius);
	  var onChange = tk.methodRef(this, "synch");
	  this.ui.radius.input.on('t-change', onChange);
	};
	
	SphereWizard.prototype.synch = function () {
	  this.update.apply(this, this.getParams());
	  this.viewer.render();
	};
	
	SphereWizard.prototype.getParams = function () {
	  return [this.ui.radius.val()];
	};
	
	SphereWizard.prototype.createRequest = function (done) {
	  var params = this.getParams();
	  done({
	    type: 'SPHERE',
	    solids: [],
	    params: { radius: params[0] },
	    protoParams: params
	  });
	};
	
	SphereWizard.prototype.dispose = function () {
	  _wizardCommons.Wizard.prototype.dispose.call(this);
	  this.viewer.scene.remove(this.previewGroup);
	  this.viewer.render();
	};

/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.BASE_MATERIAL = exports.IMAGINARY_SURFACE_MATERIAL = exports.IMAGINE_MATERIAL = exports.OpWizard = undefined;
	exports.Wizard = Wizard;
	
	var _dpr = __webpack_require__(325);
	
	var _dpr2 = _interopRequireDefault(_dpr);
	
	var _toolkit = __webpack_require__(300);
	
	var tk = _interopRequireWildcard(_toolkit);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var IMAGINE_MATERIAL = new THREE.LineBasicMaterial({
	  color: 0xFA8072,
	  linewidth: 1 / _dpr2.default,
	  depthWrite: false,
	  depthTest: false
	});
	
	var BASE_MATERIAL = new THREE.LineBasicMaterial({
	  color: 0x8B0000,
	  linewidth: 3 / _dpr2.default,
	  depthWrite: false,
	  depthTest: false
	});
	
	var IMAGINARY_SURFACE_MATERIAL = new THREE.MeshPhongMaterial({
	  vertexColors: THREE.FaceColors,
	  color: 0xFA8072,
	  transparent: true,
	  opacity: 0.5,
	  shininess: 0,
	  side: THREE.DoubleSide
	});
	
	function Wizard(viewer, initParams) {
	  var _this = this;
	
	  if (!initParams) initParams = this.DEFAULT_PARAMS;
	  this.viewer = viewer;
	  this.disposed = false;
	  this.ui = {
	    box: new tk.Box($('#view-3d')),
	    folder: new tk.Folder(this.title())
	  };
	  tk.add(this.ui.box, this.ui.folder);
	
	  this.ui.box.root.keydown(function (e) {
	    switch (e.keyCode) {
	      case 27:
	        _this.cancelClick();break;
	      case 13:
	        _this.okClick();break;
	    }
	  });
	
	  this.createUI.apply(this, initParams);
	  this.addButtons(this.ui.folder);
	}
	
	Wizard.prototype.apply = function (done) {
	  var _this2 = this;
	
	  this.createRequest(function (request) {
	    try {
	      if (!_this2.disposed) {
	        _this2.onRequestReady(request);
	      }
	    } finally {
	      done();
	    }
	  });
	};
	
	Wizard.prototype.onRequestReady = function () {}; // For clients
	
	Wizard.prototype.okClick = function () {
	  var _this3 = this;
	
	  this.ui.buttons.root.find('.tc-block-btn').eq(1).removeClass('active-btn').html('<i class="fa fa-cog fa-spin"></i>');
	  this.apply(function () {
	    return _this3.dispose();
	  });
	};
	
	Wizard.prototype.cancelClick = function () {
	  this.dispose();
	};
	
	Wizard.prototype.dispose = function () {
	  this.disposed = true;
	  this.ui.box.close();
	};
	
	Wizard.prototype.focus = function () {
	  this.ui.box.root.find('input, select').first().focus();
	};
	
	Wizard.prototype.addButtons = function (folder) {
	  var _this4 = this;
	
	  this.ui.buttons = new tk.ButtonRow(["Cancel", "OK"], [function () {
	    return _this4.cancelClick();
	  }, function () {
	    return _this4.okClick();
	  }]);
	  tk.add(folder, this.ui.buttons);
	};
	
	Wizard.InvalidRequest = function (message) {
	  this.invalidAndShouldBeDropped = true;
	  this.message = message;
	};
	
	function OpWizard(viewer, initParams) {
	  Wizard.call(this, viewer, initParams);
	  this.previewGroup = new THREE.Object3D();
	  this.lines = [];
	  viewer.scene.add(this.previewGroup);
	}
	
	OpWizard.prototype = Object.create(Wizard.prototype);
	
	OpWizard.prototype.setupLine = function (lineId, a, b, material) {
	  var line = this.lines[lineId];
	  if (line === undefined) {
	    var lg = new THREE.Geometry();
	    lg.vertices.push(new THREE.Vector3().copy(a));
	    lg.vertices.push(new THREE.Vector3().copy(b));
	    line = new THREE.Line(lg, material);
	    line.renderOrder = 1e10;
	    this.previewGroup.add(line);
	    this.lines[lineId] = line;
	  } else {
	    line.geometry.vertices[0] = new THREE.Vector3().copy(a);
	    line.geometry.vertices[1] = new THREE.Vector3().copy(b);
	    line.geometry.verticesNeedUpdate = true;
	  }
	};
	
	OpWizard.prototype.disposeLines = function () {
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = this.lines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var line = _step.value;
	
	      line.geometry.dispose();
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	};
	
	OpWizard.prototype.dispose = function () {
	  Wizard.prototype.dispose.call(this);
	  this.viewer.scene.remove(this.previewGroup);
	  this.disposeLines();
	  this.viewer.render();
	};
	
	exports.OpWizard = OpWizard;
	exports.IMAGINE_MATERIAL = IMAGINE_MATERIAL;
	exports.IMAGINARY_SURFACE_MATERIAL = IMAGINARY_SURFACE_MATERIAL;
	exports.BASE_MATERIAL = BASE_MATERIAL;

/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TransformWizard = TransformWizard;
	
	var _l3space = __webpack_require__(308);
	
	var _toolkit = __webpack_require__(300);
	
	var tk = _interopRequireWildcard(_toolkit);
	
	var _cadUtils = __webpack_require__(302);
	
	var _wizardCommons = __webpack_require__(391);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function TransformWizard(viewer, solid, initParams) {
	  _wizardCommons.Wizard.call(this, viewer, initParams);
	  this.previewGroup = new THREE.Object3D();
	  this.solid = solid;
	  this.initialPosition = this.solid.cadGroup.position.clone();
	  this.viewer.transformControls.attach(this.solid.cadGroup);
	  this.transfomControlListener = tk.methodRef(this, "synchToUI");
	  this.viewer.transformControls.addEventListener('objectChange', this.transfomControlListener);
	  this.synch();
	}
	
	TransformWizard.prototype = Object.create(_wizardCommons.Wizard.prototype);
	
	TransformWizard.prototype.DEFAULT_PARAMS = [0, 0, 0, 0, 0, 0, 1];
	
	TransformWizard.prototype.title = function () {
	  return "Solid Transform";
	};
	
	TransformWizard.prototype.discardChanges = function () {
	  this.solid.cadGroup.position.copy(this.initialPosition);
	};
	
	TransformWizard.prototype.update = function (x, y, z, rotationX, rotationY, rotationZ, rotationW) {
	  this.solid.cadGroup.position.setX(x);
	  this.solid.cadGroup.position.setX(y);
	  this.solid.cadGroup.position.setX(z);
	
	  this.solid.cadGroup.quaternion.x = rotationX;
	  this.solid.cadGroup.quaternion.y = rotationY;
	  this.solid.cadGroup.quaternion.z = rotationZ;
	  this.solid.cadGroup.quaternion.w = rotationW;
	
	  this.viewer.transformControls.update();
	  this.viewer.render();
	};
	
	TransformWizard.prototype.createUI = function (x, y, z, rotationX, rotationY, rotationZ, rotationW) {
	  var ui = this.ui;
	  var folder = ui.folder;
	  var position = new tk.Folder("Position");
	  var rotation = new tk.Folder("Rotation");
	  tk.add(folder, position);
	  tk.add(folder, rotation);
	  tk.add(ui.box, folder);
	  ui.x = new tk.Number("Position X", x, 1, 6);
	  ui.y = new tk.Number("Position Y", y, 1, 6);
	  ui.z = new tk.Number("Position Z", z, 1, 6);
	  ui.rotationX = tk.config(new tk.Number("Rotation X", rotationX, 0.1, 6), { min: -1, max: 1 });
	  ui.rotationY = tk.config(new tk.Number("Rotation Y", rotationY, 0.1, 6), { min: -1, max: 1 });
	  ui.rotationZ = tk.config(new tk.Number("Rotation Z", rotationZ, 0.1, 6), { min: -1, max: 1 });
	  ui.rotationW = tk.config(new tk.Number("Rotation W", rotationW, 0.1, 6), { min: -1, max: 1 });
	  ui.mode = new tk.InlineRadio(['translate(T)', 'rotate(R)'], ['translate', 'rotate'], 0);
	  tk.add(position, ui.x);
	  tk.add(position, ui.y);
	  tk.add(position, ui.z);
	  tk.add(rotation, ui.rotationX);
	  tk.add(rotation, ui.rotationY);
	  tk.add(rotation, ui.rotationZ);
	  tk.add(rotation, ui.rotationW);
	  tk.add(rotation, ui.mode);
	  this.ui.mode.root.find('input:radio').change(tk.methodRef(this, "modeChanged"));
	  var onChange = tk.methodRef(this, "synch");
	  ui.x.input.on('t-change', onChange);
	  ui.y.input.on('t-change', onChange);
	  ui.z.input.on('t-change', onChange);
	  ui.rotationX.input.on('t-change', onChange);
	  ui.rotationY.input.on('t-change', onChange);
	  ui.rotationZ.input.on('t-change', onChange);
	};
	
	TransformWizard.prototype.modeChanged = function () {
	  var mode = this.ui.mode.getValue();
	  this.viewer.transformControls.setMode(mode);
	};
	
	TransformWizard.prototype.synchToUI = function () {
	  function round(val) {
	    return val.toFixed(6);
	  }
	  var ui = this.ui;
	  ui.x.input.val(round(this.solid.cadGroup.position.x));
	  ui.y.input.val(round(this.solid.cadGroup.position.y));
	  ui.z.input.val(round(this.solid.cadGroup.position.z));
	  ui.rotationX.input.val(round(this.solid.cadGroup.quaternion.x));
	  ui.rotationY.input.val(round(this.solid.cadGroup.quaternion.y));
	  ui.rotationZ.input.val(round(this.solid.cadGroup.quaternion.z));
	  ui.rotationW.input.val(round(this.solid.cadGroup.quaternion.w));
	  this.viewer.render();
	};
	
	TransformWizard.prototype.synch = function () {
	  this.update.apply(this, this.getParams());
	  this.viewer.render();
	};
	
	TransformWizard.prototype.getParams = function () {
	  return [this.ui.x.val(), this.ui.y.val(), this.ui.z.val(), this.ui.rotationX.val(), this.ui.rotationY.val(), this.ui.rotationZ.val(), this.ui.rotationW.val()];
	};
	
	TransformWizard.prototype.createRequest = function (done) {
	  var params = this.getParams();
	  done({
	    type: 'TRANSFORM',
	    solids: [],
	    params: {
	      position: { x: params[0], y: params[1], z: params[2] },
	      rotate: { x: params[3], y: params[4], z: params[5] }
	    },
	    protoParams: params
	  });
	};
	
	TransformWizard.prototype.cancelClick = function () {
	  _wizardCommons.Wizard.prototype.cancelClick.call(this);
	  this.discardChanges();
	};
	
	TransformWizard.prototype.dispose = function () {
	  _wizardCommons.Wizard.prototype.dispose.call(this);
	  this.viewer.transformControls.removeEventListener('objectChange', this.transfomControlListener);
	  this.viewer.transformControls.detach(this.solid.cadGroup);
	  this.viewer.render();
	};

/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ImportWizard = ImportWizard;
	
	var _toolkit = __webpack_require__(300);
	
	var tk = _interopRequireWildcard(_toolkit);
	
	var _workbench = __webpack_require__(311);
	
	var workbench = _interopRequireWildcard(_workbench);
	
	var _cadUtils = __webpack_require__(302);
	
	var cad_utils = _interopRequireWildcard(_cadUtils);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _wizardCommons = __webpack_require__(391);
	
	var _io = __webpack_require__(314);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function ImportWizard(viewer, initParams) {
	  _wizardCommons.Wizard.call(this, viewer, initParams);
	}
	
	ImportWizard.prototype = Object.create(_wizardCommons.Wizard.prototype);
	
	ImportWizard.prototype.DEFAULT_PARAMS = ['https://cdn.thingiverse.com/assets/de/88/44/ab/fe/Touring_Bike_not_for_print.stl'];
	
	ImportWizard.prototype.title = function () {
	  return "Import URL";
	};
	
	ImportWizard.prototype.createUI = function (url) {
	  this.ui.url = new tk.Text("URL", url);
	  tk.add(this.ui.folder, this.ui.url);
	};
	
	ImportWizard.prototype.getParams = function () {
	  return [this.ui.url.input.val()];
	};
	
	ImportWizard.prototype.createRequest = function (done) {
	  var protoParams = this.getParams();
	  var url = protoParams[0];
	  (0, _io.LoadSTLFromURL)(url, function (objects, err) {
	    if (objects == null || objects.length == 0) {
	      done(new _wizardCommons.Wizard.InvalidRequest("Server returned no data or format isn't supported." + (err ? " Http Status: " + err : "")));
	    } else {
	      done({
	        type: 'IMPORT_STL',
	        solids: [],
	        params: { objects: objects, url: url },
	        protoParams: protoParams
	      });
	    }
	  });
	};

/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.BINDERS = exports.FORMATTERS = exports.BINDING_CALLBACK = undefined;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.Bind = Bind;
	exports.BindArray = BindArray;
	exports.Scope = Scope;
	
	var _sprintf = __webpack_require__(395);
	
	var BINDING_CALLBACK = exports.BINDING_CALLBACK = 'OnBind';
	
	function Bind(node, data, policy) {
	  var scope = getScope(node);
	  var props = Object.getOwnPropertyNames(data);
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = props[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var prop = _step.value;
	
	      if (prop == BINDING_CALLBACK) continue;
	      var value = data[prop];
	      if (Array.isArray(value)) {
	        var nodesToBind = scope.nestedScopes[prop];
	        if (!nodesToBind) continue;
	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;
	
	        try {
	          for (var _iterator2 = nodesToBind[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var nodeToBind = _step2.value;
	
	            BindArray(nodeToBind, value, policy);
	          }
	        } catch (err) {
	          _didIteratorError2 = true;
	          _iteratorError2 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	              _iterator2.return();
	            }
	          } finally {
	            if (_didIteratorError2) {
	              throw _iteratorError2;
	            }
	          }
	        }
	      } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	        var _nodesToBind = scope.nestedScopes[prop];
	        if (!_nodesToBind) continue;
	        var _iteratorNormalCompletion3 = true;
	        var _didIteratorError3 = false;
	        var _iteratorError3 = undefined;
	
	        try {
	          for (var _iterator3 = _nodesToBind[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	            var _nodeToBind = _step3.value;
	
	            Bind(_nodeToBind, value, policy);
	          }
	        } catch (err) {
	          _didIteratorError3 = true;
	          _iteratorError3 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion3 && _iterator3.return) {
	              _iterator3.return();
	            }
	          } finally {
	            if (_didIteratorError3) {
	              throw _iteratorError3;
	            }
	          }
	        }
	      } else {
	        var bindCallbacks = scope.bindings[prop];
	        if (!bindCallbacks) continue;
	        var _iteratorNormalCompletion4 = true;
	        var _didIteratorError4 = false;
	        var _iteratorError4 = undefined;
	
	        try {
	          for (var _iterator4 = bindCallbacks[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	            var bindCallback = _step4.value;
	
	            bindCallback(value, policy);
	          }
	        } catch (err) {
	          _didIteratorError4 = true;
	          _iteratorError4 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion4 && _iterator4.return) {
	              _iterator4.return();
	            }
	          } finally {
	            if (_didIteratorError4) {
	              throw _iteratorError4;
	            }
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  var callback = data[BINDING_CALLBACK];
	  if (callback) {
	    callback(node, data, policy);
	  }
	}
	
	function BindArray(node, array, policy) {
	  var scope = getScope(node);
	  var template = detachTemplate(node);
	
	  function createFromTemplate(id) {
	    var child = template.clone();
	    child.attr('data-bind-scope', id);
	    scope.nestedScopes[id] = [child];
	    return child;
	  }
	
	  var children = node.children();
	  var domPointer = 0;
	  for (var dataPointer = 0; dataPointer < array.length; dataPointer++) {
	    var value = array[dataPointer];
	    var domItem = void 0;
	    if (domPointer == children.length) {
	      domItem = createFromTemplate(value.id);
	      node.append(domItem);
	    } else {
	      domItem = children.eq(domPointer);
	      var domItemId = domItem.attr('data-bind-scope');
	      if (domItemId != value.id) {
	        domItem = scope.nestedScopes[value.id];
	        if (!domItem) {
	          domItem = createFromTemplate(value.id);
	        } else {
	          domItem = domItem[0];
	        }
	        if (domPointer == 0) {
	          node.prepend(domItem);
	        } else {
	          children.eq(domPointer - 1).after(domItem);
	        }
	      }
	      domPointer++;
	    }
	    Bind(domItem, value, policy);
	  }
	  //clean up
	  for (; domPointer < children.length; domPointer++) {
	    var item = children.eq(domPointer);
	    item.remove();
	    delete scope[item.attr('data-bind-scope')];
	  }
	}
	
	function detachTemplate(node) {
	  var template = node.data("BindingTemplate");
	  if (!template) {
	    template = node.children();
	    template.detach();
	    node.data("BindingTemplate", template);
	  }
	  return template;
	}
	
	function clearScope(dom) {
	  dom.removeData('BindingScope');
	}
	
	function getScope(dom) {
	  var scope = dom.data('BindingScope');
	  if (!scope) {
	    scope = index(dom);
	    dom.data('BindingScope', scope);
	  }
	  return scope;
	}
	
	function detectBinder(def) {
	  var _iteratorNormalCompletion5 = true;
	  var _didIteratorError5 = false;
	  var _iteratorError5 = undefined;
	
	  try {
	    for (var _iterator5 = BINDERS[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	      var binder = _step5.value;
	
	      if (def.startsWith(binder.prefix)) {
	        return binder;
	      }
	    }
	  } catch (err) {
	    _didIteratorError5 = true;
	    _iteratorError5 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion5 && _iterator5.return) {
	        _iterator5.return();
	      }
	    } finally {
	      if (_didIteratorError5) {
	        throw _iteratorError5;
	      }
	    }
	  }
	
	  return DEFAULT_BINDER;
	}
	
	function setupBindings(bindings, bindingsDefinition, node) {
	  bindingsDefinition.split(',').forEach(function (defStr) {
	    defStr = defStr.trim();
	    var binder = detectBinder(defStr);
	    var def = parseBindDefinition(defStr.substring(binder.prefix.length));
	    addToList(bindings, def.dataKey, function (value, policy) {
	      policy = adjustPolicyForNode(policy, def.policy);
	      var formattedValue = format(def.formatters, value);
	      binder.apply(node, formattedValue, policy, def.key);
	    });
	    binder.init(node);
	  });
	}
	
	function index(dom) {
	  var scope = new Scope();
	  //do bfs
	  var queue = [];
	  function advance(node) {
	    var bindingsDefinition = node.attr('data-bind');
	    if (bindingsDefinition) {
	      setupBindings(scope.bindings, bindingsDefinition, node);
	    }
	    node.children().each(function (i, e) {
	      return queue.push($(e));
	    });
	  }
	  advance(dom);
	  while (queue.length != 0) {
	    var list = false;
	    var node = queue.shift();
	    var nestedScope = node.attr('data-bind-scope');
	    if (!nestedScope) {
	      nestedScope = node.attr('data-bind-list');
	      list = true;
	    }
	    if (nestedScope) {
	      addToList(scope.nestedScopes, nestedScope, node);
	      if (list) {
	        detachTemplate(node);
	      }
	    } else {
	      advance(node);
	    }
	  }
	
	  return scope;
	}
	
	function adjustPolicyForNode(propagatedPolicy, nodePolicy) {
	  var policy = propagatedPolicy || DEFAULT_POLICY;
	  if (nodePolicy) {
	    policy = Object.assign({}, policy, nodePolicy);
	  }
	  return policy;
	}
	
	function addToList(map, key, value) {
	  var list = map[key];
	  if (!list) {
	    list = [];
	    map[key] = list;
	  }
	  list.push(value);
	}
	
	var DEFAULT_POLICY = {
	  hideEmpty: true
	};
	
	var FORMATTERS = exports.FORMATTERS = {
	  capitalize: function capitalize(s) {
	    return s.replace(/\b\w/g, function (l) {
	      return l.toUpperCase();
	    });
	  },
	  uppercase: function uppercase(s) {
	    return s.toUpperCase();
	  },
	  'css-url': function cssUrl(s) {
	    return 'url(' + s + ')';
	  }
	};
	
	function parseDataLink(str, def) {
	  var idx = str.indexOf('|');
	  if (idx == -1) {
	    def.dataKey = str.trim();
	    def.formatters = [];
	  } else {
	    def.dataKey = str.substring(0, idx).trim();
	    def.formatters = str.substring(idx + 1).split('|').map(function (s) {
	      return s.trim();
	    });
	  }
	}
	
	function parsePolicy(policyStr) {
	  var policy = {};
	  policyStr.split('&').forEach(function (p) {
	    p = p.trim();
	    var eqIdx = p.indexOf('=');
	    if (eqIdx == -1) {
	      policy[p] = true;
	    } else {
	      policy[p.substring(0, eqIdx)] = p.substring(eqIdx + 1);
	    }
	  });
	  return policy;
	}
	
	function parseBindDefinition(str) {
	  var def = {};
	  var qmIdx = str.indexOf('?');
	  if (qmIdx != -1) {
	    def.policy = parsePolicy(str.substring(qmIdx + 1));
	    str = str.substring(0, qmIdx);
	  }
	  var colonIdx = str.indexOf(':');
	  if (colonIdx == -1) {
	    parseDataLink(str, def);
	  } else {
	    def.key = str.substring(0, colonIdx).trim();
	    parseDataLink(str.substring(colonIdx + 1), def);
	  }
	  return def;
	}
	
	function format(formatters, value) {
	  var _iteratorNormalCompletion6 = true;
	  var _didIteratorError6 = false;
	  var _iteratorError6 = undefined;
	
	  try {
	    for (var _iterator6 = formatters[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	      var formatterKey = _step6.value;
	
	      var formatter = FORMATTERS[formatterKey];
	      if (formatter) {
	        value = formatter(value);
	      }
	    }
	  } catch (err) {
	    _didIteratorError6 = true;
	    _iteratorError6 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion6 && _iterator6.return) {
	        _iterator6.return();
	      }
	    } finally {
	      if (_didIteratorError6) {
	        throw _iteratorError6;
	      }
	    }
	  }
	
	  return value;
	}
	
	var DEFAULT_BINDER = {
	  prefix: '',
	  apply: function apply(node, value, policy) {
	    var templateData = node.attr('data-bind-template');
	
	    var isEmpty = value === '' || value === undefined || value === null;
	    if (isEmpty) {
	      node.text('');
	    } else {
	      if (templateData) {
	        value = (0, _sprintf.sprintf)(templateData, value);
	      }
	      node.text(value);
	    }
	    if (isEmpty && policy.hideEmpty) {
	      node.hide();
	    } else {
	      node.show();
	    }
	  },
	  init: function init(node) {
	    var template = node.text();
	    if (template) {
	      node.attr('data-bind-template', template);
	    }
	  }
	};
	
	var BINDERS = exports.BINDERS = [{
	  prefix: '@',
	  apply: function apply(node, value, policy, key) {
	    return node.attr(key, value);
	  },
	  init: function init(node) {}
	}, {
	  prefix: '$',
	  apply: function apply(node, value, policy, key) {
	    return node.css(key, value);
	  },
	  init: function init(node) {}
	}, {
	  prefix: '!',
	  apply: function apply(node, value, policy, key) {
	    return value ? node.addClass(key) : node.removeClass(key);
	  },
	  init: function init(node) {}
	}, DEFAULT_BINDER];
	
	function Scope() {
	  this.bindings = {};
	  this.nestedScopes = {};
	}
	
	function example(dom) {
	  var initState = {
	    title: 'this is title',
	    users: [{ id: 1, name: 'Peach', email: 'Peach@ooo.com' }, { id: 2, name: 'Melon', email: 'Melon@ooo.com' }, { id: 3, name: 'Berry', email: 'Berry@ooo.com' }, { id: 4, name: 'Apple', email: 'Apple@ooo.com' }, { id: 5, name: 'Banana', email: 'Banana@ooo.com' }]
	  };
	
	  Bind(dom, initState);
	  //reordering, removing, updating provided attributes
	  Bind(dom, { users: [{ id: 3 }, { id: 1, name: 'Peach-Beach' }, { id: 2 }] });
	  //only content update
	  Bind(dom, { users: {
	      '3': { name: 'updated', email: 'light@update.com' }
	    } });
	}

/***/ },
/* 395 */
/***/ function(module, exports) {

	/**
	sprintf() for JavaScript 0.7-beta1
	http://www.diveintojavascript.com/projects/javascript-sprintf
	
	Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
	All rights reserved.
	
	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:
	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.
	    * Neither the name of sprintf() for JavaScript nor the
	      names of its contributors may be used to endorse or promote products
	      derived from this software without specific prior written permission.
	
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY
	DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	
	
	Changelog:
	2010.11.07 - 0.7-beta1-node
	  - converted it to a node.js compatible module
	
	2010.09.06 - 0.7-beta1
	  - features: vsprintf, support for named placeholders
	  - enhancements: format cache, reduced global namespace pollution
	
	2010.05.22 - 0.6:
	 - reverted to 0.4 and fixed the bug regarding the sign of the number 0
	 Note:
	 Thanks to Raphael Pigulla <raph (at] n3rd [dot) org> (http://www.n3rd.org/)
	 who warned me about a bug in 0.5, I discovered that the last update was
	 a regress. I appologize for that.
	
	2010.05.09 - 0.5:
	 - bug fix: 0 is now preceeded with a + sign
	 - bug fix: the sign was not at the right position on padded results (Kamal Abdali)
	 - switched from GPL to BSD license
	
	2007.10.21 - 0.4:
	 - unit test and patch (David Baird)
	
	2007.09.17 - 0.3:
	 - bug fix: no longer throws exception on empty paramenters (Hans Pufal)
	
	2007.09.11 - 0.2:
	 - feature: added argument swapping
	
	2007.04.03 - 0.1:
	 - initial release
	**/
	
	var sprintf = (function() {
		function get_type(variable) {
			return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
		}
		function str_repeat(input, multiplier) {
			for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
			return output.join('');
		}
	
		var str_format = function() {
			if (!str_format.cache.hasOwnProperty(arguments[0])) {
				str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
			}
			return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
		};
	
		// convert object to simple one line string without indentation or
		// newlines. Note that this implementation does not print array
		// values to their actual place for sparse arrays. 
		//
		// For example sparse array like this
		//    l = []
		//    l[4] = 1
		// Would be printed as "[1]" instead of "[, , , , 1]"
		// 
		// If argument 'seen' is not null and array the function will check for 
		// circular object references from argument.
		str_format.object_stringify = function(obj, depth, maxdepth, seen) {
			var str = '';
			if (obj != null) {
				switch( typeof(obj) ) {
				case 'function': 
					return '[Function' + (obj.name ? ': '+obj.name : '') + ']';
				    break;
				case 'object':
					if ( obj instanceof Error) { return '[' + obj.toString() + ']' };
					if (depth >= maxdepth) return '[Object]'
					if (seen) {
						// add object to seen list
						seen = seen.slice(0)
						seen.push(obj);
					}
					if (obj.length != null) { //array
						str += '[';
						var arr = []
						for (var i in obj) {
							if (seen && seen.indexOf(obj[i]) >= 0) arr.push('[Circular]');
							else arr.push(str_format.object_stringify(obj[i], depth+1, maxdepth, seen));
						}
						str += arr.join(', ') + ']';
					} else if ('getMonth' in obj) { // date
						return 'Date(' + obj + ')';
					} else { // object
						str += '{';
						var arr = []
						for (var k in obj) { 
							if(obj.hasOwnProperty(k)) {
								if (seen && seen.indexOf(obj[k]) >= 0) arr.push(k + ': [Circular]');
								else arr.push(k +': ' +str_format.object_stringify(obj[k], depth+1, maxdepth, seen)); 
							}
						}
						str += arr.join(', ') + '}';
					}
					return str;
					break;
				case 'string':				
					return '"' + obj + '"';
					break
				}
			}
			return '' + obj;
		}
	
		str_format.format = function(parse_tree, argv) {
			var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
			for (i = 0; i < tree_length; i++) {
				node_type = get_type(parse_tree[i]);
				if (node_type === 'string') {
					output.push(parse_tree[i]);
				}
				else if (node_type === 'array') {
					match = parse_tree[i]; // convenience purposes only
					if (match[2]) { // keyword argument
						arg = argv[cursor];
						for (k = 0; k < match[2].length; k++) {
							if (!arg.hasOwnProperty(match[2][k])) {
								throw new Error(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
							}
							arg = arg[match[2][k]];
						}
					}
					else if (match[1]) { // positional argument (explicit)
						arg = argv[match[1]];
					}
					else { // positional argument (implicit)
						arg = argv[cursor++];
					}
	
					if (/[^sO]/.test(match[8]) && (get_type(arg) != 'number')) {
						throw new Error(sprintf('[sprintf] expecting number but found %s "' + arg + '"', get_type(arg)));
					}
					switch (match[8]) {
						case 'b': arg = arg.toString(2); break;
						case 'c': arg = String.fromCharCode(arg); break;
						case 'd': arg = parseInt(arg, 10); break;
						case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
						case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
					    case 'O': arg = str_format.object_stringify(arg, 0, parseInt(match[7]) || 5); break;
						case 'o': arg = arg.toString(8); break;
						case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
						case 'u': arg = Math.abs(arg); break;
						case 'x': arg = arg.toString(16); break;
						case 'X': arg = arg.toString(16).toUpperCase(); break;
					}
					arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
					pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
					pad_length = match[6] - String(arg).length;
					pad = match[6] ? str_repeat(pad_character, pad_length) : '';
					output.push(match[5] ? arg + pad : pad + arg);
				}
			}
			return output.join('');
		};
	
		str_format.cache = {};
	
		str_format.parse = function(fmt) {
			var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
			while (_fmt) {
				if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
					parse_tree.push(match[0]);
				}
				else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
					parse_tree.push('%');
				}
				else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosOuxX])/.exec(_fmt)) !== null) {
					if (match[2]) {
						arg_names |= 1;
						var field_list = [], replacement_field = match[2], field_match = [];
						if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
							field_list.push(field_match[1]);
							while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
								if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
									field_list.push(field_match[1]);
								}
								else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
									field_list.push(field_match[1]);
								}
								else {
									throw new Error('[sprintf] ' + replacement_field);
								}
							}
						}
						else {
	                        throw new Error('[sprintf] ' + replacement_field);
						}
						match[2] = field_list;
					}
					else {
						arg_names |= 2;
					}
					if (arg_names === 3) {
						throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');
					}
					parse_tree.push(match);
				}
				else {
					throw new Error('[sprintf] ' + _fmt);
				}
				_fmt = _fmt.substring(match[0].length);
			}
			return parse_tree;
		};
	
		return str_format;
	})();
	
	var vsprintf = function(fmt, argv) {
		var argvClone = argv.slice();
		argvClone.unshift(fmt);
		return sprintf.apply(null, argvClone);
	};
	
	module.exports = sprintf;
	sprintf.sprintf = sprintf;
	sprintf.vsprintf = vsprintf;


/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SolidList = SolidList;
	
	var _utils = __webpack_require__(333);
	
	var _bind = __webpack_require__(394);
	
	function SolidList(app) {
	  var _this = this;
	
	  this.app = app;
	  app.bus.subscribe('solid-list', function (data) {
	    return _this.onChange(data);
	  });
	  this.dom = $((0, _utils.LoadTemplate)('solid-list')({}));
	  (0, _bind.BindArray)(this.dom, []);
	}
	
	SolidList.prototype.onChange = function (data) {
	  var _this2 = this;
	
	  var domData = data.solids.map(function (s) {
	    return { id: s.id };
	  });
	  domData.forEach(function (s) {
	    var toRefresh = data.needRefresh.find(function (nr) {
	      return nr.id == s.id;
	    });
	    if (toRefresh) {
	      Object.assign(s, _this2.getFullInfo(toRefresh));
	    }
	  });
	  (0, _bind.BindArray)(this.dom, domData);
	};
	
	SolidList.prototype.getFullInfo = function (solid) {
	  return {
	    id: solid.id,
	    type: solid.tCadType,
	    sketches: this.app.findSketches(solid).map(function (id) {
	      return { id: id };
	    })
	  };
	};

/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ModificationsPanel = ModificationsPanel;
	
	var _utils = __webpack_require__(333);
	
	var _bind = __webpack_require__(394);
	
	var _operations = __webpack_require__(358);
	
	var Operations = _interopRequireWildcard(_operations);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function ModificationsPanel(app) {
	  var _this = this;
	
	  this.app = app;
	  this.dom = $((0, _utils.LoadTemplate)('modifications')({}));
	  this.buttonsBlock = this.dom.find(".tc-buttons-block");
	  var buttons = this.buttonsBlock.find(".tc-block-btn");
	  buttons.eq(0).click(function () {
	    return app.craft.finishHistoryEditing();
	  });
	  this.buttonsBlock.hide();
	  this.historyWizard = null;
	
	  this.app.bus.subscribe("craft", function () {
	    _this.updateList();
	    _this.updateHistoryPointer();
	  });
	
	  this.app.bus.subscribe("historyShrink", function () {
	    _this.updateList();
	  });
	
	  this.app.bus.subscribe("refreshSketch", function () {
	    if (_this.historyWizard != null) {
	      var craft = _this.app.craft;
	      var op = JSON.parse(JSON.stringify(craft.history[craft.historyPointer]));
	      op.protoParams = _this.historyWizard.getParams();
	      _this.historyWizard.dispose();
	      _this.historyWizard = _this.app.ui.createWizardForOperation(op, app);
	    }
	  });
	
	  (0, _bind.Bind)(this.dom, {});
	}
	
	ModificationsPanel.prototype.updateList = function () {
	  var _this2 = this;
	
	  var modifications = [];
	
	  var _loop = function _loop(i) {
	    var op = _this2.app.craft.history[i];
	    var m = {
	      id: i,
	      info: _this2.app.ui.getInfoForOp(op),
	      OnBind: function OnBind(dom, data) {
	        var icon = getIconForOp(op);
	        if (icon) {
	          dom.css('background-image', 'url(' + icon + ')');
	        }
	        if (!op.face) {
	          dom.find('.require-face').addClass('action-disabled');
	        }
	      }
	    };
	    modifications.push(m);
	  };
	
	  for (var i = 0; i < this.app.craft.history.length; i++) {
	    _loop(i);
	  }
	  (0, _bind.Bind)(this.dom, { modifications: modifications });
	};
	
	ModificationsPanel.prototype.updateHistoryPointer = function () {
	  if (this.historyWizard != null) {
	    this.historyWizard.dispose();
	    this.historyWizard = null;
	  }
	  var modificationRows = this.dom.find('.modification-item');
	  modificationRows.removeClass('history-selected');
	
	  var craft = this.app.craft;
	  var historyEditMode = craft.historyPointer != craft.history.length;
	  if (historyEditMode) {
	    modificationRows.eq(craft.historyPointer).addClass('history-selected');
	    var op = craft.history[craft.historyPointer];
	    this.historyWizard = this.app.ui.createWizardForOperation(op);
	    this.buttonsBlock.show();
	  } else {
	    this.buttonsBlock.hide();
	  }
	};
	
	function getIconForOp(op) {
	  var opDef = Operations[op.type];
	  if (!opDef || !opDef.icon) {
	    return null;
	  }
	  return opDef.icon + '32.png';
	}

/***/ },
/* 398 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = TabSwitcher;
	function TabSwitcher(tabBar, defaultView) {
	  var _this = this;
	
	  this.tabBar = tabBar;
	  var defaultTab = $('<div>', {
	    'class': 'tab',
	    text: '3D View'
	  });
	  this.defaultViewHandle = new ViewHandle(defaultView, defaultTab);
	  defaultTab.click(function () {
	    _this.defaultViewHandle.show(_this);
	  });
	  this.tabBar.append(defaultTab);
	  this.markSelected(defaultTab);
	
	  this.detachedViews = {};
	}
	
	function idToName(id) {
	  var match = /\$+$/.exec(id);
	  if (match == null) return id;
	  var beenCraftedTimes = match[0].length;
	  function to27Base(n) {
	    if (n == 0) return "";
	    var rad = n % 27;
	    return to27Base(Math.floor(n / 27)) + String.fromCharCode(65 + rad);
	  }
	  return id.replace(/\$+$/, '') + to27Base(beenCraftedTimes);
	}
	
	TabSwitcher.prototype.showSketch = function (sketchURL, sketchId) {
	  var _this2 = this;
	
	  var tab = this.tabBar.find('[data-sketch-id="' + sketchId + '"]');
	  var detachedView = this.detachedViews[sketchId];
	  if (detachedView !== undefined) {
	    if (!detachedView.closed) {
	      detachedView.focus();
	      return;
	    } else {
	      delete this.detachedViews[sketchId];
	    }
	  }
	  if (tab.length == 0) {
	    tab = $('<div>', { 'class': 'tab', text: 'Sketch ' + idToName(sketchId) }).append(' ').append($('<i>', { 'class': 'fa fa-expand expand' })).append(' ').append($('<i>', { 'class': 'fa fa-close close' }));
	    tab.attr('data-sketch-id', sketchId);
	    var url = "sketcher.html#" + sketchURL;
	
	    var view = $('<div>', { 'class': 'app-tab-view' }).append($('<iframe>', { css: {
	        width: '100%', height: '100%'
	      } }));
	    view.insertAfter($('.app-tab-view').last());
	    view.find('iframe').attr('src', url);
	    var viewHandle = new ViewHandle(view, tab);
	    tab.on('click', function () {
	      return viewHandle.show(_this2);
	    });
	    this.tabBar.append(tab);
	    var close = function close() {
	      view.remove();
	      tab.remove();
	      _this2.defaultViewHandle.show(_this2);
	    };
	    tab.find('.expand').click(function () {
	      close();
	      _this2.detachedViews[sketchId] = window.open(url, sketchId, "height=900,width=1200");
	    });
	    tab.find('.close').click(close);
	  }
	  tab.click();
	};
	
	TabSwitcher.prototype.markSelected = function (tab) {
	  this.tabBar.find('.tab').removeClass('tab-selected');
	  tab.addClass('tab-selected');
	};
	
	function ViewHandle(view, tab) {
	  this.view = view;
	  this.tab = tab;
	}
	
	ViewHandle.prototype.show = function (tabSwitcher) {
	  tabSwitcher.markSelected(this.tab);
	  $('.app-tab-view').not(this.view).hide();
	  this.view.show();
	};

/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ControlBar;
	
	var _utils = __webpack_require__(333);
	
	function ControlBar(app, bar) {
	  this.app = app;
	  this.bar = bar;
	}
	
	ControlBar.prototype.add = function (actionName, left, overrides) {
	  var action = this.app.actionManager.actions[actionName];
	  if (action == undefined) return;
	  if (overrides != undefined) {
	    action = Object.assign({}, action, overrides);
	  }
	  var btn = $('<div>', { 'class': 'button' });
	  if (action.cssIcons != undefined) {
	    btn.append($('<i>', { 'class': 'fa ' + (0, _utils.cssIconsToClasses)(action.cssIcons) }));
	  }
	  if (action.label != undefined && action.label != null) {
	    if (action.cssIcons != undefined) {
	      btn.append(' ');
	    }
	    btn.append(action.label);
	  }
	  var to = this.bar.find(left ? '.left-group' : '.right-group');
	  to.append(btn);
	  if (action.type == 'binary') {
	    this.app.bus.subscribe(action.property, function (show) {
	      btn.removeClass('button-selected');
	      if (show) {
	        btn.addClass('button-selected');
	      }
	    })(this.app.state[action.property]);
	  } else if (action.type == 'menu') {
	    btn.data('menuOrientation', 'up');
	  }
	  btn.addClass('action-item');
	  btn.data('action', actionName);
	  return btn;
	};

/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.InputManager = InputManager;
	
	var _jwerty = __webpack_require__(401);
	
	var _default = __webpack_require__(402);
	
	var _bind = __webpack_require__(394);
	
	var _messageSink = __webpack_require__(403);
	
	var _utils = __webpack_require__(333);
	
	function InputManager(app) {
	  var _this = this;
	
	  this.app = app;
	  this.openMenus = [];
	  this.keymap = _default.keymap;
	  this.mouseInfo = new _utils.DefaultMouseEvent();
	  this.requestedActionInfo = null;
	  this.actionInfoDom = $((0, _utils.LoadTemplate)('action-info')({}));
	  this.messageSink = new _messageSink.MessageSink(this);
	  this.context = null;
	  $(function () {
	    $(document).on('keydown', function (e) {
	      return _this.handleKeyPress(e);
	    }).on('mousedown', function (e) {
	      return _this.clear(e);
	    }).on('click', '.context-click', function (e) {
	      return _this.context = $(e.currentTarget);
	    }).on('mouseenter', '.context-hover', function (e) {
	      return _this.context = $(e.currentTarget);
	    }).on('mouseleave', '.context-hover', function (e) {
	      return _this.context = null;
	    }).on('mouseenter', '.action-item', function (e) {
	      return _this.showActionInfo($(e.currentTarget));
	    }).on('mouseleave', '.action-item', function (e) {
	      return _this.hideActionInfo();
	    }).on('mousemove', function (e) {
	      return _this.mouseInfo = e;
	    }).on('click', '.action-item', function (e) {
	      return _this.handleActionClick(e);
	    }).on('contextmenu', '.action-item', function (e) {
	      return _this.handleRightClick(e);
	    });
	  });
	}
	
	InputManager.prototype.handleKeyPress = function (e) {
	  var _this2 = this;
	
	  switch (e.keyCode) {
	    case 27:
	      this.clear();break;
	  }
	
	  var _loop = function _loop(action) {
	    if (_jwerty.jwerty.is(_this2.keymap[action], e)) {
	      setTimeout(function () {
	        return _this2.app.actionManager.run(action, e);
	      }, 0);
	      return 'break';
	    }
	  };
	
	  for (var action in this.keymap) {
	    var _ret = _loop(action);
	
	    if (_ret === 'break') break;
	  }
	};
	
	InputManager.prototype.clear = function (e) {
	  if (e != undefined && $(e.target).closest('.menu-item').length != 0) {
	    return;
	  }
	  this.clearMenus();
	  this.requestedActionInfo = null;
	  this.messageSink.hide();
	};
	
	InputManager.prototype.clearMenus = function () {
	  if (this.openMenus.length != 0) {
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = this.openMenus[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var openMenu = _step.value;
	
	        openMenu.node.hide();
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	
	    this.openMenus = [];
	  }
	};
	
	InputManager.prototype.handleRightClick = function (e) {
	  if ($(event.currentTarget).hasClass('.right-click-action')) {
	    e.preventDefault();
	    this.handleActionClick(e);
	    return false;
	  }
	  return true;
	};
	
	InputManager.prototype.handleActionClick = function (event) {
	  this.mouseInfo = event;
	  var target = $(event.currentTarget);
	  var action = target.data('action');
	  if (action != undefined) {
	    this.clear();
	    _utils.EventData.set(event, 'initiator', target);
	    this.app.actionManager.run(action, event);
	    event.stopPropagation();
	  }
	};
	
	InputManager.prototype.registerOpenMenu = function (menu) {
	  (0, _utils.fit)(menu.node, $('body'));
	  this.openMenus.push(menu);
	};
	
	InputManager.prototype.hideActionInfo = function () {
	  this.requestedActionInfo = null;
	  this.messageSink.hide();
	};
	
	InputManager.prototype.showActionInfo = function (el) {
	  var action = el.data('action');
	  if (action) {
	    this.requestInfo(action);
	  }
	};
	
	InputManager.prototype.requestInfo = function (actionRequest) {
	  var _this3 = this;
	
	  if (this.requestedActionInfo == actionRequest) {
	    return;
	  }
	  this.requestedActionInfo = actionRequest;
	  setTimeout(function () {
	    var actionId = _this3.requestedActionInfo;
	    _this3.requestedActionInfo = null;
	    if (actionId != null) {
	      var action = _this3.app.actionManager.actions[actionId];
	      var hotKey = _this3.keymap[actionId];
	      if (action && (action.state.hint || action.info || hotKey)) {
	        (0, _bind.Bind)(_this3.actionInfoDom, {
	          hint: action.state.hint,
	          info: action.info,
	          hotKey: hotKey
	        });
	        _this3.messageSink.showContent(_this3.actionInfoDom);
	      }
	    }
	  }, 500);
	};

/***/ },
/* 401 */
/***/ function(module, exports) {

	/*
	 * jwerty - Awesome handling of keyboard events
	 *
	 * jwerty is a JS lib which allows you to bind, fire and assert key combination
	 * strings against elements and events. It normalises the poor std api into
	 * something easy to use and clear.
	 *
	 * This code is licensed under the MIT
	 * For the full license see: http://keithamus.mit-license.org/
	 * For more information see: http://keithamus.github.com/jwerty
	 *
	 * @author Keith Cirkel ('keithamus') <jwerty@keithcirkel.co.uk>
	 * @license http://keithamus.mit-license.org/
	 * @copyright Copyright  2011, Keith Cirkel
	 *
	 */
	(function (global, exports) {
	    
	    // Helper methods & vars:
	    var $d = global.document
	    ,   $ = (global.jQuery || global.Zepto || global.ender || $d)
	    ,   $$
	    ,   $b
	    ,   ke = 'keydown';
	    
	    function realTypeOf(v, s) {
	        return (v === null) ? s === 'null'
	        : (v === undefined) ? s === 'undefined'
	        : (v.is && v instanceof $) ? s === 'element'
	        : Object.prototype.toString.call(v).toLowerCase().indexOf(s) > 7;
	    }
	    
	    if ($ === $d) {
	        $$ = function (selector, context) {
	            return selector ? $.querySelector(selector, context || $) : $;
	        };
	        
	        $b = function (e, fn) { e.addEventListener(ke, fn, false); };
	        $f = function (e, jwertyEv) {
	            var ret = document.createEvent('Event')
	            ,   i;
	            
	            ret.initEvent(ke, true, true);
	            
	            for (i in jwertyEv) ret[i] = jwertyEv[i];
	            
	            return (e || $).dispatchEvent(ret);
	        }
	    } else {
	        $$ = function (selector, context, fn) { return $(selector || $d, context); };
	        $b = function (e, fn) { $(e).bind(ke + '.jwerty', fn); };
	        $f = function (e, ob) { $(e || $d).trigger($.Event(ke, ob)); };
	    }
	    
	    // Private
	    var _modProps = { 16: 'shiftKey', 17: 'ctrlKey', 18: 'altKey', 91: 'metaKey' };
	    
	    // Generate key mappings for common keys that are not printable.
	    var _keys = {
	        
	        // MOD aka toggleable keys
	        mods: {
	            // Shift key, 
	            '': 16, shift: 16,
	            // CTRL key, on Mac: 
	            '': 17, ctrl: 17,
	            // ALT key, on Mac:  (Alt)
	            '': 18, alt: 18, option: 18,
	            // META, on Mac:  (CMD), on Windows (Win), on Linux (Super)
	            '': 91, meta: 91, cmd: 91, 'super': 91, win: 91
	        },
	        
	        // Normal keys
	        keys: {
	            // Backspace key, on Mac:  (Backspace)
	            '': 8, backspace: 8,
	            // Tab Key, on Mac:  (Tab), on Windows 
	            '': 9, '': 9, tab: 9,
	            // Return key, 
	            '': 13, 'return': 13, enter: 13, '': 13,
	            // Pause/Break key
	            'pause': 19, 'pause-break': 19,
	            // Caps Lock key, 
	            '': 20, caps: 20, 'caps-lock': 20,
	            // Escape key, on Mac: , on Windows: Esc
	            '': 27, escape: 27, esc: 27,
	            // Space key
	            space: 32,
	            // Page-Up key, or pgup, on Mac: 
	            '': 33, pgup: 33, 'page-up': 33,
	            // Page-Down key, or pgdown, on Mac: 
	            '': 34, pgdown: 34, 'page-down': 34,
	            // END key, on Mac: 
	            '': 35, end: 35,
	            // HOME key, on Mac: 
	            '': 36, home: 36,
	            // Insert key, or ins
	            ins: 45, insert: 45,
	            // Delete key, on Mac:  (Delete)
	            del: 46, 'delete': 46,
	            
	            // Left Arrow Key, or 
	            '': 37, left: 37, 'arrow-left': 37,
	            // Up Arrow Key, or 
	            '': 38, up: 38, 'arrow-up': 38,
	            // Right Arrow Key, or 
	            '': 39, right: 39, 'arrow-right': 39,
	            // Up Arrow Key, or 
	            '': 40, down: 40, 'arrow-down': 40,
	            
	            // odities, printing characters that come out wrong:
	            // Num-Multiply, or *
	            '*': 106, star: 106, asterisk: 106, multiply: 106,
	            // Num-Plus or +
	            '+': 107, 'plus': 107,
	            // Num-Subtract, or -
	            '-': 109, subtract: 109,
	            // Semicolon
	            ';': 186, semicolon:186,
	            // = or equals
	            '=': 187, 'equals': 187,
	            // Comma, or ,
	            ',': 188, comma: 188,
	            //'-': 189, //???
	            // Period, or ., or full-stop
	            '.': 190, period: 190, 'full-stop': 190,
	            // Slash, or /, or forward-slash
	            '/': 191, slash: 191, 'forward-slash': 191,
	            // Tick, or `, or back-quote 
	            '`': 192, tick: 192, 'back-quote': 192,
	            // Open bracket, or [
	            '[': 219, 'open-bracket': 219,
	            // Back slash, or \
	            '\\': 220, 'back-slash': 220,
	            // Close backet, or ]
	            ']': 221, 'close-bracket': 221,
	            // Apostraphe, or Quote, or '
	            '\'': 222, quote: 222, apostraphe: 222
	        }
	        
	    };
	    
	    // To minimise code bloat, add all of the NUMPAD 0-9 keys in a loop
	    i = 95, n = 0;
	    while(++i < 106) {
	        _keys.keys['num-' + n] = i;
	        ++n;
	    }
	    
	    // To minimise code bloat, add all of the top row 0-9 keys in a loop
	    i = 47, n = 0;
	    while(++i < 58) {
	        _keys.keys[n] = i;
	        ++n;
	    }
	    
	    // To minimise code bloat, add all of the F1-F25 keys in a loop
	    i = 111, n = 1;
	    while(++i < 136) {
	        _keys.keys['f' + n] = i;
	        ++n;
	    }
	    
	    // To minimise code bloat, add all of the letters of the alphabet in a loop
	    var i = 64;
	    while(++i < 91) {
	        _keys.keys[String.fromCharCode(i).toLowerCase()] = i;
	    }
	    
	    function JwertyCode(jwertyCode) {
	        var i
	        ,   c
	        ,   n
	        ,   z
	        ,   keyCombo
	        ,   optionals
	        ,   jwertyCodeFragment
	        ,   rangeMatches
	        ,   rangeI;
	        
	        // In-case we get called with an instance of ourselves, just return that.
	        if (jwertyCode instanceof JwertyCode) return jwertyCode;
	        
	        // If jwertyCode isn't an array, cast it as a string and split into array.
	        if (!realTypeOf(jwertyCode, 'array')) {
	            jwertyCode = (String(jwertyCode)).replace(/\s/g, '').toLowerCase().
	                match(/(?:\+,|[^,])+/g);
	        }
	        
	        // Loop through each key sequence in jwertyCode
	        for (i = 0, c = jwertyCode.length; i < c; ++i) {
	            
	            // If the key combo at this part of the sequence isn't an array,
	            // cast as a string and split into an array.
	            if (!realTypeOf(jwertyCode[i], 'array')) {
	                jwertyCode[i] = String(jwertyCode[i])
	                    .match(/(?:\+\/|[^\/])+/g);
	            }
	            
	            // Parse the key optionals in this sequence
	            optionals = [], n = jwertyCode[i].length;
	            while (n--) {
	                
	                // Begin creating the object for this key combo
	                var jwertyCodeFragment = jwertyCode[i][n];
	                
	                keyCombo = {
	                    jwertyCombo: String(jwertyCodeFragment),
	                    shiftKey: false,
	                    ctrlKey: false,
	                    altKey: false,
	                    metaKey: false
	                }
	                
	                // If jwertyCodeFragment isn't an array then cast as a string
	                // and split it into one.
	                if (!realTypeOf(jwertyCodeFragment, 'array')) {
	                    jwertyCodeFragment = String(jwertyCodeFragment).toLowerCase()
	                        .match(/(?:(?:[^\+])+|\+\+|^\+$)/g);
	                }
	                
	                z = jwertyCodeFragment.length;
	                while (z--) {
	                    
	                    // Normalise matching errors
	                    if (jwertyCodeFragment[z] === '++') jwertyCodeFragment[z] = '+';
	                    
	                    // Inject either keyCode or ctrl/meta/shift/altKey into keyCombo
	                    if (jwertyCodeFragment[z] in _keys.mods) {
	                        keyCombo[_modProps[_keys.mods[jwertyCodeFragment[z]]]] = true;
	                    } else if(jwertyCodeFragment[z] in _keys.keys) {
	                        keyCombo.keyCode = _keys.keys[jwertyCodeFragment[z]];
	                    } else {
	                        rangeMatches = jwertyCodeFragment[z].match(/^\[([^-]+\-?[^-]*)-([^-]+\-?[^-]*)\]$/);
	                    }
	                }
	                if (realTypeOf(keyCombo.keyCode, 'undefined')) {
	                    // If we picked up a range match earlier...
	                    if (rangeMatches && (rangeMatches[1] in _keys.keys) && (rangeMatches[2] in _keys.keys)) {
	                        rangeMatches[2] = _keys.keys[rangeMatches[2]];
	                        rangeMatches[1] = _keys.keys[rangeMatches[1]];
	                        
	                        // Go from match 1 and capture all key-comobs up to match 2
	                        for (rangeI = rangeMatches[1]; rangeI < rangeMatches[2]; ++rangeI) {
	                            optionals.push({
	                                altKey: keyCombo.altKey,
	                                shiftKey: keyCombo.shiftKey,
	                                metaKey: keyCombo.metaKey,
	                                ctrlKey: keyCombo.ctrlKey,
	                                keyCode: rangeI,
	                                jwertyCombo: String(jwertyCodeFragment)
	                            });
	                            
	                        }
	                        keyCombo.keyCode = rangeI;
	                    // Inject either keyCode or ctrl/meta/shift/altKey into keyCombo
	                    } else {
	                        keyCombo.keyCode = 0;
	                    }
	                }
	                optionals.push(keyCombo);
	            
	            }
	            this[i] = optionals;
	        }
	        this.length = i;
	        return this;
	    }
	    
	    var jwerty = exports.jwerty = {        
	        /**
	         * jwerty.event
	         *
	         * `jwerty.event` will return a function, which expects the first
	         *  argument to be a key event. When the key event matches `jwertyCode`,
	         *  `callbackFunction` is fired. `jwerty.event` is used by `jwerty.key`
	         *  to bind the function it returns. `jwerty.event` is useful for
	         *  attaching to your own event listeners. It can be used as a decorator
	         *  method to encapsulate functionality that you only want to fire after
	         *  a specific key combo. If `callbackContext` is specified then it will
	         *  be supplied as `callbackFunction`'s context - in other words, the
	         *  keyword `this` will be set to `callbackContext` inside the
	         *  `callbackFunction` function.
	         *
	         *   @param {Mixed} jwertyCode can be an array, or string of key
	         *      combinations, which includes optinals and or sequences
	         *   @param {Function} callbackFucntion is a function (or boolean) which
	         *      is fired when jwertyCode is matched. Return false to
	         *      preventDefault()
	         *   @param {Object} callbackContext (Optional) The context to call
	         *      `callback` with (i.e this)
	         *      
	         */
	        event: function (jwertyCode, callbackFunction, callbackContext /*? this */) {
	            
	            // Construct a function out of callbackFunction, if it is a boolean.
	            if (realTypeOf(callbackFunction, 'boolean')) {
	                var bool = callbackFunction;
	                callbackFunction = function () { return bool; }
	            }
	            
	            jwertyCode = new JwertyCode(jwertyCode);
	            
	            // Initialise in-scope vars.
	            var i = 0
	            ,   c = jwertyCode.length - 1
	            ,   returnValue
	            ,   jwertyCodeIs;
	            
	            // This is the event listener function that gets returned...
	            return function (event) {
	                
	                // if jwertyCodeIs returns truthy (string)...
	                if ((jwertyCodeIs = jwerty.is(jwertyCode, event, i))) {
	                    // ... and this isn't the last key in the sequence,
	                    // incriment the key in sequence to check.
	                    if (i < c) {
	                        ++i;
	                        return;
	                    // ... and this is the last in the sequence (or the only
	                    // one in sequence), then fire the callback
	                    } else {
	                        returnValue = callbackFunction.call(
	                            callbackContext || this, event, jwertyCodeIs);
	                        
	                        // If the callback returned false, then we should run
	                        // preventDefault();
	                        if (returnValue === false) event.preventDefault();
	                        
	                        // Reset i for the next sequence to fire.
	                        i = 0;
	                        return;
	                    }
	                }
	                
	                // If the event didn't hit this time, we should reset i to 0,
	                // that is, unless this combo was the first in the sequence,
	                // in which case we should reset i to 1.
	                i = jwerty.is(jwertyCode, event) ? 1 : 0;
	            }
	        },
	        
	        /**
	         * jwerty.is
	         *
	         * `jwerty.is` will return a boolean value, based on if `event` matches
	         *  `jwertyCode`. `jwerty.is` is called by `jwerty.event` to check
	         *  whether or not to fire the callback. `event` can be a DOM event, or
	         *  a jQuery/Zepto/Ender manufactured event. The properties of
	         *  `jwertyCode` (speficially ctrlKey, altKey, metaKey, shiftKey and
	         *  keyCode) should match `jwertyCode`'s properties - if they do, then
	         *  `jwerty.is` will return `true`. If they don't, `jwerty.is` will
	         *  return `false`.
	         *
	         *   @param {Mixed} jwertyCode can be an array, or string of key
	         *      combinations, which includes optinals and or sequences
	         *   @param {KeyboardEvent} event is the KeyboardEvent to assert against
	         *   @param {Integer} i (Optional) checks the `i` key in jwertyCode
	         *      sequence
	         *      
	         */
	        is: function (jwertyCode, event, i /*? 0*/) {
	            jwertyCode = new JwertyCode(jwertyCode);
	            // Default `i` to 0
	            i = i || 0;
	            // We are only interesting in `i` of jwertyCode;
	            jwertyCode = jwertyCode[i];
	            // jQuery stores the *real* event in `originalEvent`, which we use
	            // because it does annoything stuff to `metaKey`
	            event = event.originalEvent || event;
	            
	            // We'll look at each optional in this jwertyCode sequence...
	            var key
	            ,   n = jwertyCode.length
	            ,   returnValue = false;
	            
	            // Loop through each fragment of jwertyCode
	            while (n--) {
	                returnValue = jwertyCode[n].jwertyCombo;
	                // For each property in the jwertyCode object, compare to `event`
	                for (var p in jwertyCode[n]) {
	                    // ...except for jwertyCode.jwertyCombo...
	                    if (p !== 'jwertyCombo' && event[p] != jwertyCode[n][p]) returnValue = false;
	                }
	                // If this jwertyCode optional wasn't falsey, then we can return early.
	                if (returnValue !== false) return returnValue;
	            }
	            return returnValue;
	        },
	        
	        /**
	         * jwerty.key
	         *
	         *  `jwerty.key` will attach an event listener and fire
	         *   `callbackFunction` when `jwertyCode` matches. The event listener is
	         *   attached to `document`, meaning it will listen for any key events
	         *   on the page (a global shortcut listener). If `callbackContext` is
	         *   specified then it will be supplied as `callbackFunction`'s context
	         *   - in other words, the keyword `this` will be set to
	         *   `callbackContext` inside the `callbackFunction` function.
	         *
	         *   @param {Mixed} jwertyCode can be an array, or string of key
	         *      combinations, which includes optinals and or sequences
	         *   @param {Function} callbackFunction is a function (or boolean) which
	         *      is fired when jwertyCode is matched. Return false to
	         *      preventDefault()
	         *   @param {Object} callbackContext (Optional) The context to call
	         *      `callback` with (i.e this)
	         *   @param {Mixed} selector can be a string, jQuery/Zepto/Ender object,
	         *      or an HTML*Element on which to bind the eventListener
	         *   @param {Mixed} selectorContext can be a string, jQuery/Zepto/Ender
	         *      object, or an HTML*Element on which to scope the selector
	         *  
	         */
	        key: function (jwertyCode, callbackFunction, callbackContext /*? this */, selector /*? document */, selectorContext /*? body */) {
	            // Because callbackContext is optional, we should check if the
	            // `callbackContext` is a string or element, and if it is, then the
	            // function was called without a context, and `callbackContext` is
	            // actually `selector`
	            var realSelector = realTypeOf(callbackContext, 'element') || realTypeOf(callbackContext, 'string') ? callbackContext : selector
	            // If `callbackContext` is undefined, or if we skipped it (and
	            // therefore it is `realSelector`), set context to `global`.
	            ,   realcallbackContext = realSelector === callbackContext ? global : callbackContext
	            // Finally if we did skip `callbackContext`, then shift
	            // `selectorContext` to the left (take it from `selector`)
	            ,    realSelectorContext = realSelector === callbackContext ? selector : selectorContext;
	            
	            // If `realSelector` is already a jQuery/Zepto/Ender/DOM element,
	            // then just use it neat, otherwise find it in DOM using $$()
	            $b(realTypeOf(realSelector, 'element') ?
	               realSelector : $$(realSelector, realSelectorContext)
	            , jwerty.event(jwertyCode, callbackFunction, realcallbackContext));
	        },
	        
	        /**
	         * jwerty.fire
	         *
	         * `jwerty.fire` will construct a keyup event to fire, based on
	         *  `jwertyCode`. The event will be fired against `selector`.
	         *  `selectorContext` is used to search for `selector` within
	         *  `selectorContext`, similar to jQuery's
	         *  `$('selector', 'context')`.
	         *
	         *   @param {Mixed} jwertyCode can be an array, or string of key
	         *      combinations, which includes optinals and or sequences
	         *   @param {Mixed} selector can be a string, jQuery/Zepto/Ender object,
	         *      or an HTML*Element on which to bind the eventListener
	         *   @param {Mixed} selectorContext can be a string, jQuery/Zepto/Ender
	         *      object, or an HTML*Element on which to scope the selector
	         *  
	         */
	        fire: function (jwertyCode, selector /*? document */, selectorContext /*? body */, i) {
	            jwertyCode = new JwertyCode(jwertyCode);
	            var realI = realTypeOf(selectorContext, 'number') ? selectorContext : i;
	            
	            // If `realSelector` is already a jQuery/Zepto/Ender/DOM element,
	            // then just use it neat, otherwise find it in DOM using $$()
	            $f(realTypeOf(selector, 'element') ?
	                selector : $$(selector, selectorContext)
	            , jwertyCode[realI || 0][0]);
	        },
	        
	        KEYS: _keys
	    };
	    
	}(this, (typeof module !== 'undefined' && module.exports ? module.exports : this)));

/***/ },
/* 402 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var keymap = exports.keymap = {
	
	  'CUT': 'C',
	  'EXTRUDE': 'E',
	  'ZoomIn': '+',
	  'ZoomOut': '-',
	  'menu.craft': 'shift+C',
	  'menu.primitives': 'shift+A',
	  'menu.main': 'space',
	  'Save': 'ctrl+S',
	  'Info': 'F1'
	};

/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.MessageSink = MessageSink;
	
	var _utils = __webpack_require__(333);
	
	function MessageSink(inputManager) {
	  this.inputManager = inputManager;
	  this.node = $('<div>', { 'class': 'message-sink' });
	  $('body').append(this.node);
	}
	
	MessageSink.prototype.show = function () {
	  this.node.show();
	  this.node.offset({ left: this.inputManager.mouseInfo.pageX + 10, top: this.inputManager.mouseInfo.pageY + 10 });
	  (0, _utils.fit)(this.node, $('body'));
	};
	
	MessageSink.prototype.hide = function () {
	  this.node.hide();
	};
	
	MessageSink.prototype.showContent = function (dom) {
	  this.node.children().detach();
	  this.node.empty();
	  this.node.append(dom);
	  this.show();
	};
	
	MessageSink.prototype.info = function (text) {
	  this.node.children().detach();
	  this.node.html(text);
	  this.show();
	};

/***/ },
/* 404 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ActionManager = ActionManager;
	function ActionManager(app) {
	  this.app = app;
	  this.actions = {};
	  this.eventsToActions = {};
	  this.registerAction('-', { 'type': 'separator' });
	}
	
	ActionManager.prototype.registerAction = function (id, action) {
	  action = Object.assign({ id: id }, action);
	  action.__handler = handler(action);
	  action.state = {
	    hint: '',
	    enabled: true,
	    visible: true
	  };
	  this.addListeners(action);
	  this.actions[id] = action;
	};
	
	ActionManager.prototype.addListeners = function (action) {
	  var _this = this;
	
	  if (action.listens == undefined || action.update == undefined) return;
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    var _loop = function _loop() {
	      var event = _step.value;
	
	      var actions = _this.eventsToActions[event];
	      if (actions == undefined) {
	        actions = [];
	        _this.eventsToActions[event] = actions;
	        _this.app.bus.subscribe(event, function (data) {
	          return _this.notify(event);
	        });
	      }
	      actions.push(action);
	    };
	
	    for (var _iterator = action.listens[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      _loop();
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  this.updateAction(action);
	};
	
	ActionManager.prototype.notify = function (event) {
	  var actions = this.eventsToActions[event];
	  if (actions != undefined) {
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	      for (var _iterator2 = actions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	        var action = _step2.value;
	
	        this.updateAction(action);
	        this.app.bus.notify('action.update.' + action.id, action.state);
	      }
	    } catch (err) {
	      _didIteratorError2 = true;
	      _iteratorError2 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion2 && _iterator2.return) {
	          _iterator2.return();
	        }
	      } finally {
	        if (_didIteratorError2) {
	          throw _iteratorError2;
	        }
	      }
	    }
	  }
	};
	
	ActionManager.prototype.updateAction = function (action) {
	  action.state.hint = '';
	  action.state.enabled = true;
	  action.state.visible = true;
	  action.update(action.state, this.app);
	};
	
	ActionManager.prototype.registerActions = function (actions) {
	  for (var actionName in actions) {
	    this.registerAction(actionName, actions[actionName]);
	  }
	};
	
	ActionManager.prototype.run = function (actionId, event) {
	  var action = this.actions[actionId];
	  if (action == undefined) {
	    return;
	  }
	  if (action.state.enabled) {
	    action.__handler(this.app, event);
	  } else {
	    this.app.inputManager.messageSink.info("action '" + actionId + "' is disabled and can't be executed<br>" + action.state.hint);
	  }
	};
	
	ActionManager.prototype.subscribe = function (actionId, callback) {
	  this.app.bus.subscribe('action.update.' + actionId, callback);
	  var action = this.actions[actionId];
	  if (action) {
	    callback(action.state);
	  }
	  return callback;
	};
	
	var NOOP = function NOOP() {};
	
	function handler(action) {
	  if (action.type == 'binary') {
	    return function (app, event, source) {
	      return app.state[action.property] = !app.state[action.property];
	    };
	  } else if (action.type == 'separator') {
	    return NOOP;
	  } else if (action.type == 'menu') {
	    return function (app, event) {
	      return action.menu.show(app, event);
	    };
	  } else if (action.invoke != undefined) {
	    return function (app, event) {
	      return action.invoke(app, event);
	    };
	  } else {
	    return NOOP;
	  }
	}

/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _coreActions = __webpack_require__(406);
	
	Object.keys(_coreActions).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _coreActions[key];
	    }
	  });
	});
	
	var _operationActions = __webpack_require__(408);
	
	Object.keys(_operationActions).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _operationActions[key];
	    }
	  });
	});
	
	var _historyActions = __webpack_require__(409);
	
	Object.keys(_historyActions).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _historyActions[key];
	    }
	  });
	});

/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.noIcon = exports.LookAtSolid = exports.ShowSketches = exports.GitHub = exports.Donate = exports.Info = exports.DeselectAll = exports.RefreshSketches = exports.StlExport = exports.Save = exports.EditFace = undefined;
	
	var _actionHelpers = __webpack_require__(407);
	
	var ActionHelpers = _interopRequireWildcard(_actionHelpers);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	var EditFace = exports.EditFace = {
	  cssIcons: ['file-picture-o'],
	  label: 'sketch',
	  icon96: 'img/3d/face-edit96.png',
	  info: 'open sketcher for a face/plane',
	  listens: ['selection'],
	  update: ActionHelpers.checkForSelectedFaces(1),
	  invoke: function invoke(app) {
	    return app.editFace();
	  }
	};
	
	var Save = exports.Save = {
	  cssIcons: ['floppy-o'],
	  label: 'save',
	  info: 'save project to storage',
	  invoke: function invoke(app) {
	    return app.save();
	  }
	};
	
	var StlExport = exports.StlExport = {
	  cssIcons: ['upload', 'flip-vertical'],
	  label: 'STL Export',
	  info: 'export model to STL file',
	  invoke: function invoke(app) {
	    return app.stlExport();
	  }
	};
	
	var RefreshSketches = exports.RefreshSketches = {
	  cssIcons: ['refresh'],
	  label: 'Refresh Sketches',
	  info: 'refresh all visible sketches',
	  invoke: function invoke(app) {
	    return app.refreshSketches();
	  }
	};
	
	var DeselectAll = exports.DeselectAll = {
	  cssIcons: ['square-o'],
	  label: 'deselect all',
	  info: 'deselect everything',
	  invoke: function invoke(app) {
	    return app.viewer.selectionMgr.deselectAll();
	  }
	};
	
	var Info = exports.Info = {
	  cssIcons: ['info-circle'],
	  label: 'info',
	  info: 'opens help dialog',
	  invoke: function invoke(app) {
	    return app.showInfo();
	  }
	};
	
	var Donate = exports.Donate = {
	  cssIcons: ['paypal'],
	  label: 'donate',
	  info: 'open paypal donate page',
	  invoke: function invoke(app, e) {
	    return window.open('https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=WADW7V7CC32CY&lc=US&item_name=web%2dcad%2eorg&currency_code=USD&bn=PP%2dDonationsBF%3abtn_donate_LG%2egif%3aNonHosted', '_blank');
	  }
	};
	
	var GitHub = exports.GitHub = {
	  cssIcons: ['github'],
	  label: 'GitHub',
	  info: 'open GitHub project page',
	  invoke: function invoke(app, e) {
	    return window.open('https://github.com/xibyte/jsketcher', '_blank');
	  }
	};
	
	var ShowSketches = exports.ShowSketches = {
	  type: 'binary',
	  property: 'showSketches',
	  cssIcons: ['image'],
	  label: 'show sketches',
	  info: 'toggle whether to show sketches on a solid face'
	};
	
	var LookAtSolid = exports.LookAtSolid = {
	  cssIcons: ['crosshairs'],
	  label: 'look at solid',
	  info: 'position camera at the solid at zoom to fit it',
	  invoke: function invoke(app, e) {
	    return app.lookAtSolid(app.inputManager.context.attr('data-id'));
	  }
	};
	
	var noIcon = exports.noIcon = {
	  label: 'no icon'
	};

/***/ },
/* 407 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.checkForSelectedFaces = checkForSelectedFaces;
	exports.checkForSelectedSolids = checkForSelectedSolids;
	function checkForSelectedFaces(amount) {
	  return function (state, app) {
	    state.enabled = app.viewer.selectionMgr.selection.length >= amount;
	    if (!state.enabled) {
	      state.hint = amount == 1 ? 'requires a face to be selected' : 'requires ' + amount + ' faces to be selected';
	    }
	  };
	}
	
	function checkForSelectedSolids(amount) {
	  return function (state, app) {
	    state.enabled = app.viewer.selectionMgr.selection.length >= amount;
	    if (!state.enabled) {
	      state.hint = amount == 1 ? 'requires a solid to be selected' : 'requires ' + amount + ' solids to be selected';
	    }
	  };
	}

/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.IMPORT_STL = exports.UNION = exports.DIFFERENCE = exports.INTERSECTION = exports.SPHERE = exports.PLANE = exports.BOX = exports.SHELL = exports.REVOLVE = exports.EXTRUDE = exports.CUT = undefined;
	
	var _operations = __webpack_require__(358);
	
	var Operations = _interopRequireWildcard(_operations);
	
	var _actionHelpers = __webpack_require__(407);
	
	var ActionHelpers = _interopRequireWildcard(_actionHelpers);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function mergeInfo(opName, action) {
	  var op = Operations[opName];
	  action.label = op.label;
	  action.icon32 = op.icon + '32.png';
	  action.icon96 = op.icon + '96.png';
	  action.invoke = function (app) {
	    return app.ui.initOperation(opName);
	  };
	  return action;
	}
	
	var CUT = exports.CUT = mergeInfo('CUT', {
	  info: 'makes a cut based on 2D sketch'
	});
	
	var EXTRUDE = exports.EXTRUDE = mergeInfo('EXTRUDE', {
	  info: 'extrudes 2D sketch'
	});
	
	var REVOLVE = exports.REVOLVE = mergeInfo('REVOLVE', {
	  info: 'revolve 2D sketch'
	});
	
	var SHELL = exports.SHELL = mergeInfo('SHELL', {
	  info: 'makes shell using borders'
	});
	
	var BOX = exports.BOX = mergeInfo('BOX', {
	  info: 'creates new object box'
	});
	
	var PLANE = exports.PLANE = mergeInfo('PLANE', {
	  info: 'creates new object plane'
	});
	
	var SPHERE = exports.SPHERE = mergeInfo('SPHERE', {
	  info: 'creates new object sphere'
	});
	
	var INTERSECTION = exports.INTERSECTION = mergeInfo('INTERSECTION', {
	  info: 'intersection operation on two solids'
	});
	
	var DIFFERENCE = exports.DIFFERENCE = mergeInfo('DIFFERENCE', {
	  info: 'difference operation on two solids'
	});
	
	var UNION = exports.UNION = mergeInfo('UNION', {
	  info: 'union operation on two solids'
	});
	
	var IMPORT_STL = exports.IMPORT_STL = mergeInfo('IMPORT_STL', {
	  info: 'import stl from external location'
	});
	
	requiresFaceSelection(CUT, 1);
	requiresFaceSelection(EXTRUDE, 1);
	requiresFaceSelection(REVOLVE, 1);
	
	requiresSolidSelection(INTERSECTION, 2);
	requiresSolidSelection(DIFFERENCE, 2);
	requiresSolidSelection(UNION, 2);
	
	function requiresFaceSelection(action, amount) {
	  action.listens = ['selection'];
	  action.update = ActionHelpers.checkForSelectedFaces(amount);
	}
	
	function requiresSolidSelection(action, amount) {
	  action.listens = ['selection'];
	  action.update = ActionHelpers.checkForSelectedSolids(amount);
	}

/***/ },
/* 409 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SetHistoryPointer = exports.SetHistoryPointer = {
	  label: 'set history',
	  info: 'set history pointer to this modification item',
	  invoke: function invoke(app) {
	    var mIndex = parseInt(modificationIndex(app));
	    app.craft.historyPointer = mIndex;
	  }
	};
	
	var OpenHistoryWizard = exports.OpenHistoryWizard = {
	  label: 'edit operation',
	  info: 'open wizard to change parameters of this operation',
	  invoke: function invoke(app) {
	    var mIndex = parseInt(modificationIndex(app));
	    if (mIndex != app.craft.historyPointer) {
	      app.craft.historyPointer = mIndex;
	    } else {
	      var modification = app.craft.history[mIndex];
	      app.ui.createWizardForOperation(modification);
	    }
	  }
	};
	
	var EditOperationSketch = exports.EditOperationSketch = {
	  cssIcons: ['image'],
	  label: 'sketch',
	  info: 'edit the sketch assigned to this operation',
	  invoke: function invoke(app) {
	
	    var mIndex = parseInt(modificationIndex(app));
	    var modification = app.craft.history[mIndex];
	    if (!modification.face) {
	      return;
	    }
	    if (mIndex != app.craft.historyPointer) {
	      app.craft.historyPointer = mIndex;
	    }
	    var face = app.findFace(modification.face);
	    app.sketchFace(face);
	  }
	};
	
	var RemoveModification = exports.RemoveModification = {
	  label: 'remove modification',
	  info: 'remove this modification',
	  invoke: function invoke(app) {
	    if (!confirm("This modification and all following modifications will be removed. Continue?")) {
	      return;
	    }
	    var mIndex = parseInt(modificationIndex(app));
	    app.craft.remove(mIndex);
	  }
	};
	
	function modificationIndex(app) {
	  return app.inputManager.context.data('modification');
	}

/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Craft = Craft;
	
	var _counters = __webpack_require__(309);
	
	var _counters2 = _interopRequireDefault(_counters);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Craft(app) {
	  this.app = app;
	  this.operations = {};
	  this.history = [];
	  this.solids = [];
	  this._historyPointer = 0;
	  Object.defineProperty(this, "historyPointer", {
	    get: function get() {
	      return this._historyPointer;
	    },
	    set: function set(value) {
	      if (this._historyPointer === value) return;
	      this._historyPointer = value;
	      this.reset(this.history.slice(0, this._historyPointer));
	      this.app.bus.notify('craft');
	      this.app.bus.notify('historyPointer');
	      this.app.viewer.render();
	    }
	  });
	}
	
	Craft.prototype.registerOperation = function (name, action) {
	  this.operations[name] = action;
	};
	
	Craft.prototype.remove = function (modificationIndex) {
	  var history = this.history;
	  history.splice(modificationIndex, history.length - modificationIndex);
	
	  if (this.historyPointer >= history.length) {
	    this.finishHistoryEditing();
	  } else {
	    this.app.bus.notify('historyShrink');
	  }
	};
	
	Craft.prototype.loadHistory = function (history) {
	  this.history = history;
	  this._historyPointer = history.length;
	  this.reset(history);
	  this.app.bus.notify('craft');
	  this.app.bus.notify('historyPointer');
	  this.app.viewer.render();
	};
	
	Craft.prototype.reset = function (modifications) {
	  _counters2.default.solid = 0;
	  _counters2.default.shared = 0;
	  this.solids.forEach(function (s) {
	    s.vanish();
	  });
	  this.solids = [];
	  for (var i = 0; i < modifications.length; i++) {
	    var request = modifications[i];
	    this.modifyInternal(request);
	  }
	};
	
	Craft.prototype.finishHistoryEditing = function () {
	  this.loadHistory(this.history);
	};
	
	Craft.prototype.current = function () {
	  return this.history[this.history.length - 1];
	};
	
	Craft.prototype.modifyInternal = function (request) {
	  var op = this.operations[request.type];
	  if (!op) return;
	
	  var result = op(this.app, request.params);
	
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = result.outdated[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var solid = _step.value;
	
	      solid.vanish();
	      var idx = this.solids.indexOf(solid);
	      if (idx != -1) {
	        this.solids.splice(idx, 1);
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  var _iteratorNormalCompletion2 = true;
	  var _didIteratorError2 = false;
	  var _iteratorError2 = undefined;
	
	  try {
	    for (var _iterator2 = result.created[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	      var _solid = _step2.value;
	
	      this.solids.push(_solid);
	      this.app.viewer.workGroup.add(_solid.cadGroup);
	    }
	  } catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion2 && _iterator2.return) {
	        _iterator2.return();
	      }
	    } finally {
	      if (_didIteratorError2) {
	        throw _iteratorError2;
	      }
	    }
	  }
	
	  this.app.bus.notify('solid-list', {
	    solids: this.solids,
	    needRefresh: result.created
	  });
	};
	
	Craft.prototype.modify = function (request, overriding) {
	  this.modifyInternal(request);
	  if (!overriding && this._historyPointer != this.history.length) {
	    this.history.splice(this._historyPointer + 1, 0, null);
	  }
	  this.history[this._historyPointer] = request;
	  this._historyPointer++;
	  this.app.bus.notify('craft');
	  this.app.bus.notify('historyPointer');
	  this.app.viewer.render();
	};

/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Types = exports.BBox = exports.IO = undefined;
	
	var _idGenerator = __webpack_require__(412);
	
	var _viewer2d = __webpack_require__(413);
	
	var _styles = __webpack_require__(414);
	
	var _arc = __webpack_require__(444);
	
	var _point = __webpack_require__(429);
	
	var _segment = __webpack_require__(440);
	
	var _circle = __webpack_require__(436);
	
	var _ellipse = __webpack_require__(434);
	
	var _ellipticalArc = __webpack_require__(435);
	
	var _bezierCurve = __webpack_require__(445);
	
	var _dim = __webpack_require__(447);
	
	var _parametric = __webpack_require__(415);
	
	var _hashmap = __webpack_require__(306);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Types = {
	  END_POINT: 'TCAD.TWO.EndPoint',
	  SEGMENT: 'TCAD.TWO.Segment',
	  ARC: 'TCAD.TWO.Arc',
	  CIRCLE: 'TCAD.TWO.Circle',
	  ELLIPSE: 'TCAD.TWO.Ellipse',
	  ELL_ARC: 'TCAD.TWO.EllipticalArc',
	  BEZIER: 'TCAD.TWO.BezierCurve',
	  DIM: 'TCAD.TWO.Dimension',
	  HDIM: 'TCAD.TWO.HDimension',
	  VDIM: 'TCAD.TWO.VDimension',
	  DDIM: 'TCAD.TWO.DiameterDimension'
	};
	
	IO.BOUNDARY_LAYER_NAME = "__bounds__";
	
	/** @constructor */
	function IO(viewer) {
	  this.viewer = viewer;
	}
	
	IO.prototype.loadSketch = function (sketchData) {
	  return this._loadSketch(JSON.parse(sketchData));
	};
	
	IO.prototype.serializeSketch = function () {
	  return JSON.stringify(this._serializeSketch());
	};
	
	IO.prototype._loadSketch = function (sketch) {
	
	  this.cleanUpData();
	
	  var index = {};
	
	  function endPoint(p) {
	    var id = p[0];
	    var ep = index[id];
	    if (ep !== undefined) {
	      return;
	    }
	    ep = new _point.EndPoint(p[1][1], p[2][1]);
	    index[p[1][0]] = ep._x;
	    index[p[2][0]] = ep._y;
	    index[id] = ep;
	    return ep;
	  }
	
	  var layerIdGen = 0;
	  function getLayer(viewer, name) {
	    if (name === undefined) {
	      name = "layer_" + layerIdGen++;
	    } else {
	      if (name === viewer.dimLayer.name) {
	        return viewer.dimLayer;
	      }
	      for (var i = 0; i < viewer.layers.length; ++i) {
	        if (name === viewer.layers[i].name) {
	          return viewer.layers[i];
	        }
	      }
	    }
	    var layer = new _viewer2d.Layer(name, _styles.Styles.DEFAULT);
	    viewer.layers.push(layer);
	    return layer;
	  }
	  var T = Types;
	  var maxEdge = 0;
	  var sketchLayers = sketch['layers'];
	  var boundary = sketch['boundary'];
	  var boundaryNeedsUpdate = !(boundary === undefined || boundary == null);
	  if (sketchLayers !== undefined) {
	    for (var l = 0; l < sketchLayers.length; ++l) {
	      var ioLayer = sketchLayers[l];
	      var layerName = ioLayer['name'];
	      var boundaryProcessing = layerName == IO.BOUNDARY_LAYER_NAME && boundaryNeedsUpdate;
	      var layer = getLayer(this.viewer, layerName);
	      if (!!ioLayer.style) layer.style = ioLayer.style;
	      layer.readOnly = !!ioLayer.readOnly;
	      var layerData = ioLayer['data'];
	      for (i = 0; i < layerData.length; ++i) {
	        var obj = layerData[i];
	        var skobj = null;
	        var _class = obj['_class'];
	        var aux = !!obj['aux'];
	
	        if (boundaryProcessing) {
	          if (_class === T.SEGMENT && boundary.lines.length == 0) continue;else if (_class === T.ARC && boundary.arcs.length == 0) continue;else if (_class === T.CIRCLE && boundary.circles.length == 0) continue;
	        }
	
	        if (_class === T.SEGMENT) {
	          var points = obj['points'];
	          var a = endPoint(points[0]);
	          var b = endPoint(points[1]);
	          skobj = new _segment.Segment(a, b);
	        } else if (_class === T.END_POINT) {
	          skobj = endPoint(obj['location']);
	        } else if (_class === T.ARC) {
	          var _points = obj['points'];
	          var _a = endPoint(_points[0]);
	          var _b = endPoint(_points[1]);
	          var c = endPoint(_points[2]);
	          skobj = new _arc.Arc(_a, _b, c);
	        } else if (_class === T.CIRCLE) {
	          var _c = endPoint(obj['c']);
	          skobj = new _circle.Circle(_c);
	          skobj.r.set(obj['r']);
	        } else if (_class === T.ELLIPSE) {
	          var ep1 = endPoint(obj['ep1']);
	          var ep2 = endPoint(obj['ep2']);
	          skobj = new _ellipse.Ellipse(ep1, ep2);
	          skobj.r.set(obj['r']);
	        } else if (_class === T.ELL_ARC) {
	          var _ep = endPoint(obj['ep1']);
	          var _ep2 = endPoint(obj['ep2']);
	          var _a2 = endPoint(obj['a']);
	          var _b2 = endPoint(obj['b']);
	          skobj = new _ellipticalArc.EllipticalArc(_ep, _ep2, _a2, _b2);
	          skobj.r.set(obj['r']);
	        } else if (_class === T.BEZIER) {
	          var _a3 = endPoint(obj['a']);
	          var _b3 = endPoint(obj['b']);
	          var cp1 = endPoint(obj['cp1']);
	          var cp2 = endPoint(obj['cp2']);
	          skobj = new _bezierCurve.BezierCurve(_a3, _b3, cp1, cp2);
	        } else if (_class === T.HDIM) {
	          skobj = new _dim.HDimension(obj['a'], obj['b']);
	          skobj.flip = obj['flip'];
	        } else if (_class === T.VDIM) {
	          skobj = new _dim.VDimension(obj['a'], obj['b']);
	          skobj.flip = obj['flip'];
	        } else if (_class === T.DIM) {
	          skobj = new _dim.Dimension(obj['a'], obj['b']);
	          skobj.flip = obj['flip'];
	        } else if (_class === T.DDIM) {
	          skobj = new _dim.DiameterDimension(obj['obj']);
	        }
	        if (skobj != null) {
	          if (!aux) skobj.stabilize(this.viewer);
	          if (aux) skobj.accept(function (o) {
	            o.aux = true;return true;
	          });
	          if (obj['edge'] !== undefined) {
	            skobj.edge = obj['edge'];
	            maxEdge = Math.max(maxEdge, skobj.edge);
	          }
	          layer.add(skobj);
	          index[obj['id']] = skobj;
	
	          //reindex non point children to recover constraints
	          var childrenIds = obj['children'];
	          if (childrenIds) {
	            var children = nonPointChildren(skobj);
	            for (var childIdx = 0; childIdx < childrenIds.length; childIdx++) {
	              index[childrenIds[childIdx]] = children[childIdx];
	            }
	          }
	        }
	        if (boundaryProcessing) {
	          if (_class === T.SEGMENT) this.synchLine(skobj, boundary.lines.shift());else if (_class === T.ARC) this.synchArc(skobj, boundary.arcs.shift());else if (_class === T.CIRCLE) this.synchCircle(skobj, boundary.circles.shift());
	        }
	      }
	    }
	  }
	
	  for (i = 0; i < this.viewer.dimLayer.objects.length; ++i) {
	    obj = this.viewer.dimLayer.objects[i];
	    if (obj._class === T.DIM || obj._class === T.HDIM || obj._class === T.VDIM) {
	      obj.a = index[obj.a];
	      obj.b = index[obj.b];
	    } else if (obj._class === T.DDIM) {
	      obj.obj = index[obj.obj];
	    }
	  }
	
	  if (boundaryNeedsUpdate) {
	    this.addNewBoundaryObjects(boundary, maxEdge);
	  }
	  var boundaryLayer = this.viewer.findLayerByName(IO.BOUNDARY_LAYER_NAME);
	  if (boundaryLayer != null) {
	    this.linkEndPoints(boundaryLayer.objects);
	  }
	
	  var sketchConstraints = sketch['constraints'];
	  if (sketchConstraints !== undefined) {
	    for (var i = 0; i < sketchConstraints.length; ++i) {
	      try {
	        var _c2 = this.parseConstr(sketchConstraints[i], index);
	        this.viewer.parametricManager._add(_c2);
	      } catch (msg) {
	        console.info("Skipping. " + msg);
	      }
	    }
	    this.viewer.parametricManager.notify();
	  }
	  var constants = sketch['constants'];
	  if (constants !== undefined) {
	    this.viewer.params.constantDefinition = constants;
	  }
	};
	
	IO.prototype.linkEndPoints = function (objects) {
	  var index = _hashmap.HashTable.forVector2d();
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = objects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var obj = _step.value;
	
	      obj.accept(function (o) {
	        if (o._class == Types.END_POINT) {
	          var equalPoint = index.get(o);
	          if (equalPoint == null) {
	            index.put(o, o);
	          } else {
	            o.linked.push(equalPoint);
	            equalPoint.linked.push(o);
	          }
	        }
	        return true;
	      });
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	};
	
	IO.prototype.synchLine = function (skobj, edgeObj) {
	  skobj.a.x = edgeObj.a.x;
	  skobj.a.y = edgeObj.a.y;
	  skobj.b.x = edgeObj.b.x;
	  skobj.b.y = edgeObj.b.y;
	};
	
	IO.prototype.synchArc = function (skobj, edgeObj) {
	  skobj.a.x = edgeObj.a.x;
	  skobj.a.y = edgeObj.a.y;
	  skobj.b.x = edgeObj.b.x;
	  skobj.b.y = edgeObj.b.y;
	  skobj.c.x = edgeObj.c.x;
	  skobj.c.y = edgeObj.c.y;
	};
	
	IO.prototype.synchCircle = function (skobj, edgeObj) {
	  skobj.c.x = edgeObj.c.x;
	  skobj.c.y = edgeObj.c.y;
	  skobj.r.set(edgeObj.r);
	};
	
	IO.prototype.addNewBoundaryObjects = function (boundary, maxEdge) {
	  var boundaryLayer = this.viewer.findLayerByName(IO.BOUNDARY_LAYER_NAME);
	
	  if (boundaryLayer === null) {
	    boundaryLayer = new _viewer2d.Layer(IO.BOUNDARY_LAYER_NAME, _styles.Styles.BOUNDS);
	    this.viewer.layers.splice(0, 0, boundaryLayer);
	  }
	
	  boundaryLayer.readOnly = true;
	  boundaryLayer.style = _styles.Styles.BOUNDS;
	
	  var i,
	      obj,
	      id = maxEdge + 1;
	  function __processAux(obj) {
	    obj.edge = id++;
	    obj.accept(function (o) {
	      o.aux = true;
	      return true;
	    });
	  }
	
	  for (i = 0; i < boundary.lines.length; ++i) {
	    var edge = boundary.lines[i];
	    var seg = this.viewer.addSegment(edge.a.x, edge.a.y, edge.b.x, edge.b.y, boundaryLayer);
	    __processAux(seg);
	  }
	  for (i = 0; i < boundary.arcs.length; ++i) {
	    var a = boundary.arcs[i];
	    var arc = new _arc.Arc(new _point.EndPoint(a.a.x, a.a.y), new _point.EndPoint(a.b.x, a.b.y), new _point.EndPoint(a.c.x, a.c.y));
	    boundaryLayer.objects.push(arc);
	    __processAux(arc);
	  }
	  for (i = 0; i < boundary.circles.length; ++i) {
	    obj = boundary.circles[i];
	    var circle = new _circle.Circle(new _point.EndPoint(obj.c.x, obj.c.y));
	    circle.r.set(obj.r);
	    boundaryLayer.objects.push(circle);
	    __processAux(circle);
	  }
	};
	
	IO.prototype.cleanUpData = function () {
	  for (var l = 0; l < this.viewer.layers.length; ++l) {
	    var layer = this.viewer.layers[l];
	    if (layer.objects.length != 0) {
	      layer.objects = [];
	    }
	  }
	  this.viewer.deselectAll();
	  _idGenerator.Generator.resetIDGenerator(0);
	  if (this.viewer.parametricManager.subSystems.length != 0) {
	    this.viewer.parametricManager.subSystems = [];
	    this.viewer.parametricManager.notify();
	  }
	};
	
	IO.prototype._serializeSketch = function () {
	  var sketch = {};
	  //sketch.boundary = boundary;
	  sketch['layers'] = [];
	  function point(p) {
	    return [p.id, [p._x.id, p.x], [p._y.id, p.y]];
	  }
	  var T = Types;
	  var toSave = [this.viewer.dimLayers, this.viewer.layers];
	  for (var t = 0; t < toSave.length; ++t) {
	    var layers = toSave[t];
	    for (var l = 0; l < layers.length; ++l) {
	      var layer = layers[l];
	      var toLayer = { 'name': layer.name, style: layer.style, readOnly: layer.readOnly, 'data': [] };
	      sketch['layers'].push(toLayer);
	      for (var i = 0; i < layer.objects.length; ++i) {
	        var obj = layer.objects[i];
	        var to = { 'id': obj.id, '_class': obj._class };
	        if (obj.aux) to.aux = obj.aux;
	        if (obj.edge !== undefined) to.edge = obj.edge;
	        toLayer['data'].push(to);
	        if (obj._class === T.SEGMENT) {
	          to['points'] = [point(obj.a), point(obj.b)];
	        } else if (obj._class === T.END_POINT) {
	          to['location'] = point(obj);
	        } else if (obj._class === T.ARC) {
	          to['points'] = [point(obj.a), point(obj.b), point(obj.c)];
	        } else if (obj._class === T.CIRCLE) {
	          to['c'] = point(obj.c);
	          to['r'] = obj.r.get();
	        } else if (obj._class === T.ELLIPSE) {
	          to['ep1'] = point(obj.ep1);
	          to['ep2'] = point(obj.ep2);
	          to['r'] = obj.r.get();
	        } else if (obj._class === T.ELL_ARC) {
	          to['ep1'] = point(obj.ep1);
	          to['ep2'] = point(obj.ep2);
	          to['a'] = point(obj.a);
	          to['b'] = point(obj.b);
	          to['r'] = obj.r.get();
	        } else if (obj._class === T.BEZIER) {
	          to['a'] = point(obj.a);
	          to['b'] = point(obj.b);
	          to['cp1'] = point(obj.cp1);
	          to['cp2'] = point(obj.cp2);
	        } else if (obj._class === T.DIM || obj._class === T.HDIM || obj._class === T.VDIM) {
	          to['a'] = obj.a.id;
	          to['b'] = obj.b.id;
	          to['flip'] = obj.flip;
	        } else if (obj._class === T.DDIM) {
	          to['obj'] = obj.obj.id;
	        }
	        var children = nonPointChildren(obj).map(function (c) {
	          return c.id;
	        });
	        if (children.length != 0) {
	          to['children'] = children;
	        }
	      }
	    }
	  }
	
	  var constrs = sketch['constraints'] = [];
	  var subSystems = this.viewer.parametricManager.subSystems;
	  for (var j = 0; j < subSystems.length; j++) {
	    var sub = subSystems[j];
	    for (i = 0; i < sub.constraints.length; ++i) {
	      if (!sub.constraints[i].aux) {
	        constrs.push(this.serializeConstr(sub.constraints[i]));
	      }
	    }
	  }
	
	  var constantDefinition = this.viewer.params.constantDefinition;
	  if (constantDefinition !== undefined && constantDefinition != null && !/^\s*$/.test(constantDefinition)) {
	    sketch['constants'] = constantDefinition;
	  }
	  return sketch;
	};
	
	function nonPointChildren(obj) {
	  var children = [];
	  obj.accept(function (o) {
	    if (o._class !== Types.END_POINT) {
	      children.push(o);
	    }
	    return true;
	  });
	  return children;
	}
	
	IO.prototype.parseConstr = function (c, index) {
	  var name = c[0];
	  var ps = c[1];
	  function find(id) {
	    var p = index[id];
	    if (!p) {
	      throw "Constraint " + name + " refers to nonexistent object.";
	    }
	    return p;
	  }
	  var constrCreate = _parametric.Constraints.Factory[name];
	  if (constrCreate === undefined) {
	    throw "Constraint " + name + " doesn't exist.";
	  }
	  return constrCreate(find, ps);
	};
	
	IO.prototype.serializeConstr = function (c) {
	  return c.serialize();
	};
	
	function _format(str, args) {
	  if (args.length == 0) return str;
	  var i = 0;
	  return str.replace(/\$/g, function () {
	    if (args === undefined || args[i] === undefined) throw "format arguments mismatch";
	    var val = args[i];
	    if (typeof val === 'number') val = val.toPrecision();
	    i++;
	    return val;
	  });
	}
	
	/** @constructor */
	function PrettyColors() {
	  var colors = ["#000000", "#00008B", "#006400", "#8B0000", "#FF8C00", "#E9967A"];
	  var colIdx = 0;
	  this.next = function () {
	    return colors[colIdx++ % colors.length];
	  };
	}
	
	/** @constructor */
	function TextBuilder() {
	  this.data = "";
	  this.fline = function (chunk, args) {
	    this.data += _format(chunk, args) + "\n";
	  };
	  this.line = function (chunk) {
	    this.data += chunk + "\n";
	  };
	  this.number = function (n) {
	    this.data += n.toPrecision();
	  };
	  this.numberln = function (n) {
	    this.number(n);
	    this.data += "\n";
	  };
	}
	
	/** @constructor */
	function BBox() {
	  var bbox = [Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE];
	
	  var T = Types;
	
	  this.checkLayers = function (layers) {
	    for (var l = 0; l < layers.length; ++l) {
	      for (var i = 0; i < layers[l].objects.length; ++i) {
	        this.check(layers[l].objects[i]);
	      }
	    }
	  };
	
	  this.check = function (obj) {
	    var _this = this;
	
	    if (obj._class === T.SEGMENT) {
	      this.checkBounds(obj.a.x, obj.a.y);
	      this.checkBounds(obj.b.x, obj.b.y);
	    } else if (obj._class === T.END_POINT) {
	      this.checkBounds(obj.x, obj.y);
	    } else if (obj._class === T.ARC) {
	      this.checkCircBounds(obj.c.x, obj.c.y, obj.r.get());
	    } else if (obj._class === T.CIRCLE) {
	      this.checkCircBounds(obj.c.x, obj.c.y, obj.r.get());
	    } else if (obj._class === T.ELLIPSE || obj._class === T.ELL_ARC) {
	      this.checkCircBounds(obj.centerX, obj.centerY, Math.max(obj.radiusX, obj.radiusY));
	    } else if (obj) {
	      obj.accept(function (o) {
	        if (o._class == T.END_POINT) {
	          _this.checkBounds(o.x, o.y);
	        }
	        return true;
	      });
	      //    } else if (obj._class === T.DIM || obj._class === T.HDIM || obj._class === T.VDIM) {
	    }
	  };
	
	  this.isValid = function () {
	    return bbox[0] != Number.MAX_VALUE;
	  };
	
	  this.checkBounds = function (x, y) {
	    bbox[0] = Math.min(bbox[0], x);
	    bbox[1] = Math.min(bbox[1], y);
	    bbox[2] = Math.max(bbox[2], x);
	    bbox[3] = Math.max(bbox[3], y);
	  };
	
	  this.checkCircBounds = function (x, y, r) {
	    this.checkBounds(x + r, y + r);
	    this.checkBounds(x - r, y + r);
	    this.checkBounds(x - r, y - r);
	    this.checkBounds(x - r, y + r);
	  };
	
	  this.inc = function (by) {
	    bbox[0] -= by;
	    bbox[1] -= by;
	    bbox[2] += by;
	    bbox[3] += by;
	  };
	
	  this.width = function () {
	    return bbox[2] - bbox[0];
	  };
	
	  this.height = function () {
	    return bbox[3] - bbox[1];
	  };
	
	  this.bbox = bbox;
	}
	
	IO.prototype.getWorkspaceToExport = function () {
	  return [this.viewer.layers];
	};
	
	IO.prototype.getLayersToExport = function () {
	  var ws = this.getWorkspaceToExport();
	  var toExport = [];
	  for (var t = 0; t < ws.length; ++t) {
	    var layers = ws[t];
	    for (var l = 0; l < layers.length; ++l) {
	      var layer = layers[l];
	      toExport.push(layer);
	    }
	  }
	  return toExport;
	};
	
	IO.prototype.svgExport = function () {
	
	  var T = Types;
	  var out = new TextBuilder();
	
	  var bbox = new BBox();
	
	  var a = new _vector2.default();
	  var b = new _vector2.default();
	
	  var prettyColors = new PrettyColors();
	  var toExport = this.getLayersToExport();
	  for (var l = 0; l < toExport.length; ++l) {
	    var layer = toExport[l];
	    var color = prettyColors.next();
	    out.fline('<g id="$" fill="$" stroke="$" stroke-width="$">', [layer.name, "none", color, '2']);
	    for (var i = 0; i < layer.objects.length; ++i) {
	      var obj = layer.objects[i];
	      if (obj._class !== T.END_POINT) bbox.check(obj);
	      if (obj._class === T.SEGMENT) {
	        out.fline('<line x1="$" y1="$" x2="$" y2="$" />', [obj.a.x, obj.a.y, obj.b.x, obj.b.y]);
	      } else if (obj._class === T.ARC) {
	        a.set(obj.a.x - obj.c.x, obj.a.y - obj.c.y, 0);
	        b.set(obj.b.x - obj.c.x, obj.b.y - obj.c.y, 0);
	        var dir = a.cross(b).z > 0 ? 0 : 1;
	        var r = obj.r.get();
	        out.fline('<path d="M $ $ A $ $ 0 $ $ $ $" />', [obj.a.x, obj.a.y, r, r, dir, 1, obj.b.x, obj.b.y]);
	      } else if (obj._class === T.CIRCLE) {
	        out.fline('<circle cx="$" cy="$" r="$" />', [obj.c.x, obj.c.y, obj.r.get()]);
	        //      } else if (obj._class === T.DIM || obj._class === T.HDIM || obj._class === T.VDIM) {
	      }
	    }
	    out.line('</g>');
	  }
	  bbox.inc(20);
	  return _format("<svg viewBox='$ $ $ $'>\n", bbox.bbox) + out.data + "</svg>";
	};
	
	IO.prototype.dxfExport = function () {
	  var T = Types;
	  var out = new TextBuilder();
	  var bbox = new BBox();
	  var toExport = this.getLayersToExport();
	  var i;
	  bbox.checkLayers(toExport);
	  out.line("999");
	  out.line("js.parametric.sketcher");
	  out.line("0");
	  out.line("SECTION");
	  out.line("2");
	  out.line("HEADER");
	  out.line("9");
	  out.line("$ACADVER");
	  out.line("1");
	  out.line("AC1006");
	  out.line("9");
	  out.line("$INSBASE");
	  out.line("10");
	  out.line("0");
	  out.line("20");
	  out.line("0");
	  out.line("30");
	  out.line("0");
	  out.line("9");
	  out.line("$EXTMIN");
	  out.line("10");
	  out.numberln(bbox.bbox[0]);
	  out.line("20");
	  out.numberln(bbox.bbox[1]);
	  out.line("9");
	  out.line("$EXTMAX");
	  out.line("10");
	  out.numberln(bbox.bbox[2]);
	  out.line("20");
	  out.numberln(bbox.bbox[3]);
	  out.line("0");
	  out.line("ENDSEC");
	
	  out.line("0");
	  out.line("SECTION");
	  out.line("2");
	  out.line("TABLES");
	
	  for (i = 0; i < toExport.length; i++) {
	    out.line("0");
	    out.line("LAYER");
	    out.line("2");
	    out.line("" + (i + 1));
	    out.line("70");
	    out.line("64");
	    out.line("62");
	    out.line("7");
	    out.line("6");
	    out.line("CONTINUOUS");
	  }
	  out.line("0");
	  out.line("ENDTAB");
	  out.line("0");
	  out.line("ENDSEC");
	  out.line("0");
	  out.line("SECTION");
	  out.line("2");
	  out.line("BLOCKS");
	  out.line("0");
	  out.line("ENDSEC");
	  out.line("0");
	  out.line("SECTION");
	  out.line("2");
	  out.line("ENTITIES");
	
	  for (var l = 0; l < toExport.length; l++) {
	    var lid = l + 1;
	    var layer = toExport[l];
	    for (i = 0; i < layer.objects.length; ++i) {
	      var obj = layer.objects[i];
	      if (obj._class === T.END_POINT) {
	        out.line("0");
	        out.line("POINT");
	        out.line("8");
	        out.line(lid);
	        out.line("10");
	        out.numberln(obj.x);
	        out.line("20");
	        out.numberln(obj.y);
	        out.line("30");
	        out.line("0");
	      } else if (obj._class === T.SEGMENT) {
	        out.line("0");
	        out.line("LINE");
	        out.line("8");
	        out.line(lid);
	        //out.line("62"); color
	        //out.line("4");
	        out.line("10");
	        out.numberln(obj.a.x);
	        out.line("20");
	        out.numberln(obj.a.y);
	        out.line("30");
	        out.line("0");
	        out.line("11");
	        out.numberln(obj.b.x);
	        out.line("21");
	        out.numberln(obj.b.y);
	        out.line("31");
	        out.line("0");
	      } else if (obj._class === T.ARC) {
	        out.line("0");
	        out.line("ARC");
	        out.line("8");
	        out.line(lid);
	        out.line("10");
	        out.numberln(obj.c.x);
	        out.line("20");
	        out.numberln(obj.c.y);
	        out.line("30");
	        out.line("0");
	        out.line("40");
	        out.numberln(obj.r.get());
	        out.line("50");
	        out.numberln(obj.getStartAngle() * (180 / Math.PI));
	        out.line("51");
	        out.numberln(obj.getEndAngle() * (180 / Math.PI));
	      } else if (obj._class === T.CIRCLE) {
	        out.line("0");
	        out.line("CIRCLE");
	        out.line("8");
	        out.line(lid);
	        out.line("10");
	        out.numberln(obj.c.x);
	        out.line("20");
	        out.numberln(obj.c.y);
	        out.line("30");
	        out.line("0");
	        out.line("40");
	        out.numberln(obj.r.get());
	        //      } else if (obj._class === T.DIM || obj._class === T.HDIM || obj._class === T.VDIM) {
	      }
	    }
	  }
	
	  out.line("0");
	  out.line("ENDSEC");
	  out.line("0");
	  out.line("EOF");
	  return out.data;
	};
	
	IO.exportTextData = function (data, fileName) {
	  var link = document.getElementById("downloader");
	  link.href = "data:application/octet-stream;charset=utf-8;base64," + btoa(data);
	  link.download = fileName;
	  link.click();
	  //console.log(app.viewer.io.svgExport());
	};
	
	exports.IO = IO;
	exports.BBox = BBox;
	exports.Types = Types;

/***/ },
/* 412 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var ID_COUNTER = 0;
	
	var Generator = exports.Generator = {
	  genID: function genID() {
	    return ID_COUNTER++;
	  },
	
	  resetIDGenerator: function resetIDGenerator(value) {
	    ID_COUNTER = value;
	  }
	};

/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Styles = exports.Layer = exports.Viewer = undefined;
	
	var _idGenerator = __webpack_require__(412);
	
	var _styles = __webpack_require__(414);
	
	var _toolkit = __webpack_require__(300);
	
	var _parametric = __webpack_require__(415);
	
	var _history = __webpack_require__(424);
	
	var _manager = __webpack_require__(426);
	
	var _pan = __webpack_require__(427);
	
	var _drag = __webpack_require__(438);
	
	var _segment = __webpack_require__(440);
	
	var _point = __webpack_require__(429);
	
	var _primitives = __webpack_require__(441);
	
	var _referencePoint = __webpack_require__(442);
	
	var _basisOrigin = __webpack_require__(443);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _drawUtils = __webpack_require__(432);
	
	var draw_utils = _interopRequireWildcard(_drawUtils);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/** @constructor */
	function Viewer(canvas, IO) {
	
	  // 1/1000'' aka 1 mil is a standard precision for the imperial system(for engeneering) 
	  // this precision also covers the metric system which is supposed to be ~0.01
	  // this field is used only for displaying purposes now, although in future it could be
	  // used to keep all internal data with such precision transforming the input from user
	  this.presicion = 3;
	  this.canvas = canvas;
	  this.params = new _toolkit.Parameters();
	  this.io = new IO(this);
	  var viewer = this;
	  this.retinaPxielRatio = window.devicePixelRatio > 1 ? window.devicePixelRatio : 1;
	  function updateCanvasSize() {
	    var canvasWidth = canvas.parentNode.offsetWidth;
	    var canvasHeight = canvas.parentNode.offsetHeight;
	
	    canvas.width = canvasWidth * viewer.retinaPxielRatio;
	    canvas.height = canvasHeight * viewer.retinaPxielRatio;
	
	    canvas.style.width = canvasWidth + "px";
	    canvas.style.height = canvasHeight + "px";
	  }
	
	  this.onWindowResize = function () {
	    updateCanvasSize();
	    viewer.refresh();
	  };
	  updateCanvasSize();
	  window.addEventListener('resize', this.onWindowResize, false);
	
	  Object.defineProperty(this, "activeLayer", {
	    get: viewer.getActiveLayer,
	    set: viewer.setActiveLayer
	  });
	
	  this.bus = new _toolkit.Bus();
	  this.ctx = this.canvas.getContext("2d");
	  this._activeLayer = null;
	  this.layers = [];
	  this.dimLayer = new Layer("_dim", _styles.Styles.DIM);
	  this.dimLayers = [this.dimLayer];
	  this.bus.defineObservable(this, 'dimScale', 1);
	  this.bus.subscribe('dimScale', function () {
	    viewer.refresh();
	  });
	
	  this._workspace = [this.layers, this.dimLayers];
	
	  this.referencePoint = new _referencePoint.ReferencePoint();
	  this._serviceWorkspace = [this._createServiceLayers()];
	
	  this.toolManager = new _manager.ToolManager(this, new _pan.PanTool(this));
	  this.parametricManager = new _parametric.ParametricManager(this);
	
	  this.translate = { x: 0.0, y: 0.0 };
	  this.scale = 1.0;
	
	  this.selected = [];
	  this.snapped = null;
	
	  this.historyManager = new _history.HistoryManager(this);
	  this.refresh();
	}
	
	Viewer.prototype.roundToPrecision = function (value) {
	  return value.toFixed(this.presicion);
	};
	
	Viewer.prototype.addSegment = function (x1, y1, x2, y2, layer) {
	  var a = new _point.EndPoint(x1, y1);
	  var b = new _point.EndPoint(x2, y2);
	  var line = new _segment.Segment(a, b);
	  layer.add(line);
	  return line;
	};
	
	Viewer.prototype.remove = function (obj) {
	  if (obj.layer != null) {
	    if (obj.layer.remove(obj)) {
	      this.parametricManager.removeConstraintsByObj(obj);
	    }
	  }
	};
	
	Viewer.prototype.add = function (obj, layer) {
	  layer.add(obj);
	};
	
	function isEndPoint(o) {
	  return o._class === 'TCAD.TWO.EndPoint';
	}
	
	Viewer.prototype.search = function (x, y, buffer, deep, onlyPoints, filter) {
	  var _this = this;
	
	  buffer *= 0.5;
	
	  var pickResult = [];
	  var aim = new _vector2.default(x, y);
	
	  var heroIdx = 0;
	  var unreachable = buffer * 2;
	  var heroLength = unreachable; // unreachable
	
	  function isFiltered(o) {
	    for (var i = 0; i < filter.length; ++i) {
	      if (filter[i] === o) return true;
	    }
	    return false;
	  }
	
	  for (var i = 0; i < this.layers.length; i++) {
	    var objs = this.layers[i].objects;
	    for (var j = 0; j < objs.length; j++) {
	      var l = unreachable + 1;
	      var before = pickResult.length;
	      objs[j].accept(function (o) {
	        if (!o.visible) return true;
	        if (onlyPoints && !isEndPoint(o)) {
	          return true;
	        }
	        l = o.normalDistance(aim, _this.scale);
	        if (l >= 0 && l <= buffer && !isFiltered(o)) {
	          pickResult.push(o);
	          return false;
	        }
	        return true;
	      });
	      var hit = before - pickResult.length != 0;
	      if (hit) {
	        if (!deep && pickResult.length != 0) return pickResult;
	        if (l >= 0 && l < heroLength) {
	          heroLength = l;
	          heroIdx = pickResult.length - 1;
	        }
	      }
	    }
	  }
	  if (pickResult.length > 0) {
	    var _f = pickResult[0];
	    pickResult[0] = pickResult[heroIdx];
	    pickResult[heroIdx] = _f;
	  }
	  return pickResult;
	};
	
	Viewer.prototype._createServiceLayers = function () {
	  var layer = new Layer("_service", _styles.Styles.SERVICE);
	  //  layer.objects.push(new CrossHair(0, 0, 20));
	  layer.objects.push(new _primitives.Point(0, 0, 2));
	  layer.objects.push(this.referencePoint);
	  layer.objects.push(new _basisOrigin.BasisOrigin(null, this));
	  return [layer];
	};
	
	Viewer.prototype.refresh = function () {
	  var viewer = this;
	  window.requestAnimationFrame(function () {
	    viewer.repaint();
	  });
	};
	
	Viewer.prototype.repaint = function () {
	
	  var ctx = this.ctx;
	  ctx.setTransform(1, 0, 0, 1, 0, 0);
	
	  ctx.fillStyle = "#808080";
	  ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
	
	  //Order is important!
	  ctx.transform(1, 0, 0, -1, 0, this.canvas.height);
	  ctx.transform(1, 0, 0, 1, this.translate.x, this.translate.y);
	  ctx.transform(this.scale, 0, 0, this.scale, 0, 0);
	
	  this.__prevStyle = null;
	
	  this.__drawWorkspace(ctx, this._workspace, Viewer.__SKETCH_DRAW_PIPELINE);
	  this.__drawWorkspace(ctx, this._serviceWorkspace, Viewer.__SIMPLE_DRAW_PIPELINE);
	};
	
	Viewer.__SKETCH_DRAW_PIPELINE = [function (obj) {
	  return !isEndPoint(obj) && obj.marked === null;
	}, function (obj) {
	  return !isEndPoint(obj) && obj.marked !== null;
	}, function (obj) {
	  return isEndPoint(obj) && obj.marked === null;
	}, function (obj) {
	  return isEndPoint(obj) && obj.marked !== null;
	}];
	
	Viewer.__SIMPLE_DRAW_PIPELINE = [function (obj) {
	  return true;
	}];
	
	Viewer.prototype.__drawWorkspace = function (ctx, workspace, pipeline) {
	  var _this2 = this;
	
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    var _loop = function _loop() {
	      var drawPredicate = _step.value;
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        for (var _iterator2 = workspace[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var layers = _step2.value;
	          var _iteratorNormalCompletion3 = true;
	          var _didIteratorError3 = false;
	          var _iteratorError3 = undefined;
	
	          try {
	            var _loop2 = function _loop2() {
	              var layer = _step3.value;
	              var _iteratorNormalCompletion4 = true;
	              var _didIteratorError4 = false;
	              var _iteratorError4 = undefined;
	
	              try {
	                for (var _iterator4 = layer.objects[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	                  var obj = _step4.value;
	
	                  obj.accept(function (obj) {
	                    if (!obj.visible) return true;
	                    if (drawPredicate(obj)) {
	                      _this2.__draw(ctx, layer, obj);
	                    }
	                    return true;
	                  });
	                }
	              } catch (err) {
	                _didIteratorError4 = true;
	                _iteratorError4 = err;
	              } finally {
	                try {
	                  if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                    _iterator4.return();
	                  }
	                } finally {
	                  if (_didIteratorError4) {
	                    throw _iteratorError4;
	                  }
	                }
	              }
	            };
	
	            for (var _iterator3 = layers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	              _loop2();
	            }
	          } catch (err) {
	            _didIteratorError3 = true;
	            _iteratorError3 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                _iterator3.return();
	              }
	            } finally {
	              if (_didIteratorError3) {
	                throw _iteratorError3;
	              }
	            }
	          }
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	    };
	
	    for (var _iterator = pipeline[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      _loop();
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	};
	
	Viewer.prototype.__draw = function (ctx, layer, obj) {
	  var style = this.getStyleForObject(layer, obj);
	  if (style !== this.__prevStyle) {
	    this.setStyle(style, ctx);
	  }
	  this.__prevStyle = style;
	  obj.draw(ctx, this.scale / this.retinaPxielRatio, this);
	};
	
	Viewer.prototype.getStyleForObject = function (layer, obj) {
	  if (obj.style != null) {
	    return obj.style;
	  } else if (obj.role != null) {
	    var style = layer.stylesByRoles[obj.role];
	    if (style) {
	      return style;
	    }
	  }
	  return layer.style;
	};
	
	Viewer.prototype.setStyle = function (style, ctx) {
	  draw_utils.SetStyle(style, ctx, this.scale / this.retinaPxielRatio);
	};
	
	Viewer.prototype.snap = function (x, y, excl) {
	  this.cleanSnap();
	  var snapTo = this.search(x, y, 20 / this.scale, true, true, excl);
	  if (snapTo.length > 0) {
	    this.snapped = snapTo[0];
	    this.mark(this.snapped, _styles.Styles.SNAP);
	  }
	  return this.snapped;
	};
	
	Viewer.prototype.cleanSnap = function () {
	  if (this.snapped != null) {
	    this.deselect(this.snapped);
	    this.snapped = null;
	  }
	};
	
	Viewer.prototype.showBounds = function (x1, y1, x2, y2, offset) {
	  var dx = x2 - x1;
	  var dy = y2 - y1;
	  if (this.canvas.width > this.canvas.height) {
	    this.scale = this.canvas.height / dy;
	  } else {
	    this.scale = this.canvas.width / dx;
	  }
	  this.translate.x = -x1 * this.scale;
	  this.translate.y = -y1 * this.scale;
	};
	
	Viewer.prototype.screenToModel2 = function (x, y, out) {
	
	  out.x = x * this.retinaPxielRatio;
	  out.y = this.canvas.height - y * this.retinaPxielRatio;
	
	  out.x -= this.translate.x;
	  out.y -= this.translate.y;
	
	  out.x /= this.scale;
	  out.y /= this.scale;
	};
	
	Viewer.prototype.screenToModel = function (e) {
	  return this._screenToModel(e.offsetX, e.offsetY);
	};
	
	Viewer.prototype._screenToModel = function (x, y) {
	  var out = { x: 0, y: 0 };
	  this.screenToModel2(x, y, out);
	  return out;
	};
	
	Viewer.prototype.accept = function (visitor) {
	  var _iteratorNormalCompletion5 = true;
	  var _didIteratorError5 = false;
	  var _iteratorError5 = undefined;
	
	  try {
	    for (var _iterator5 = this.layers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	      var _layer = _step5.value;
	      var _iteratorNormalCompletion6 = true;
	      var _didIteratorError6 = false;
	      var _iteratorError6 = undefined;
	
	      try {
	        for (var _iterator6 = _layer.objects[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	          var object = _step6.value;
	
	          if (!object.accept(visitor)) {
	            return false;
	          }
	        }
	      } catch (err) {
	        _didIteratorError6 = true;
	        _iteratorError6 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion6 && _iterator6.return) {
	            _iterator6.return();
	          }
	        } finally {
	          if (_didIteratorError6) {
	            throw _iteratorError6;
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError5 = true;
	    _iteratorError5 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion5 && _iterator5.return) {
	        _iterator5.return();
	      }
	    } finally {
	      if (_didIteratorError5) {
	        throw _iteratorError5;
	      }
	    }
	  }
	};
	
	Viewer.prototype.findLayerByName = function (name) {
	  for (var i = 0; i < this.layers.length; i++) {
	    if (this.layers[i].name == name) {
	      return this.layers[i];
	    }
	  }
	  return null;
	};
	
	Viewer.prototype.findById = function (id) {
	  var result = null;
	  this.accept(function (o) {
	    if (o.id === id) {
	      result = o;
	      return false;
	    }
	    return true;
	  });
	  return result;
	};
	
	Viewer.prototype.select = function (objs, exclusive) {
	  if (exclusive) this.deselectAll();
	  for (var i = 0; i < objs.length; i++) {
	    this.mark(objs[i]);
	  }
	};
	
	Viewer.prototype.pick = function (e) {
	  var m = this.screenToModel(e);
	  return this.search(m.x, m.y, 20 / this.scale, true, false, []);
	};
	
	Viewer.prototype.mark = function (obj, style) {
	  if (style === undefined) {
	    style = _styles.Styles.MARK;
	  }
	  obj.marked = style;
	
	  if (this.selected.indexOf(obj) == -1) {
	    this.selected.push(obj);
	  }
	};
	
	Viewer.prototype.getActiveLayer = function () {
	  var layer = this._activeLayer;
	  if (layer == null || layer.readOnly) {
	    layer = null;
	    for (var i = 0; i < this.layers.length; i++) {
	      var l = this.layers[i];
	      if (!l.readOnly) {
	        layer = l;
	        break;
	      }
	    }
	  }
	  if (layer == null) {
	    layer = new Layer("JustALayer", _styles.Styles.DEFAULT);
	    this.layers.push(layer);
	  }
	  return layer;
	};
	
	Viewer.prototype.setActiveLayer = function (layer) {
	  if (!layer.readOnly) {
	    this._activeLayer = layer;
	    this.bus.notify("activeLayer");
	  }
	};
	
	Viewer.prototype.deselect = function (obj) {
	  for (var i = 0; i < this.selected.length; i++) {
	    if (obj === this.selected[i]) {
	      this.selected.splice(i, 1)[0].marked = null;
	      break;
	    }
	  }
	};
	
	Viewer.prototype.deselectAll = function () {
	  for (var i = 0; i < this.selected.length; i++) {
	    this.selected[i].marked = null;
	  }
	  while (this.selected.length > 0) {
	    this.selected.pop();
	  }
	};
	
	Viewer.prototype.equalizeLinkedEndpoints = function () {
	  var visited = new Set();
	
	  function equalize(obj) {
	    if (visited.has(obj.id)) return;
	    visited.add(obj.id);
	    var _iteratorNormalCompletion7 = true;
	    var _didIteratorError7 = false;
	    var _iteratorError7 = undefined;
	
	    try {
	      for (var _iterator7 = obj.linked[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	        var link = _step7.value;
	
	        if (isEndPoint(link)) {
	          equalize(obj, link);
	          link.setFromPoint(obj);
	          equalize(link);
	        }
	      }
	    } catch (err) {
	      _didIteratorError7 = true;
	      _iteratorError7 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion7 && _iterator7.return) {
	          _iterator7.return();
	        }
	      } finally {
	        if (_didIteratorError7) {
	          throw _iteratorError7;
	        }
	      }
	    }
	  }
	  this.accept(function (obj) {
	    if (isEndPoint(obj)) {
	      equalize(obj);
	    }
	    return true;
	  });
	};
	
	/** @constructor */
	function Layer(name, style) {
	  this.name = name;
	  this.style = style;
	  this.stylesByRoles = {
	    'construction': _styles.Styles.CONSTRUCTION_OF_OBJECT
	  };
	  this.objects = [];
	  this.readOnly = false; // This is actually a mark for boundary layers coming from 3D
	}
	
	Layer.prototype.remove = function (object) {
	  var idx = this.objects.indexOf(object);
	  if (idx != -1) {
	    this.objects.splice(idx, 1);
	    return true;
	  }
	  return false;
	};
	
	Layer.prototype.add = function (object) {
	  if (object.layer !== undefined) {
	    if (object.layer != null) {
	      object.layer.remove(object);
	    }
	    if (object.layer !== this) {
	      this.objects.push(object);
	      object.layer = this;
	    }
	  } else {
	    this.objects.push(object);
	  }
	};
	
	Viewer.prototype.fullHeavyUIRefresh = function () {
	  this.refresh();
	  this.parametricManager.notify();
	};
	
	exports.Viewer = Viewer;
	exports.Layer = Layer;
	exports.Styles = _styles.Styles;

/***/ },
/* 414 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var Styles = exports.Styles = {
	  DEFAULT: {
	    lineWidth: 2,
	    strokeStyle: "#ffffff",
	    fillStyle: "#000000"
	  },
	
	  SERVICE: {
	    lineWidth: 0.3,
	    strokeStyle: "#ff0000",
	    fillStyle: "#FF0000"
	  },
	
	  MARK: {
	    lineWidth: 2,
	    strokeStyle: "#ff0000",
	    fillStyle: "#FF0000"
	  },
	
	  SNAP: {
	    lineWidth: 2,
	    strokeStyle: "#00FF00",
	    fillStyle: "#00FF00"
	  },
	
	  DIM: {
	    lineWidth: 1,
	    strokeStyle: "#bcffc1",
	    fillStyle: "#00FF00"
	  },
	
	  BOUNDS: {
	    lineWidth: 2,
	    strokeStyle: "#fff5c3",
	    fillStyle: "#000000"
	  },
	
	  CONSTRUCTION: {
	    lineWidth: 1,
	    strokeStyle: "#aaaaaa",
	    fillStyle: "#000000"
	  },
	
	  CONSTRUCTION_OF_OBJECT: {
	    lineWidth: 1,
	    strokeStyle: "#888888",
	    fillStyle: "#000000"
	  }
	};

/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ParametricManager = exports.Constraints = undefined;
	
	var _utils = __webpack_require__(330);
	
	var utils = _interopRequireWildcard(_utils);
	
	var _ref = __webpack_require__(416);
	
	var _solver = __webpack_require__(417);
	
	var _constraints = __webpack_require__(420);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	var _fetchers = __webpack_require__(423);
	
	var fetch = _interopRequireWildcard(_fetchers);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	var Constraints = {};
	
	/** @constructor */
	function SubSystem() {
	  this.alg = 1;
	  this.error = 0;
	  this.reduce = false;
	  this.constraints = [];
	}
	
	/** @constructor */
	function ParametricManager(viewer) {
	  this.viewer = viewer;
	  this.subSystems = [];
	  this.listeners = [];
	  this.constantTable = {};
	
	  this.viewer.params.define('constantDefinition', null);
	  this.viewer.params.subscribe('constantDefinition', 'parametricManager', this.onConstantsExternalChange, this)();
	  this.constantResolver = this.createConstantResolver();
	}
	
	ParametricManager.prototype.createConstantResolver = function () {
	  var pm = this;
	  return function (value) {
	    var _value = pm.constantTable[value];
	    if (_value !== undefined) {
	      value = _value;
	    } else if (typeof value != 'number') {
	      console.error("unable to resolve constant " + value);
	    }
	    return value;
	  };
	};
	
	ParametricManager.prototype.notify = function (event) {
	  for (var i = 0; i < this.listeners.length; ++i) {
	    var l = this.listeners[i];
	    l(event);
	  }
	};
	
	ParametricManager.prototype.rebuildConstantTable = function (constantDefinition) {
	  this.constantTable = {};
	  if (constantDefinition == null) return;
	  var lines = constantDefinition.split('\n');
	  var prefix = "(function() { \n";
	  for (var i = 0; i < lines.length; i++) {
	    var line = lines[i];
	    var m = line.match(/^\s*([^\s]+)\s*=(.+)$/);
	    if (m != null && m.length == 3) {
	      var constant = m[1];
	      try {
	        var value = eval(prefix + "return " + m[2] + "; \n})()");
	        this.constantTable[constant] = value;
	        prefix += "const " + constant + " = " + value + ";\n";
	      } catch (e) {
	        console.log(e);
	      }
	    }
	  }
	};
	
	ParametricManager.prototype.onConstantsExternalChange = function (constantDefinition) {
	  this.rebuildConstantTable(constantDefinition);
	  this.refresh();
	};
	
	ParametricManager.prototype.defineNewConstant = function (name, value) {
	  var constantDefinition = this.viewer.params.constantDefinition;
	  var constantText = name + ' = ' + value;
	  if (constantDefinition) {
	    constantDefinition += '\n' + constantText;
	  } else {
	    constantDefinition = constantText;
	  }
	  this.rebuildConstantTable(constantDefinition);
	  //disabling onConstantsExternalChange since we don't need re-solve  
	  this.viewer.params.set('constantDefinition', constantDefinition, 'parametricManager');
	};
	
	ParametricManager.prototype.findComponents = function (constr) {
	  if (this.subSystems.length === 0) {
	    this.subSystems.push(new SubSystem());
	  }
	  return [0];
	};
	
	ParametricManager.prototype.tune = function (subSystem) {};
	
	ParametricManager.prototype._add = function (constr) {
	  var subSystemIds = this.findComponents(constr);
	  var subSystem;
	  switch (subSystemIds.length) {
	    case 0:
	      subSystem = new SubSystem();
	      this.subSystems.push(subSystem);
	      break;
	    case 1:
	      subSystem = this.subSystems[subSystemIds[0]];
	      break;
	    default:
	      subSystem = this.subSystems[subSystemIds[0]];
	      for (var i = 1; i < subSystemIds.length; i++) {
	        var toMerge = subSystemIds[i];
	        for (var j = 0; j < toMerge.constraints.length; j++) {
	          subSystem.push(toMerge.constraints[j]);
	        }
	      }
	      break;
	  }
	  subSystem.constraints.push(constr);
	  return subSystem;
	};
	
	ParametricManager.prototype.checkRedundancy = function (subSystem, constr) {
	  var solver = this.prepareForSubSystem([], subSystem.constraints);
	  if (solver.diagnose().conflict) {
	    alert("Most likely this " + constr.NAME + " constraint is CONFLICTING!");
	  }
	};
	
	ParametricManager.prototype.refresh = function () {
	  this.solve();
	  this.notify();
	  this.viewer.refresh();
	};
	
	ParametricManager.prototype.add = function (constr) {
	  this.viewer.historyManager.checkpoint();
	  var subSystem = this._add(constr);
	  this.checkRedundancy(subSystem, constr);
	  this.refresh();
	};
	
	ParametricManager.prototype.addAll = function (constrs) {
	  for (var i = 0; i < constrs.length; i++) {
	    var subSystem = this._add(constrs[i]);
	    this.checkRedundancy(subSystem, constrs[i]);
	  }
	  this.refresh();
	};
	
	ParametricManager.prototype.remove = function (constr) {
	  this.viewer.historyManager.checkpoint();
	  for (var j = 0; j < this.subSystems.length; j++) {
	    var sub = this.subSystems[j];
	    for (var i = 0; i < sub.constraints.length; ++i) {
	      var p = sub.constraints[i];
	      if (p === constr) {
	        sub.constraints.splice(i, 1);
	        if (p.NAME === 'coi') {
	          this.unlinkObjects(p.a, p.b);
	        }
	        break;
	      }
	    }
	  }
	  this.refresh();
	};
	
	ParametricManager.prototype.removeConstraintsByObj = function (obj) {
	  var ownedParams = [];
	  obj.collectParams(ownedParams);
	  this.removeConstraintsByParams(ownedParams);
	};
	
	ParametricManager.prototype.removeConstraintsByParams = function (ownedParams) {
	  for (var s = 0; s < this.subSystems.length; s++) {
	    var toRemove = [];
	    var sub = this.subSystems[s];
	    var i;
	    for (i = 0; i < sub.constraints.length; ++i) {
	      var sdataArr = sub.constraints[i].getSolveData(this.constantResolver);
	      MAIN: for (var j = 0; j < sdataArr.length; j++) {
	        var sdata = sdataArr[j];
	        var params = sdata[1];
	        for (var oi = 0; oi < ownedParams.length; ++oi) {
	          for (var k = 0; k < params.length; ++k) {
	            if (ownedParams[oi].id === params[k].id) {
	              toRemove.push(i);
	              break MAIN;
	            }
	          }
	        }
	      }
	    }
	    toRemove.sort();
	
	    for (i = toRemove.length - 1; i >= 0; --i) {
	      sub.constraints.splice(toRemove[i], 1);
	    }
	  }
	
	  this.notify();
	};
	
	ParametricManager.prototype.lock = function (objs) {
	  var p = fetch.points(objs);
	  for (var i = 0; i < p.length; ++i) {
	    this._add(new Constraints.Lock(p[i], { x: p[i].x, y: p[i].y }));
	  }
	  this.refresh();
	};
	
	ParametricManager.prototype.vertical = function (objs) {
	  this.addAll(fetch.lines(objs).map(function (line) {
	    return new Constraints.Vertical(line);
	  }));
	};
	
	ParametricManager.prototype.horizontal = function (objs) {
	  this.addAll(fetch.lines(objs).map(function (line) {
	    return new Constraints.Horizontal(line);
	  }));
	};
	
	ParametricManager.prototype.parallel = function (objs) {
	  var lines = fetch.lines(objs);
	  var constraints = [];
	  for (var i = 1; i < lines.length; i++) {
	    constraints.push(new Constraints.Parallel(lines[i - 1], lines[i]));
	  }
	  this.addAll(constraints);
	};
	
	ParametricManager.prototype.perpendicular = function (objs) {
	  var lines = fetch.twoLines(objs);
	  this.add(new Constraints.Perpendicular(lines[0], lines[1]));
	};
	
	ParametricManager.prototype.lockConvex = function (objs, warnCallback) {
	  var lines = fetch.twoLines(objs);
	  var l1 = lines[0];
	  var l2 = lines[1];
	  var pts = [l1.a, l1.b, l2.a, l2.b];
	  function isLinked(p1, p2) {
	    for (var i = 0; i < p1.linked.length; ++i) {
	      if (p1.linked[i].id === p2.id) {
	        return true;
	      }
	    }
	    return false;
	  }
	
	  function swap(arr, i1, i2) {
	    var _ = arr[i1];
	    arr[i1] = arr[i2];
	    arr[i2] = _;
	  }
	
	  if (isLinked(pts[0], pts[2])) {
	    swap(pts, 0, 1);
	  } else if (isLinked(pts[0], pts[3])) {
	    swap(pts, 0, 1);
	    swap(pts, 2, 3);
	  } else if (isLinked(pts[1], pts[3])) {
	    swap(pts, 2, 3);
	  } else if (isLinked(pts[1], pts[2])) {
	    //we are good
	  } else {
	    warnCallback("Lines must be connected");
	    return;
	  }
	
	  var c = pts[0];
	  var a = pts[1];
	  var t = pts[3];
	
	  // ||ac x at|| > 0 
	  var crossNorma = (c.x - a.x) * (t.y - a.y) - (c.y - a.y) * (t.x - a.x);
	
	  if (crossNorma < 0) {
	    var _ = c;
	    c = t;
	    t = _;
	  }
	
	  this.add(new Constraints.LockConvex(c, a, t));
	};
	
	ParametricManager.prototype.tangent = function (objs) {
	  var ellipses = fetch.generic(objs, ['TCAD.TWO.Ellipse', 'TCAD.TWO.EllipticalArc'], 0);
	  var lines = fetch.generic(objs, ['TCAD.TWO.Segment'], 1);
	  if (ellipses.length > 0) {
	    this.add(new Constraints.EllipseTangent(lines[0], ellipses[0]));
	  } else {
	    var arcs = fetch.generic(objs, ['TCAD.TWO.Arc', 'TCAD.TWO.Circle'], 1);
	    this.add(new Constraints.Tangent(arcs[0], lines[0]));
	  }
	};
	
	ParametricManager.prototype.rr = function (arcs) {
	  var prev = arcs[0];
	  for (var i = 1; i < arcs.length; ++i) {
	    this._add(new Constraints.RR(prev, arcs[i]));
	    prev = arcs[i];
	  }
	  this.refresh();
	};
	
	ParametricManager.prototype.ll = function (lines) {
	  var prev = lines[0];
	  for (var i = 1; i < lines.length; ++i) {
	    this._add(new Constraints.LL(prev, lines[i]));
	    prev = lines[i];
	  }
	  this.refresh();
	};
	
	ParametricManager.prototype.entityEquality = function (objs) {
	  var arcs = fetch.generic(objs, ['TCAD.TWO.Arc', 'TCAD.TWO.Circle'], 0);
	  var lines = fetch.generic(objs, ['TCAD.TWO.Segment'], 0);
	  if (arcs.length > 0) this.rr(arcs);
	  if (lines.length > 0) this.ll(lines);
	};
	
	ParametricManager.prototype.p2lDistance = function (objs, promptCallback) {
	  var pl = fetch.pointAndLine(objs);
	
	  var target = pl[0];
	  var segment = pl[1];
	
	  var ex = new _vector2.default(-(segment.b.y - segment.a.y), segment.b.x - segment.a.x).normalize();
	  var distance = Math.abs(ex.dot(new _vector2.default(segment.a.x - target.x, segment.a.y - target.y)));
	
	  var promptDistance = utils.askNumber(Constraints.P2LDistance.prototype.SettableFields.d, distance.toFixed(2), promptCallback, this.constantResolver);
	
	  if (promptDistance != null) {
	    this.add(new Constraints.P2LDistance(target, segment, promptDistance));
	  }
	};
	
	ParametricManager.prototype.pointInMiddle = function (objs) {
	  var pl = fetch.pointAndLine(objs);
	  this.add(new Constraints.PointInMiddle(pl[0], pl[1]));
	};
	
	ParametricManager.prototype.symmetry = function (objs) {
	  var pl = fetch.pointAndLine(objs);
	  this.add(new Constraints.Symmetry(pl[0], pl[1]));
	};
	
	ParametricManager.prototype.pointOnArc = function (objs) {
	  var points = fetch.generic(objs, ['TCAD.TWO.EndPoint'], 1);
	  var arcs = fetch.generic(objs, ['TCAD.TWO.Arc', 'TCAD.TWO.Circle', 'TCAD.TWO.Ellipse', 'TCAD.TWO.EllipticalArc'], 1);
	  var arc = arcs[0];
	  if (arc._class == 'TCAD.TWO.Ellipse' || arc._class == 'TCAD.TWO.EllipticalArc') {
	    this.add(new Constraints.PointOnEllipse(points[0], arc));
	  } else {
	    this.add(new Constraints.PointOnArc(points[0], arc));
	  }
	};
	
	ParametricManager.prototype.pointOnLine = function (objs) {
	  var pl = fetch.pointAndLine(objs);
	  var target = pl[0];
	  var segment = pl[1];
	  this.add(new Constraints.PointOnLine(target, segment));
	};
	
	ParametricManager.prototype.llAngle = function (objs, promptCallback) {
	  var lines = fetch.generic(objs, 'TCAD.TWO.Segment', 2);
	  var l1 = lines[0];
	  var l2 = lines[1];
	
	  var points = [l1.a, l1.b, l2.a, l2.b];
	
	  if (l1.b.x < l1.a.x) {
	    points[0] = l1.b;
	    points[1] = l1.a;
	  }
	
	  if (l2.b.x < l2.a.x) {
	    points[2] = l2.b;
	    points[3] = l2.a;
	  }
	
	  var dx1 = points[1].x - points[0].x;
	  var dy1 = points[1].y - points[0].y;
	  var dx2 = points[3].x - points[2].x;
	  var dy2 = points[3].y - points[2].y;
	
	  var angle = Math.atan2(dy2, dx2) - Math.atan2(dy1, dx1);
	  angle *= 1 / Math.PI * 180;
	  angle = utils.askNumber(Constraints.Angle.prototype.SettableFields.angle, angle.toFixed(2), promptCallback, this.constantResolver);
	  if (angle === null) return;
	  this.add(new Constraints.Angle(points[0], points[1], points[2], points[3], angle));
	};
	
	ParametricManager.prototype.p2pDistance = function (objs, promptCallback) {
	  var p = fetch.twoPoints(objs);
	  var distance = new _vector2.default(p[1].x - p[0].x, p[1].y - p[0].y).length();
	  var promptDistance = utils.askNumber(Constraints.P2PDistance.prototype.SettableFields.d, distance.toFixed(2), promptCallback, this.constantResolver);
	
	  if (promptDistance != null) {
	    this.add(new Constraints.P2PDistance(p[0], p[1], promptDistance));
	  }
	};
	
	ParametricManager.prototype.radius = function (objs, promptCallback) {
	  var arcs = fetch.arkCirc(objs, 1);
	  var radius = arcs[0].r.get();
	  var promptDistance = utils.askNumber(Constraints.Radius.prototype.SettableFields.d, radius.toFixed(2), promptCallback, this.constantResolver);
	  if (promptDistance != null) {
	    for (var i = 0; i < arcs.length; ++i) {
	      this._add(new Constraints.Radius(arcs[i], promptDistance));
	    }
	    this.refresh();
	  }
	};
	
	ParametricManager.prototype._linkObjects = function (objs) {
	  var i;
	  var masterIdx = -1;
	  for (i = 0; i < objs.length; ++i) {
	    if (ParametricManager.isAux(objs[i])) {
	      if (masterIdx !== -1) {
	        throw "not allowed to have a coincident constraint between two or more auxiliary objects";
	      }
	      masterIdx = i;
	    }
	  }
	  if (masterIdx === -1) masterIdx = objs.length - 1;
	
	  for (i = 0; i < objs.length; ++i) {
	    if (i === masterIdx) continue;
	    objs[i].x = objs[masterIdx].x;
	    objs[i].y = objs[masterIdx].y;
	    var c = new Constraints.Coincident(objs[i], objs[masterIdx]);
	    this._add(c);
	  }
	};
	
	ParametricManager.prototype.linkObjects = function (objs) {
	  this._linkObjects(objs);
	  this.notify();
	};
	
	ParametricManager.prototype.unlinkObjects = function (a, b) {
	
	  function _unlink(a, b) {
	    for (var i = 0; i < a.linked.length; ++i) {
	      var obj = a.linked[i];
	      if (obj.id === b.id) {
	        a.linked.splice(i, 1);
	        break;
	      }
	    }
	  }
	  _unlink(a, b);
	  _unlink(b, a);
	};
	
	ParametricManager.prototype.findCoincidentConstraint = function (point1, point2) {
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = this.subSystems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var subSys = _step.value;
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        for (var _iterator2 = subSys.constraints[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var c = _step2.value;
	
	          if (c.NAME === 'coi' && (c.a.id === point1.id && c.b.id === point2.id || c.b.id === point1.id && c.a.id === point2.id)) {
	            return c;
	          }
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  return null;
	};
	
	ParametricManager.prototype.coincident = function (objs) {
	  if (objs.length == 0) return;
	  this.linkObjects(objs);
	  this.solve();
	  this.viewer.refresh();
	};
	
	ParametricManager.prototype.getSolveData = function () {
	  var sdata = [];
	  for (var i = 0; i < this.subSystems.length; i++) {
	    this.__getSolveData(this.subSystems[i].constraints, sdata);
	  }
	  return sdata;
	};
	
	ParametricManager.prototype.__getSolveData = function (constraints, out) {
	  for (var i = 0; i < constraints.length; ++i) {
	    var constraint = constraints[i];
	    var data = constraint.getSolveData(this.constantResolver);
	    for (var j = 0; j < data.length; ++j) {
	      data[j].push(constraint.reducible !== undefined);
	      out.push(data[j]);
	    }
	  }
	  return out;
	};
	
	ParametricManager.prototype.solve = function (lock, extraConstraints, disabledObjects) {
	  var solver = this.prepare(lock, extraConstraints, disabledObjects);
	  solver.solve(false);
	  solver.sync();
	};
	
	ParametricManager.prototype.prepare = function (locked, extraConstraints, disabledObjects) {
	  return this._prepare(locked, this.subSystems, extraConstraints, disabledObjects);
	};
	
	ParametricManager.prototype._prepare = function (locked, subSystems, extraConstraints, disabledObjects) {
	  var solvers = [];
	  for (var i = 0; i < subSystems.length; i++) {
	    solvers.push(this.prepareForSubSystem(locked, subSystems[i].constraints, extraConstraints, disabledObjects));
	  }
	  if (subSystems.length == 0 && locked && locked.length != 0) {
	    solvers.push(this.prepareForSubSystem(locked, [], extraConstraints, disabledObjects));
	  }
	  return {
	    solvers: solvers,
	
	    solve: function solve(rough) {
	      for (var i = 0; i < solvers.length; i++) {
	        var alg = i < subSystems.length ? subSystems[i].alg : 1;
	        var res = solvers[i].solve(rough, alg);
	        if (res.returnCode !== 1) {
	          alg = alg == 1 ? 2 : 1;
	          //if (solvers[i].solve(rough, alg).returnCode == 1) {
	          //subSystems[i].alg = alg;
	          //}
	        }
	      }
	    },
	
	    sync: function sync() {
	      for (var i = 0; i < solvers.length; i++) {
	        solvers[i].sync();
	      }
	    },
	
	    updateParameter: function updateParameter(p) {
	      for (var i = 0; i < solvers.length; i++) {
	        solvers[i].updateParameter(p);
	      }
	    },
	
	    updateLock: function updateLock(values) {
	      for (var i = 0; i < solvers.length; i++) {
	        solvers[i].updateLock(values);
	      }
	    }
	  };
	};
	
	ParametricManager.isAux = function (obj, disabledObjects) {
	  while (!!obj) {
	    if (!!obj.aux || disabledObjects !== undefined && disabledObjects.has(obj)) {
	      return true;
	    }
	    obj = obj.parent;
	  }
	  return false;
	};
	
	ParametricManager.fetchAuxParams = function (system, auxParams, auxDict, disabledObjects) {
	  disabledObjects = disabledObjects != undefined ? new Set(disabledObjects) : undefined;
	  for (var i = 0; i < system.length; ++i) {
	    for (var p = 0; p < system[i][1].length; ++p) {
	      var parameter = system[i][1][p];
	      if (parameter.obj !== undefined) {
	        if (ParametricManager.isAux(parameter.obj, disabledObjects)) {
	          if (auxDict[parameter.id] === undefined) {
	            auxDict[parameter.id] = parameter;
	            auxParams.push(parameter);
	          }
	        }
	      }
	    }
	  }
	};
	
	ParametricManager.__toId = function (v) {
	  return v.id;
	};
	
	ParametricManager.reduceSystem = function (system, readOnlyParams) {
	
	  var info = {
	    idToParam: {},
	    linkedParams: [],
	    reducedConstraints: {},
	    reducedParams: {}
	  };
	
	  var links = [];
	  function Link(a, b, constr) {
	    this.a = a;
	    this.b = b;
	    this.constr = constr;
	    this.invalid = false;
	    this.processed = false;
	  }
	
	  var c,
	      pi,
	      paramToConstraints = {};
	  for (i = 0; i < system.length; ++i) {
	    c = system[i];
	    if (c[3] !== true) {
	      for (pi = 0; pi < c[1].length; pi++) {
	        var param = c[1][pi];
	        var paramConstrs = paramToConstraints[param.id];
	        if (paramConstrs === undefined) {
	          paramConstrs = [];
	          paramToConstraints[param.id] = paramConstrs;
	        }
	        paramConstrs.push(i);
	      }
	    }
	  }
	
	  for (i = 0; i < system.length; ++i) {
	    c = system[i];
	    if (c[3] === true) {
	      //Reduce flag
	      var cp1 = c[1][0];
	      var cp2 = c[1][1];
	      links.push(new Link(cp1, cp2, i));
	    }
	  }
	  function intersect(array1, array2) {
	    if (!array1 || !array2) return false;
	    return array1.filter(function (n) {
	      return array2.indexOf(n) != -1;
	    }).length != 0;
	  }
	
	  function shared(param1, param2) {
	    if (param1 == param2) return false;
	    var assoc0 = paramToConstraints[param1];
	    var assoc1 = paramToConstraints[param2];
	    return intersect(assoc0, assoc1);
	  }
	
	  var linkTuples = [];
	
	  function mergeLinks(startIndex, into) {
	    var linkI = links[startIndex];
	    if (linkI.processed) return;
	    linkI.processed = true;
	    into.push(linkI);
	    for (var j = startIndex + 1; j < links.length; j++) {
	      var linkJ = links[j];
	      if (linkI.a.id == linkJ.a.id || linkI.a.id == linkJ.b.id || linkI.b.id == linkJ.a.id || linkI.b.id == linkJ.b.id) {
	        mergeLinks(j, into);
	      }
	    }
	  }
	  for (i = 0; i < links.length; i++) {
	    if (links[i].processed) continue;
	    var linkTuple = [];
	    linkTuples.push(linkTuple);
	    mergeLinks(i, linkTuple);
	  }
	
	  function resolveConflicts() {
	    for (var i = 0; i < linkTuples.length; i++) {
	      var tuple = linkTuples[i];
	
	      for (var j = 0; j < tuple.length; j++) {
	        var linkA = tuple[j];
	        if (linkA.invalid) continue;
	        if (shared(linkA.a.id, linkA.b.id)) {
	          linkA.invalid = true;
	          continue;
	        }
	        for (var k = j + 1; k < tuple.length; k++) {
	          var linkB = tuple[k];
	          if (shared(linkA.a.id, linkB.a.id) || shared(linkA.a.id, linkB.b.id) || shared(linkA.b.id, linkB.a.id) || shared(linkA.b.id, linkB.b.id)) {
	            linkB.invalid = true;
	          }
	        }
	      }
	    }
	  }
	  resolveConflicts();
	
	  function _merge(arr1, arr2) {
	    for (var i = 0; i < arr2.length; ++i) {
	      if (arr1.indexOf(arr2[i]) < 0) {
	        arr1.push(arr2[i]);
	      }
	    }
	  }
	
	  function linksToTuples(linkTuples) {
	    var tuples = [];
	    for (var i = 0; i < linkTuples.length; i++) {
	      var linkTuple = linkTuples[i];
	      var tuple = [];
	      tuples.push(tuple);
	      for (var j = 0; j < linkTuple.length; j++) {
	        var link = linkTuple[j];
	        if (!link.invalid) {
	          _merge(tuple, [link.a.id, link.b.id]);
	          info.reducedConstraints[link.constr] = true;
	          info.idToParam[link.a.id] = link.a;
	          info.idToParam[link.b.id] = link.b;
	        }
	      }
	    }
	    return tuples;
	  }
	  var tuples = linksToTuples(linkTuples);
	
	  for (var i = 0; i < tuples.length; ++i) {
	    var tuple = tuples[i];
	    info.linkedParams.push(tuple);
	    for (var mi = 0; mi < readOnlyParams.length; ++mi) {
	      var masterParam = readOnlyParams[mi];
	      var masterIdx = tuple.indexOf(masterParam.id);
	      if (masterIdx >= 0) {
	        var tmp = tuple[0];
	        tuple[0] = tuple[masterIdx];
	        tuple[masterIdx] = tmp;
	        break;
	      }
	    }
	  }
	
	  for (var ei = 0; ei < info.linkedParams.length; ++ei) {
	    var master = info.linkedParams[ei][0];
	    for (i = 1; i < info.linkedParams[ei].length; ++i) {
	      info.reducedParams[info.linkedParams[ei][i]] = master;
	    }
	  }
	  return info;
	};
	
	ParametricManager.prototype.prepareForSubSystem = function (locked, subSystemConstraints, extraConstraints, disabledObjects) {
	
	  locked = locked || [];
	
	  var constrs = [];
	  var solverParamsDict = {};
	  var system = [];
	  var auxParams = [];
	  var auxDict = {};
	
	  this.__getSolveData(subSystemConstraints, system);
	  if (!!extraConstraints) this.__getSolveData(extraConstraints, system);
	
	  ParametricManager.fetchAuxParams(system, auxParams, auxDict, disabledObjects);
	  var readOnlyParams = auxParams.concat(locked);
	  var reduceInfo = ParametricManager.reduceSystem(system, readOnlyParams);
	
	  function getSolverParam(p) {
	    var master = reduceInfo.reducedParams[p.id];
	    if (master !== undefined) {
	      p = reduceInfo.idToParam[master];
	    }
	    var _p = solverParamsDict[p.id];
	    if (_p === undefined) {
	      if (p.__cachedParam__ === undefined) {
	        _p = new _solver.Param(p.id, p.get());
	        p.__cachedParam__ = _p;
	      } else {
	        _p = p.__cachedParam__;
	        _p.reset(p.get());
	      }
	
	      _p._backingParam = p;
	      solverParamsDict[p.id] = _p;
	    }
	    return _p;
	  }
	
	  (function pickupAuxiliaryInfoFromSlaves() {
	    for (var i = 0; i < reduceInfo.linkedParams.length; ++i) {
	      var linkedParams = reduceInfo.linkedParams[i];
	      var master = linkedParams[0];
	      if (auxDict[master] !== undefined) continue;
	      for (var j = 1; j < linkedParams.length; j++) {
	        var slave = linkedParams[j];
	        if (auxDict[slave] !== undefined) {
	          auxDict[master] = true;
	          break;
	        }
	      }
	    }
	  })();
	
	  for (var i = 0; i < system.length; ++i) {
	
	    var sdata = system[i];
	    var params = [];
	
	    for (var p = 0; p < sdata[1].length; ++p) {
	      var param = sdata[1][p];
	      var solverParam = getSolverParam(param);
	      solverParam.aux = auxDict[param.id] !== undefined;
	      params.push(solverParam);
	    }
	    if (reduceInfo.reducedConstraints[i] === true) continue;
	
	    var _constr = (0, _constraints.createByConstraintName)(sdata[0], params, sdata[2]);
	    constrs.push(_constr);
	  }
	
	  var lockedSolverParams = [];
	  for (var _p2 = 0; _p2 < locked.length; ++_p2) {
	    lockedSolverParams[_p2] = getSolverParam(locked[_p2]);
	  }
	
	  var solver = (0, _solver.prepare)(constrs, lockedSolverParams);
	  function solve(rough, alg) {
	    return solver.solveSystem(rough, alg);
	  }
	
	  var viewer = this.viewer;
	  function sync() {
	    for (var paramId in solverParamsDict) {
	      var solverParam = solverParamsDict[paramId];
	      if (!!solverParam._backingParam.aux) continue;
	      solverParam._backingParam.set(solverParam.get());
	    }
	
	    //Make sure all coincident constraints are equal
	    for (var ei = 0; ei < reduceInfo.linkedParams.length; ++ei) {
	      var master = reduceInfo.idToParam[reduceInfo.linkedParams[ei][0]];
	      for (var i = 1; i < reduceInfo.linkedParams[ei].length; ++i) {
	        var slave = reduceInfo.idToParam[reduceInfo.linkedParams[ei][i]];
	        slave.set(master.get());
	      }
	    }
	    viewer.equalizeLinkedEndpoints();
	  }
	
	  function updateParameter(p) {
	    getSolverParam(p).set(p.get());
	  }
	
	  solver.solve = solve;
	  solver.sync = sync;
	  solver.updateParameter = updateParameter;
	  return solver;
	};
	
	Constraints.ParentsCollector = function () {
	  this.parents = [];
	  var parents = this.parents;
	  var index = {};
	  function add(obj) {
	    if (index[obj.id] === undefined) {
	      index[obj.id] = obj;
	      parents.push(obj);
	    }
	  }
	  this.check = function (obj) {
	    if (obj.parent !== null) {
	      add(obj.parent);
	    } else {
	      add(obj);
	    }
	  };
	};
	
	Constraints.Factory = {};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.Coincident = function (a, b) {
	  this.a = a;
	  this.b = b;
	  a.linked.push(b);
	  b.linked.push(a);
	};
	
	Constraints.Coincident.prototype.NAME = 'coi';
	Constraints.Coincident.prototype.UI_NAME = 'Coincident';
	Constraints.Coincident.prototype.reducible = true;
	
	Constraints.Coincident.prototype.getSolveData = function () {
	  return [['equal', [this.a._x, this.b._x], []], ['equal', [this.a._y, this.b._y], []]];
	};
	
	Constraints.Coincident.prototype.serialize = function () {
	  return [this.NAME, [this.a.id, this.b.id]];
	};
	
	Constraints.Factory[Constraints.Coincident.prototype.NAME] = function (refs, data) {
	  return new Constraints.Coincident(refs(data[0]), refs(data[1]));
	};
	
	Constraints.Coincident.prototype.getObjects = function () {
	  return [this.a, this.b];
	};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.RadiusOffset = function (arc1, arc2, offset) {
	  this.arc1 = arc1;
	  this.arc2 = arc2;
	  this.offset = offset;
	};
	
	Constraints.RadiusOffset.prototype.NAME = 'RadiusOffset';
	Constraints.RadiusOffset.prototype.UI_NAME = 'Radius Offset';
	
	Constraints.RadiusOffset.prototype.getSolveData = function (resolver) {
	  return [['Diff', [this.arc1.r, this.arc2.r], [resolver(this.offset)]]];
	};
	
	Constraints.RadiusOffset.prototype.serialize = function () {
	  return [this.NAME, [this.arc1.id, this.arc2.id, this.offset]];
	};
	
	Constraints.Factory[Constraints.RadiusOffset.prototype.NAME] = function (refs, data) {
	  return new Constraints.RadiusOffset(refs(data[0]), refs(data[1]), data[2]);
	};
	
	Constraints.RadiusOffset.prototype.getObjects = function () {
	  return [this.arc1, this.arc2];
	};
	
	Constraints.RadiusOffset.prototype.SettableFields = { 'offset': "Enter the offset" };
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.Lock = function (p, c) {
	  this.p = p;
	  this.c = c;
	};
	
	Constraints.Lock.prototype.NAME = 'lock';
	Constraints.Lock.prototype.UI_NAME = 'Lock';
	
	Constraints.Lock.prototype.getSolveData = function () {
	  return [['equalsTo', [this.p._x], [this.c.x]], ['equalsTo', [this.p._y], [this.c.y]]];
	};
	
	Constraints.Lock.prototype.serialize = function () {
	  return [this.NAME, [this.p.id, this.c]];
	};
	
	Constraints.Factory[Constraints.Lock.prototype.NAME] = function (refs, data) {
	  return new Constraints.Lock(refs(data[0]), data[1]);
	};
	
	Constraints.Lock.prototype.getObjects = function () {
	  return [this.p];
	};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.Parallel = function (l1, l2) {
	  this.l1 = l1;
	  this.l2 = l2;
	};
	
	Constraints.Parallel.prototype.NAME = 'parallel';
	Constraints.Parallel.prototype.UI_NAME = 'Parallel';
	
	Constraints.Parallel.prototype.getSolveData = function () {
	  var params = [];
	  this.l1.collectParams(params);
	  this.l2.collectParams(params);
	  return [[this.NAME, params, []]];
	};
	
	Constraints.Parallel.prototype.serialize = function () {
	  return [this.NAME, [this.l1.id, this.l2.id]];
	};
	
	Constraints.Factory[Constraints.Parallel.prototype.NAME] = function (refs, data) {
	  return new Constraints.Parallel(refs(data[0]), refs(data[1]));
	};
	
	Constraints.Parallel.prototype.getObjects = function () {
	  return [this.l1, this.l2];
	};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.Perpendicular = function (l1, l2) {
	  this.l1 = l1;
	  this.l2 = l2;
	};
	
	Constraints.Perpendicular.prototype.NAME = 'perpendicular';
	Constraints.Perpendicular.prototype.UI_NAME = 'Perpendicular';
	
	Constraints.Perpendicular.prototype.getSolveData = function () {
	  var params = [];
	  this.l1.collectParams(params);
	  this.l2.collectParams(params);
	  return [[this.NAME, params, []]];
	};
	
	Constraints.Perpendicular.prototype.serialize = function () {
	  return [this.NAME, [this.l1.id, this.l2.id]];
	};
	
	Constraints.Factory[Constraints.Perpendicular.prototype.NAME] = function (refs, data) {
	  return new Constraints.Perpendicular(refs(data[0]), refs(data[1]));
	};
	
	Constraints.Perpendicular.prototype.getObjects = function () {
	  return [this.l1, this.l2];
	};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.P2LDistanceSigned = function (p, a, b, d) {
	  this.p = p;
	  this.a = a;
	  this.b = b;
	  this.d = d;
	};
	
	Constraints.P2LDistanceSigned.prototype.NAME = 'P2LDistanceSigned';
	Constraints.P2LDistanceSigned.prototype.UI_NAME = 'Distance P & L';
	
	Constraints.P2LDistanceSigned.prototype.getSolveData = function (resolver) {
	  var params = [];
	  this.p.collectParams(params);
	  this.a.collectParams(params);
	  this.b.collectParams(params);
	  return [[this.NAME, params, [resolver(this.d)]]];
	};
	
	Constraints.P2LDistanceSigned.prototype.serialize = function () {
	  return [this.NAME, [this.p.id, this.a.id, this.b.id, this.d]];
	};
	
	Constraints.Factory[Constraints.P2LDistanceSigned.prototype.NAME] = function (refs, data) {
	  return new Constraints.P2LDistanceSigned(refs(data[0]), refs(data[1]), refs(data[2]), data[3]);
	};
	
	Constraints.P2LDistanceSigned.prototype.getObjects = function () {
	  var collector = new Constraints.ParentsCollector();
	  collector.check(this.a);
	  collector.check(this.b);
	  collector.parents.push(this.p);
	  return collector.parents;
	};
	
	Constraints.P2LDistanceSigned.prototype.SettableFields = { 'd': "Enter the distance" };
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.P2LDistance = function (p, l, d) {
	  this.p = p;
	  this.l = l;
	  this.d = d;
	};
	
	Constraints.P2LDistance.prototype.NAME = 'P2LDistance';
	Constraints.P2LDistance.prototype.UI_NAME = 'Distance P & L';
	
	Constraints.P2LDistance.prototype.getSolveData = function (resolver) {
	  var params = [];
	  this.p.collectParams(params);
	  this.l.collectParams(params);
	  return [[this.NAME, params, [resolver(this.d)]]];
	};
	
	Constraints.P2LDistance.prototype.serialize = function () {
	  return [this.NAME, [this.p.id, this.l.id, this.d]];
	};
	
	Constraints.Factory[Constraints.P2LDistance.prototype.NAME] = function (refs, data) {
	  return new Constraints.P2LDistance(refs(data[0]), refs(data[1]), data[2]);
	};
	
	Constraints.P2LDistance.prototype.getObjects = function () {
	  return [this.p, this.l];
	};
	
	Constraints.P2LDistance.prototype.SettableFields = { 'd': "Enter the distance" };
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.MinLength = function (a, b, min) {
	  this.a = a;
	  this.b = b;
	  this.min = min;
	};
	
	Constraints.MinLength.prototype.aux = true;
	Constraints.MinLength.prototype.NAME = 'MinLength';
	Constraints.MinLength.prototype.UI_NAME = 'MinLength';
	
	Constraints.MinLength.prototype.getSolveData = function () {
	  var params = [];
	  this.a.collectParams(params);
	  this.b.collectParams(params);
	  return [[this.NAME, params, [this.min]]];
	};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.P2LDistanceV = function (p, l, d) {
	  this.p = p;
	  this.l = l;
	  this.d = d;
	};
	
	Constraints.P2LDistanceV.prototype.aux = true;
	Constraints.P2LDistanceV.prototype.NAME = 'P2LDistanceV';
	Constraints.P2LDistanceV.prototype.UI_NAME = 'Distance P & L';
	
	Constraints.P2LDistanceV.prototype.getSolveData = function () {
	  var params = [];
	  this.p.collectParams(params);
	  this.l.collectParams(params);
	  params.push(this.d);
	  return [[this.NAME, params]];
	};
	
	// We don't serialize auxiliary constraints
	//
	//Constraints.P2LDistanceV.prototype.serialize = function() {
	//  return [this.NAME, [this.p.id, this.l.id, this.d.id]];
	//};
	//
	//Constraints.Factory[Constraints.P2LDistanceV.prototype.NAME] = function(refs, data) {
	//  return new Constraints.P2LDistanceV(refs(data[0]), refs(data[1]), refs(data[2]));
	//};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.P2PDistance = function (p1, p2, d) {
	  this.p1 = p1;
	  this.p2 = p2;
	  this.d = d;
	};
	
	Constraints.P2PDistance.prototype.NAME = 'P2PDistance';
	Constraints.P2PDistance.prototype.UI_NAME = 'Distance Points';
	
	Constraints.P2PDistance.prototype.getSolveData = function (resolver) {
	  var params = [];
	  this.p1.collectParams(params);
	  this.p2.collectParams(params);
	  return [[this.NAME, params, [resolver(this.d)]]];
	};
	
	Constraints.P2PDistance.prototype.serialize = function () {
	  return [this.NAME, [this.p1.id, this.p2.id, this.d]];
	};
	
	Constraints.Factory[Constraints.P2PDistance.prototype.NAME] = function (refs, data) {
	  return new Constraints.P2PDistance(refs(data[0]), refs(data[1]), data[2]);
	};
	
	Constraints.P2PDistance.prototype.getObjects = function () {
	  return [this.p1, this.p2];
	};
	
	Constraints.P2PDistance.prototype.SettableFields = { 'd': "Enter the distance" };
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.P2PDistanceV = function (p1, p2, d) {
	  this.p1 = p1;
	  this.p2 = p2;
	  this.d = d;
	};
	
	Constraints.P2PDistanceV.prototype.aux = true;
	Constraints.P2PDistanceV.prototype.NAME = 'P2PDistanceV';
	Constraints.P2PDistanceV.prototype.UI_NAME = 'Distance Points';
	
	Constraints.P2PDistanceV.prototype.getSolveData = function () {
	  var params = [];
	  this.p1.collectParams(params);
	  this.p2.collectParams(params);
	  params.push(this.d);
	  return [[this.NAME, params]];
	};
	
	// We don't serialize auxiliary constraints
	//
	//Constraints.P2PDistanceV.prototype.serialize = function() {
	//  return [this.NAME, [this.p1.id, this.p2.id, this.d.id]];
	//};
	//
	//Constraints.Factory[Constraints.P2PDistanceV.prototype.NAME] = function(refs, data) {
	//  return new Constraints.P2PDistanceV(refs(data[0]), refs(data[1]), refs(data[2]));
	//};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.GreaterThan = function (p, limit) {
	  this.p = p;
	  this.limit = limit;
	};
	
	Constraints.GreaterThan.prototype.aux = true;
	Constraints.GreaterThan.prototype.NAME = 'GreaterThan';
	Constraints.GreaterThan.prototype.UI_NAME = 'Greater Than';
	
	Constraints.GreaterThan.prototype.getSolveData = function () {
	  return [[this.NAME, [this.p], [this.limit]]];
	};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.Radius = function (arc, d) {
	  this.arc = arc;
	  this.d = d;
	};
	
	Constraints.Radius.prototype.NAME = 'Radius';
	Constraints.Radius.prototype.UI_NAME = 'Radius Value';
	
	Constraints.Radius.prototype.getSolveData = function (resolver) {
	  return [['equalsTo', [this.arc.r], [resolver(this.d)]]];
	};
	
	Constraints.Radius.prototype.serialize = function () {
	  return [this.NAME, [this.arc.id, this.d]];
	};
	
	Constraints.Factory[Constraints.Radius.prototype.NAME] = function (refs, data) {
	  return new Constraints.Radius(refs(data[0]), data[1]);
	};
	
	Constraints.Radius.prototype.getObjects = function () {
	  return [this.arc];
	};
	
	Constraints.Radius.prototype.SettableFields = { 'd': "Enter the radius value" };
	
	// ------------------------------------------------------------------------------------------------------------------ // 
	
	/** @constructor */
	Constraints.RR = function (arc1, arc2) {
	  this.arc1 = arc1;
	  this.arc2 = arc2;
	};
	
	Constraints.RR.prototype.NAME = 'RR';
	Constraints.RR.prototype.UI_NAME = 'Radius Equality';
	//Constraints.RR.prototype.reducible = true;
	
	
	Constraints.RR.prototype.getSolveData = function () {
	  return [['equal', [this.arc1.r, this.arc2.r], []]];
	};
	
	Constraints.RR.prototype.serialize = function () {
	  return [this.NAME, [this.arc1.id, this.arc2.id]];
	};
	
	Constraints.Factory[Constraints.RR.prototype.NAME] = function (refs, data) {
	  return new Constraints.RR(refs(data[0]), refs(data[1]));
	};
	
	Constraints.RR.prototype.getObjects = function () {
	  return [this.arc1, this.arc2];
	};
	
	// ------------------------------------------------------------------------------------------------------------------ // 
	
	/** @constructor */
	Constraints.LL = function (line1, line2) {
	  this.line1 = line1;
	  this.line2 = line2;
	  this.length = new _ref.Ref(math.distanceAB(line1.a, line1.b));
	};
	
	Constraints.LL.prototype.NAME = 'LL';
	Constraints.LL.prototype.UI_NAME = 'Lines Equality';
	
	Constraints.LL.prototype.getSolveData = function () {
	  var params1 = [];
	  var params2 = [];
	  this.line1.collectParams(params1);
	  this.line2.collectParams(params2);
	  params1.push(this.length);
	  params2.push(this.length);
	  return [['P2PDistanceV', params1, []], ['P2PDistanceV', params2, []]];
	};
	
	Constraints.LL.prototype.serialize = function () {
	  return [this.NAME, [this.line1.id, this.line2.id]];
	};
	
	Constraints.Factory[Constraints.LL.prototype.NAME] = function (refs, data) {
	  return new Constraints.LL(refs(data[0]), refs(data[1]));
	};
	
	Constraints.LL.prototype.getObjects = function () {
	  return [this.line1, this.line2];
	};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.Vertical = function (line) {
	  this.line = line;
	};
	
	Constraints.Vertical.prototype.NAME = 'Vertical';
	Constraints.Vertical.prototype.UI_NAME = 'Vertical';
	//Constraints.Vertical.prototype.reducible = true;
	
	Constraints.Vertical.prototype.getSolveData = function () {
	  return [['equal', [this.line.a._x, this.line.b._x], []]];
	};
	
	Constraints.Vertical.prototype.serialize = function () {
	  return [this.NAME, [this.line.id]];
	};
	
	Constraints.Factory[Constraints.Vertical.prototype.NAME] = function (refs, data) {
	  return new Constraints.Vertical(refs(data[0]));
	};
	
	Constraints.Vertical.prototype.getObjects = function () {
	  return [this.line];
	};
	
	// ------------------------------------------------------------------------------------------------------------------ // 
	
	/** @constructor */
	Constraints.Horizontal = function (line) {
	  this.line = line;
	};
	
	Constraints.Horizontal.prototype.NAME = 'Horizontal';
	Constraints.Horizontal.prototype.UI_NAME = 'Horizontal';
	//Constraints.Horizontal.prototype.reducible = true;
	
	Constraints.Horizontal.prototype.getSolveData = function () {
	  return [['equal', [this.line.a._y, this.line.b._y], []]];
	};
	
	Constraints.Horizontal.prototype.serialize = function () {
	  return [this.NAME, [this.line.id]];
	};
	
	Constraints.Factory[Constraints.Horizontal.prototype.NAME] = function (refs, data) {
	  return new Constraints.Horizontal(refs(data[0]));
	};
	
	Constraints.Horizontal.prototype.getObjects = function () {
	  return [this.line];
	};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.Tangent = function (arc, line) {
	  this.arc = arc;
	  this.line = line;
	};
	
	Constraints.Tangent.prototype.NAME = 'Tangent';
	Constraints.Tangent.prototype.UI_NAME = 'Tangent';
	
	Constraints.Tangent.prototype.getSolveData = function () {
	  var params = [];
	  this.arc.c.collectParams(params);
	  this.line.collectParams(params);
	  params.push(this.arc.r);
	  return [['P2LDistanceV', params, []]];
	};
	
	Constraints.Tangent.prototype.serialize = function () {
	  return [this.NAME, [this.arc.id, this.line.id]];
	};
	
	Constraints.Factory[Constraints.Tangent.prototype.NAME] = function (refs, data) {
	  return new Constraints.Tangent(refs(data[0]), refs(data[1]));
	};
	
	Constraints.Tangent.prototype.getObjects = function () {
	  return [this.arc, this.line];
	};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.PointOnLine = function (point, line) {
	  this.point = point;
	  this.line = line;
	};
	
	Constraints.PointOnLine.prototype.NAME = 'PointOnLine';
	Constraints.PointOnLine.prototype.UI_NAME = 'Point On Line';
	
	Constraints.PointOnLine.prototype.getSolveData = function () {
	  var params = [];
	  this.point.collectParams(params);
	  this.line.collectParams(params);
	  return [['P2LDistance', params, [0]]];
	};
	
	Constraints.PointOnLine.prototype.serialize = function () {
	  return [this.NAME, [this.point.id, this.line.id]];
	};
	
	Constraints.Factory[Constraints.PointOnLine.prototype.NAME] = function (refs, data) {
	  return new Constraints.PointOnLine(refs(data[0]), refs(data[1]));
	};
	
	Constraints.PointOnLine.prototype.getObjects = function () {
	  return [this.point, this.line];
	};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.PointOnArc = function (point, arc) {
	  this.point = point;
	  this.arc = arc;
	};
	
	Constraints.PointOnArc.prototype.NAME = 'PointOnArc';
	Constraints.PointOnArc.prototype.UI_NAME = 'Point On Arc';
	
	Constraints.PointOnArc.prototype.getSolveData = function () {
	  var params = [];
	  this.point.collectParams(params);
	  this.arc.c.collectParams(params);
	  params.push(this.arc.r);
	  return [['P2PDistanceV', params, []]];
	};
	
	Constraints.PointOnArc.prototype.serialize = function () {
	  return [this.NAME, [this.point.id, this.arc.id]];
	};
	
	Constraints.Factory[Constraints.PointOnArc.prototype.NAME] = function (refs, data) {
	  return new Constraints.PointOnArc(refs(data[0]), refs(data[1]));
	};
	
	Constraints.PointOnArc.prototype.getObjects = function () {
	  return [this.point, this.arc];
	};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.PointOnEllipseInternal = function (point, ellipse) {
	  this.point = point;
	  this.ellipse = ellipse;
	};
	
	Constraints.PointOnEllipseInternal.prototype.NAME = 'PointOnEllipseI';
	Constraints.PointOnEllipseInternal.prototype.UI_NAME = 'Point On Ellipse';
	Constraints.PointOnEllipseInternal.prototype.aux = true;
	
	Constraints.PointOnEllipseInternal.prototype.getSolveData = function () {
	  var params = [];
	  this.point.collectParams(params);
	  this.ellipse.ep1.collectParams(params);
	  this.ellipse.ep2.collectParams(params);
	  params.push(this.ellipse.r);
	  return [['PointOnEllipse', params, []]];
	};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.PointOnEllipse = function (point, ellipse) {
	  Constraints.PointOnEllipseInternal.call(this, point, ellipse);
	};
	
	Constraints.PointOnEllipse.prototype.NAME = 'PointOnEllipse';
	Constraints.PointOnEllipse.prototype.UI_NAME = 'Point On Ellipse';
	
	Constraints.PointOnEllipse.prototype.getSolveData = function () {
	  return Constraints.PointOnEllipseInternal.prototype.getSolveData.call(this);
	};
	
	Constraints.PointOnEllipse.prototype.serialize = function () {
	  return [this.NAME, [this.point.id, this.ellipse.id]];
	};
	
	Constraints.Factory[Constraints.PointOnEllipse.prototype.NAME] = function (refs, data) {
	  return new Constraints.PointOnEllipse(refs(data[0]), refs(data[1]));
	};
	
	Constraints.PointOnEllipse.prototype.getObjects = function () {
	  return [this.point, this.ellipse];
	};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.EllipseTangent = function (line, ellipse) {
	  this.line = line;
	  this.ellipse = ellipse;
	};
	
	Constraints.EllipseTangent.prototype.NAME = 'EllipseTangent';
	Constraints.EllipseTangent.prototype.UI_NAME = 'Tangent Ellipse';
	
	Constraints.EllipseTangent.prototype.getSolveData = function () {
	  var params = [];
	  this.line.collectParams(params);
	  this.ellipse.ep1.collectParams(params);
	  this.ellipse.ep2.collectParams(params);
	  params.push(this.ellipse.r);
	  return [['EllipseTangent', params, []]];
	};
	
	Constraints.EllipseTangent.prototype.serialize = function () {
	  return [this.NAME, [this.line.id, this.ellipse.id]];
	};
	
	Constraints.Factory[Constraints.EllipseTangent.prototype.NAME] = function (refs, data) {
	  return new Constraints.EllipseTangent(refs(data[0]), refs(data[1]));
	};
	
	Constraints.EllipseTangent.prototype.getObjects = function () {
	  return [this.line, this.ellipse];
	};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.PointInMiddle = function (point, line) {
	  this.point = point;
	  this.line = line;
	  this.length = new _ref.Ref(math.distanceAB(line.a, line.b) / 2);
	};
	
	Constraints.PointInMiddle.prototype.NAME = 'PointInMiddle';
	Constraints.PointInMiddle.prototype.UI_NAME = 'Point In the Middle';
	
	Constraints.PointInMiddle.prototype.getSolveData = function () {
	  var params1 = [];
	  var params2 = [];
	
	  this.line.a.collectParams(params1);
	  this.point.collectParams(params1);
	  params1.push(this.length);
	
	  this.line.b.collectParams(params2);
	  this.point.collectParams(params2);
	  params2.push(this.length);
	
	  return [['P2PDistanceV', params1, []], ['P2PDistanceV', params2, []]];
	};
	
	Constraints.PointInMiddle.prototype.serialize = function () {
	  return [this.NAME, [this.point.id, this.line.id]];
	};
	
	Constraints.Factory[Constraints.PointInMiddle.prototype.NAME] = function (refs, data) {
	  return new Constraints.PointInMiddle(refs(data[0]), refs(data[1]));
	};
	
	Constraints.PointInMiddle.prototype.getObjects = function () {
	  return [this.point, this.line];
	};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.Symmetry = function (point, line) {
	  this.point = point;
	  this.line = line;
	  this.length = new _ref.Ref(math.distanceAB(line.a, line.b) / 2);
	};
	
	Constraints.Symmetry.prototype.NAME = 'Symmetry';
	Constraints.Symmetry.prototype.UI_NAME = 'Symmetry';
	
	Constraints.Symmetry.prototype.getSolveData = function (resolver) {
	  var pointInMiddleData = Constraints.PointInMiddle.prototype.getSolveData.call(this, [resolver]);
	  var pointOnLineData = Constraints.PointOnLine.prototype.getSolveData.call(this, [resolver]);
	  return pointInMiddleData.concat(pointOnLineData);
	};
	
	Constraints.Symmetry.prototype.serialize = function () {
	  return [this.NAME, [this.point.id, this.line.id]];
	};
	
	Constraints.Factory[Constraints.Symmetry.prototype.NAME] = function (refs, data) {
	  return new Constraints.Symmetry(refs(data[0]), refs(data[1]));
	};
	
	Constraints.Symmetry.prototype.getObjects = function () {
	  return [this.point, this.line];
	};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.Angle = function (p1, p2, p3, p4, angle) {
	  this.p1 = p1;
	  this.p2 = p2;
	  this.p3 = p3;
	  this.p4 = p4;
	  this._angle = new _ref.Ref(0);
	  this.angle = angle;
	};
	
	Constraints.Angle.prototype.NAME = 'Angle';
	Constraints.Angle.prototype.UI_NAME = 'Lines Angle';
	
	Constraints.Angle.prototype.getSolveData = function (resolver) {
	  this._angle.set(resolver(this.angle) / 180 * Math.PI);
	  var params = [];
	  this.p1.collectParams(params);
	  this.p2.collectParams(params);
	  this.p3.collectParams(params);
	  this.p4.collectParams(params);
	  params.push(this._angle);
	  return [['angleConst', params, []]];
	};
	
	Constraints.Angle.prototype.serialize = function () {
	  return [this.NAME, [this.p1.id, this.p2.id, this.p3.id, this.p4.id, this.angle]];
	};
	
	Constraints.Factory[Constraints.Angle.prototype.NAME] = function (refs, data) {
	  return new Constraints.Angle(refs(data[0]), refs(data[1]), refs(data[2]), refs(data[3]), data[4]);
	};
	
	Constraints.Angle.prototype.getObjects = function () {
	  var collector = new Constraints.ParentsCollector();
	  collector.check(this.p1);
	  collector.check(this.p2);
	  collector.check(this.p3);
	  collector.check(this.p4);
	  return collector.parents;
	};
	
	Constraints.Angle.prototype.SettableFields = { 'angle': "Enter the angle value" };
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	/** @constructor */
	Constraints.LockConvex = function (c, a, t) {
	  this.c = c;
	  this.a = a;
	  this.t = t;
	};
	
	Constraints.LockConvex.prototype.NAME = 'LockConvex';
	Constraints.LockConvex.prototype.UI_NAME = 'Lock Convexity';
	
	Constraints.LockConvex.prototype.getSolveData = function () {
	  var params = [];
	  this.c.collectParams(params);
	  this.a.collectParams(params);
	  this.t.collectParams(params);
	  return [['LockConvex', params, []]];
	};
	
	Constraints.LockConvex.prototype.serialize = function () {
	  return [this.NAME, [this.c.id, this.a.id, this.t.id]];
	};
	
	Constraints.Factory[Constraints.LockConvex.prototype.NAME] = function (refs, data) {
	  return new Constraints.LockConvex(refs(data[0]), refs(data[1]), refs(data[2]));
	};
	
	Constraints.LockConvex.prototype.getObjects = function () {
	  var collector = new Constraints.ParentsCollector();
	  collector.check(this.c);
	  collector.check(this.a);
	  collector.check(this.t);
	  return collector.parents;
	};
	
	// ------------------------------------------------------------------------------------------------------------------ //
	
	exports.Constraints = Constraints;
	exports.ParametricManager = ParametricManager;

/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Ref = Ref;
	
	var _idGenerator = __webpack_require__(412);
	
	function Ref(value) {
	  this.id = _idGenerator.Generator.genID();
	  this.value = value;
	}
	
	Ref.prototype.set = function (value) {
	  this.value = value;
	};
	
	Ref.prototype.get = function () {
	  return this.value;
	};

/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.prepare = exports.Param = undefined;
	
	var _utils = __webpack_require__(330);
	
	var utils = _interopRequireWildcard(_utils);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	var _qr = __webpack_require__(418);
	
	var _qr2 = _interopRequireDefault(_qr);
	
	var _lm = __webpack_require__(419);
	
	var _lm2 = _interopRequireDefault(_lm);
	
	var _constraints = __webpack_require__(420);
	
	var _optim = __webpack_require__(421);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	/** @constructor */
	function Param(id, value, readOnly) {
	  this.reset(value);
	}
	
	Param.prototype.reset = function (value) {
	  this.set(value);
	  this.j = -1;
	  this.aux = false;
	};
	
	Param.prototype.set = function (value) {
	  if (this.aux) return;
	  this.value = value;
	};
	
	Param.prototype.get = function () {
	  return this.value;
	};
	
	Param.prototype.nop = function () {};
	
	/** @constructor */
	function System(constraints) {
	  this.constraints = constraints;
	  this.params = [];
	  for (var ci = 0; ci < constraints.length; ++ci) {
	    var c = constraints[ci];
	    for (var pi = 0; pi < c.params.length; ++pi) {
	      var p = c.params[pi];
	      if (p.j == -1) {
	        p.j = this.params.length;
	        this.params.push(p);
	      }
	    }
	  }
	}
	
	System.prototype.makeJacobian = function () {
	  var jacobi = [];
	  var i;
	  var j;
	  for (i = 0; i < this.constraints.length; i++) {
	    jacobi[i] = [];
	    for (j = 0; j < this.params.length; j++) {
	      jacobi[i][j] = 0;
	    }
	  }
	  for (i = 0; i < this.constraints.length; i++) {
	    var c = this.constraints[i];
	
	    var cParams = c.params;
	    var grad = [];
	    utils.fillArray(grad, 0, cParams.length, 0);
	    c.gradient(grad);
	
	    for (var p = 0; p < cParams.length; p++) {
	      var param = cParams[p];
	      j = param.j;
	      jacobi[i][j] = grad[p];
	    }
	  }
	  return jacobi;
	};
	
	System.prototype.fillJacobian = function (jacobi) {
	  for (var i = 0; i < this.constraints.length; i++) {
	    var c = this.constraints[i];
	
	    var cParams = c.params;
	    var grad = [];
	    utils.fillArray(grad, 0, cParams.length, 0);
	    c.gradient(grad);
	
	    for (var p = 0; p < cParams.length; p++) {
	      var param = cParams[p];
	      var j = param.j;
	      jacobi[i][j] = grad[p];
	    }
	  }
	  return jacobi;
	};
	
	System.prototype.calcResidual = function (r) {
	
	  var i = 0;
	  var err = 0.;
	
	  for (i = 0; i < this.constraints.length; i++) {
	    var c = this.constraints[i];
	    r[i] = c.error();
	    err += r[i] * r[i];
	  }
	
	  err *= 0.5;
	  return err;
	};
	
	System.prototype.calcGrad_ = function (out) {
	  var i;
	  for (i = 0; i < out.length || i < this.params.length; ++i) {
	    out[i][0] = 0;
	  }
	
	  for (i = 0; i < this.constraints.length; i++) {
	    var c = this.constraints[i];
	
	    var cParams = c.params;
	    var grad = [];
	    utils.fillArray(grad, 0, cParams.length, 0);
	    c.gradient(grad);
	
	    for (var p = 0; p < cParams.length; p++) {
	      var param = cParams[p];
	      var j = param.j;
	      out[j][0] += this.constraints[i].error() * grad[p]; // (10.4)
	    }
	  }
	};
	
	System.prototype.calcGrad = function (out) {
	  var i;
	  for (i = 0; i < out.length || i < this.params.length; ++i) {
	    out[i] = 0;
	  }
	
	  for (i = 0; i < this.constraints.length; i++) {
	    var c = this.constraints[i];
	
	    var cParams = c.params;
	    var grad = [];
	    utils.fillArray(grad, 0, cParams.length, 0);
	    for (var p = 0; p < cParams.length; p++) {
	      var param = cParams[p];
	      var j = param.j;
	      out[j] += this.constraints[i].error() * grad[p]; // (10.4) 
	    }
	  }
	};
	
	System.prototype.fillParams = function (out) {
	  for (var p = 0; p < this.params.length; p++) {
	    out[p] = this.params[p].get();
	  }
	};
	
	System.prototype.getParams = function () {
	  var out = [];
	  this.fillParams(out);
	  return out;
	};
	
	System.prototype.setParams = function (point) {
	  for (var p = 0; p < this.params.length; p++) {
	    this.params[p].set(point[p]);
	  }
	};
	
	System.prototype.error = function () {
	  var error = 0;
	  for (var i = 0; i < this.constraints.length; i++) {
	    error += Math.abs(this.constraints[i].error());
	  }
	  return error;
	};
	
	System.prototype.errorSquare = function () {
	  var error = 0;
	  for (var i = 0; i < this.constraints.length; i++) {
	    var t = this.constraints[i].error();
	    error += t * t;
	  }
	  return error * 0.5;
	};
	
	System.prototype.getValues = function () {
	  var values = [];
	  for (var i = 0; i < this.constraints.length; i++) {
	    values[i] = this.constraints[i].error();
	  }
	  return values;
	};
	
	function wrapAux(constrs) {
	  for (var i = 0; i < constrs.length; i++) {
	    var c = constrs[i];
	    var mask = [];
	    var needWrap = false;
	    for (var j = 0; j < c.params.length; j++) {
	      var param = c.params[j];
	      mask[j] = param.aux === true;
	      needWrap = needWrap || mask[j];
	    }
	    if (needWrap) {
	      constrs[i] = new _constraints.ConstantWrapper(c, mask);
	    }
	  }
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = constrs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var constr = _step.value;
	
	      if (constr.params.length == 0) {
	        return constrs.filter(function (c) {
	          return c.params.length != 0;
	        });
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  return constrs;
	}
	
	var lock2Equals2 = function lock2Equals2(constrs, locked) {
	  var _locked = [];
	  for (var i = 0; i < locked.length; ++i) {
	    _locked.push(new _constraints.EqualsTo([locked[i]], locked[i].get()));
	  }
	  return _locked;
	};
	
	var _diagnose = function _diagnose(sys) {
	  if (sys.constraints.length == 0 || sys.params.length == 0) {
	    return {
	      conflict: false,
	      dof: 0
	    };
	  }
	  var jacobian = sys.makeJacobian();
	  var qr = new _qr2.default(jacobian);
	  return {
	    conflict: sys.constraints.length > qr.rank,
	    dof: sys.params.length - qr.rank
	  };
	};
	
	var prepare = function prepare(constrs, locked) {
	
	  var simpleMode = true;
	  if (!simpleMode) {
	    var lockingConstrs = lock2Equals2(constrs, locked);
	    Array.prototype.push.apply(constrs, lockingConstrs);
	  }
	
	  constrs = wrapAux(constrs);
	  var sys = new System(constrs);
	
	  var model = function model(point) {
	    sys.setParams(point);
	    return sys.getValues();
	  };
	
	  var jacobian = function jacobian(point) {
	    sys.setParams(point);
	    return sys.makeJacobian();
	  };
	  var nullResult = {
	    evalCount: 0,
	    error: 0,
	    returnCode: 1
	  };
	
	  function solve(rough, alg) {
	    //if (simpleMode) return nullResult;
	    if (constrs.length == 0) return nullResult;
	    if (sys.params.length == 0) return nullResult;
	    switch (alg) {
	      case 2:
	        return solve_lm(sys, model, jacobian, rough);
	      case 1:
	      default:
	        return (0, _optim.dog_leg)(sys, rough);
	    }
	  }
	  var systemSolver = {
	    diagnose: function diagnose() {
	      return _diagnose(sys);
	    },
	    error: function error() {
	      return sys.error();
	    },
	    solveSystem: solve,
	    system: sys,
	    updateLock: function updateLock(values) {
	      for (var i = 0; i < values.length; ++i) {
	        if (simpleMode) {
	          locked[i].set(values[i]);
	        } else {
	          lockingConstrs[i].value = values[i];
	        }
	      }
	    }
	  };
	  return systemSolver;
	};
	
	var solve_lm = function solve_lm(sys, model, jacobian, rough) {
	  var opt = new _lm2.default(sys.getParams(), math.vec(sys.constraints.length), model, jacobian);
	  opt.evalMaximalCount = 100 * sys.params.length;
	  var eps = rough ? 0.001 : 0.00000001;
	  opt.init0(eps, eps, eps);
	  var returnCode = 1;
	  try {
	    var res = opt.doOptimize();
	  } catch (e) {
	    returnCode = 2;
	  }
	  sys.setParams(res[0]);
	  return {
	    evalCount: opt.evalCount,
	    error: sys.error(),
	    returnCode: returnCode
	  };
	};
	
	exports.Param = Param;
	exports.prepare = prepare;

/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _utils = __webpack_require__(330);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	/** @constructor */
	function QR(matrix) {
	  var vec = math._vec;
	  this.matrix = matrix;
	  var nR = this.matrix.length;
	  var nC = nR == 0 ? 0 : this.matrix[0].length;
	
	  this.qrRankingThreshold = 1e-30; //??
	  this.solvedCols = Math.min(nR, nC);
	  this.diagR = vec(nC);
	  this.norm = vec(nC);
	  this.beta = vec(nC);
	  this.permutation = vec(nC);
	  this.rank = null;
	
	  var k;
	  var norm2;
	  var akk;
	  var j;
	  var i;
	
	  // initializations
	  for (k = 0; k < nC; ++k) {
	    this.permutation[k] = k;
	    norm2 = 0;
	    for (i = 0; i < nR; ++i) {
	      akk = matrix[i][k];
	      norm2 += akk * akk;
	    }
	    this.norm[k] = Math.sqrt(norm2);
	  }
	
	  // transform the matrix column after column
	  for (k = 0; k < nC; ++k) {
	
	    // select the column with the greatest norm on active components
	    var nextColumn = -1;
	    var ak2 = Number.NEGATIVE_INFINITY;
	    for (i = k; i < nC; ++i) {
	      norm2 = 0;
	      for (j = k; j < nR; ++j) {
	        var aki = matrix[j][this.permutation[i]];
	        norm2 += aki * aki;
	      }
	      if (!isFinite(norm2)) {
	        throw "UNABLE_TO_PERFORM_QR_DECOMPOSITION";
	      }
	      if (norm2 > ak2) {
	        nextColumn = i;
	        ak2 = norm2;
	      }
	    }
	    if (ak2 <= this.qrRankingThreshold) {
	      this.rank = k;
	      return;
	    }
	    var pk = this.permutation[nextColumn];
	    this.permutation[nextColumn] = this.permutation[k];
	    this.permutation[k] = pk;
	
	    // choose alpha such that Hk.u = alpha ek
	    akk = matrix[k][pk];
	    var alpha = akk > 0 ? -Math.sqrt(ak2) : Math.sqrt(ak2);
	    var betak = 1.0 / (ak2 - akk * alpha);
	    this.beta[pk] = betak;
	
	    // transform the current column
	    this.diagR[pk] = alpha;
	    matrix[k][pk] -= alpha;
	
	    // transform the remaining columns
	    for (var dk = nC - 1 - k; dk > 0; --dk) {
	      var gamma = 0;
	      for (j = k; j < nR; ++j) {
	        gamma += matrix[j][pk] * matrix[j][this.permutation[k + dk]];
	      }
	      gamma *= betak;
	      for (j = k; j < nR; ++j) {
	        matrix[j][this.permutation[k + dk]] -= gamma * matrix[j][pk];
	      }
	    }
	  }
	  this.rank = this.solvedCols;
	}
	
	QR.prototype.qTy = function (y) {
	  var nR = this.matrix.length;
	  var nC = this.matrix[0].length;
	
	  for (var k = 0; k < nC; ++k) {
	    var pk = this.permutation[k];
	    var gamma = 0;
	    for (var i = k; i < nR; ++i) {
	      gamma += this.matrix[i][pk] * y[i];
	    }
	    gamma *= this.beta[pk];
	    for (var i = k; i < nR; ++i) {
	      y[i] -= gamma * this.matrix[i][pk];
	    }
	  }
	};
	
	QR.prototype.solve = function (qy) {
	
	  var nR = this.matrix.length;
	  var nC = this.matrix[0].length;
	
	  var vec = math._vec;
	
	  var diag = vec(nC);
	  var lmDiag = vec(nC);
	  var work = vec(nC);
	  var out = vec(nC);
	
	  // copy R and Qty to preserve input and initialize s
	  //  in particular, save the diagonal elements of R in lmDir
	  for (var j = 0; j < this.solvedCols; ++j) {
	    var pj = this.permutation[j];
	    for (var i = j + 1; i < this.solvedCols; ++i) {
	      this.matrix[i][pj] = this.matrix[j][this.permutation[i]];
	    }
	    out[j] = this.diagR[pj];
	    work[j] = qy[j];
	  }
	
	  // eliminate the diagonal matrix d using a Givens rotation
	  for (var j = 0; j < this.solvedCols; ++j) {
	
	    // prepare the row of d to be eliminated, locating the
	    // diagonal element using p from the Q.R. factorization
	    var pj = this.permutation[j];
	    var dpj = diag[pj];
	    if (dpj != 0) {
	      (0, _utils.fillArray)(lmDiag, j + 1, lmDiag.length, 0);
	    }
	    lmDiag[j] = dpj;
	
	    //  the transformations to eliminate the row of d
	    // modify only a single element of Qty
	    // beyond the first n, which is initially zero.
	    var qtbpj = 0;
	    for (var k = j; k < this.solvedCols; ++k) {
	      var pk = this.permutation[k];
	
	      // determine a Givens rotation which eliminates the
	      // appropriate element in the current row of d
	      if (lmDiag[k] != 0) {
	
	        var sin;
	        var cos;
	        var rkk = this.matrix[k][pk];
	        if (Math.abs(rkk) < Math.abs(lmDiag[k])) {
	          var cotan = rkk / lmDiag[k];
	          sin = 1.0 / Math.sqrt(1.0 + cotan * cotan);
	          cos = sin * cotan;
	        } else {
	          var tan = lmDiag[k] / rkk;
	          cos = 1.0 / Math.sqrt(1.0 + tan * tan);
	          sin = cos * tan;
	        }
	
	        // compute the modified diagonal element of R and
	        // the modified element of (Qty,0)
	        this.matrix[k][pk] = cos * rkk + sin * lmDiag[k];
	        var temp = cos * work[k] + sin * qtbpj;
	        qtbpj = -sin * work[k] + cos * qtbpj;
	        work[k] = temp;
	
	        // accumulate the tranformation in the row of s
	        for (var i = k + 1; i < this.solvedCols; ++i) {
	          var rik = this.matrix[i][pk];
	          var temp2 = cos * rik + sin * lmDiag[i];
	          lmDiag[i] = -sin * rik + cos * lmDiag[i];
	          this.matrix[i][pk] = temp2;
	        }
	      }
	    }
	
	    // store the diagonal element of s and restore
	    // the corresponding diagonal element of R
	    lmDiag[j] = this.matrix[j][this.permutation[j]];
	    this.matrix[j][this.permutation[j]] = out[j];
	  }
	
	  // solve the triangular system for z, if the system is
	  // singular, then obtain a least squares solution
	  var nSing = this.solvedCols;
	  for (var j = 0; j < this.solvedCols; ++j) {
	    if (lmDiag[j] == 0 && nSing == this.solvedCols) {
	      nSing = j;
	    }
	    if (nSing < this.solvedCols) {
	      work[j] = 0;
	    }
	  }
	  if (nSing > 0) {
	    for (var j = nSing - 1; j >= 0; --j) {
	      var pj = this.permutation[j];
	      var sum = 0;
	      for (var i = j + 1; i < nSing; ++i) {
	        sum += this.matrix[i][pj] * work[i];
	      }
	      work[j] = (work[j] - sum) / lmDiag[j];
	    }
	  }
	
	  // permute the components of z back to components of lmDir
	  for (var j = 0; j < out.length; ++j) {
	    out[this.permutation[j]] = work[j];
	  }
	  return out;
	};
	
	exports.default = QR;

/***/ },
/* 419 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = LMOptimizer;
	/**
	 * This class solves a least-squares problem using the Levenberg-Marquardt algorithm.
	 *
	 * <p>This implementation <em>should</em> work even for over-determined systems
	 * (i.e. systems having more point than equations). Over-determined systems
	 * are solved by ignoring the point which have the smallest impact according
	 * to their jacobian column norm. Only the rank of the matrix and some loop bounds
	 * are changed to implement this.</p>
	 *
	 * <p>The resolution engine is a simple translation of the MINPACK <a
	 * href="http://www.netlib.org/minpack/lmder.f">lmder</a> routine with minor
	 * changes. The changes include the over-determined resolution, the use of
	 * inherited convergence checker and the Q.R. decomposition which has been
	 * rewritten following the algorithm described in the
	 * P. Lascaux and R. Theodor book <i>Analyse num&eacute;rique matricielle
	 * appliqu&eacute;e &agrave; l'art de l'ing&eacute;nieur</i>, Masson 1986.</p>
	 * <p>The authors of the original fortran version are:
	 * <ul>
	 * <li>Argonne National Laboratory. MINPACK project. March 1980</li>
	 * <li>Burton S. Garbow</li>
	 * <li>Kenneth E. Hillstrom</li>
	 * <li>Jorge J. More</li>
	 * </ul>
	 * The redistribution policy for MINPACK is available <a
	 * href="http://www.netlib.org/minpack/disclaimer">here</a>, for convenience, it
	 * is reproduced below.</p>
	 *
	 * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0">
	 * <tr><td>
	 *    Minpack Copyright Notice (1999) University of Chicago.
	 *    All rights reserved
	 * </td></tr>
	 * <tr><td>
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * <ol>
	 *  <li>Redistributions of source code must retain the above copyright
	 *      notice, this list of conditions and the following disclaimer.</li>
	 * <li>Redistributions in binary form must reproduce the above
	 *     copyright notice, this list of conditions and the following
	 *     disclaimer in the documentation and/or other materials provided
	 *     with the distribution.</li>
	 * <li>The end-user documentation included with the redistribution, if any,
	 *     must include the following acknowledgment:
	 *     <code>This product includes software developed by the University of
	 *           Chicago, as Operator of Argonne National Laboratory.</code>
	 *     Alternately, this acknowledgment may appear in the software itself,
	 *     if and wherever such third-party acknowledgments normally appear.</li>
	 * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS"
	 *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
	 *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
	 *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
	 *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
	 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
	 *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
	 *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
	 *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
	 *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
	 *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
	 *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
	 *     BE CORRECTED.</strong></li>
	 * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
	 *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
	 *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
	 *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
	 *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
	 *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
	 *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
	 *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
	 *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
	 *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>
	 * <ol></td></tr>
	 * </table>
	 *
	 * @version $Id: LevenbergMarquardtOptimizer.java 1416643 2012-12-03 19:37:14Z tn $
	 * @constructor
	 */
	function LMOptimizer(startPoint, target, model, jacobian) {
	
	    this.startPoint = startPoint;
	    this.target = target;
	    this.evalCount = 0;
	    this.evalMaximalCount = 100000;
	    this.model = model;
	    this.jacobian = jacobian;
	
	    this.identity = function (size) {
	        var out = [];
	        for (var row = 0; row < size; ++row) {
	            out.push([]);
	            for (var col = 0; col < size; ++col) {
	                out[row].push(row === col ? 1 : 0);
	            }
	        }
	        return out;
	    };
	
	    /** Square-root of the weight matrix. */
	    this.weightMatrixSqrt = this.identity(target.length); //TMath.identity(new TMath.Matrix(target.length, target.length)); //TODO:
	    this.weightMatrix = this.identity(target.length);
	    /** Cost value (square root of the sum of the residuals). */
	    this.cost = null;
	    /** Number of solved point. */
	    this.solvedCols = null;
	    /** Diagonal elements of the R matrix in the Q.R. decomposition. */
	    this.diagR = null;
	    /** Norms of the columns of the jacobian matrix. */
	    this.jacNorm = null;
	    /** Coefficients of the Householder transforms vectors. */
	    this.beta = null;
	    /** Columns permutation array. */
	    this.permutation = null;
	    /** Rank of the jacobian matrix. */
	    this.rank = null;
	    /** Levenberg-Marquardt parameter. */
	    this.lmPar = null;
	    /** Parameters evolution direction associated with lmPar. */
	    this.lmDir = null;
	    /** Positive input variable used in determining the initial step bound. */
	    this.initialStepBoundFactor = null;
	    /** Desired relative error in the sum of squares. */
	    this.costRelativeTolerance = null;
	    /**  Desired relative error in the approximate solution parameters. */
	    this.parRelativeTolerance = null;
	    /** Desired max cosine on the orthogonality between the function vector
	     * and the columns of the jacobian. */
	    this.orthoTolerance = null;
	    /** Threshold for QR ranking. */
	    this.qrRankingThreshold = null;
	    /** Weighted residuals. */
	    this.weightedResidual = null;
	    /** Weighted Jacobian. */
	    this.weightedJacobian = null;
	
	    this.checker = null;
	
	    function arr(size) {
	        var out = [];
	        out.length = size;
	        for (var i = 0; i < size; ++i) {
	            out[i] = 0;
	        }
	        return out;
	    }
	
	    function Arrays_fill(a, fromIndex, toIndex, val) {
	        for (var i = fromIndex; i < toIndex; i++) {
	            a[i] = val;
	        }
	    }
	
	    //    var SAFE_MIN = Number.MIN_VALUE; //FIXME!!!!
	    var SAFE_MIN = 1e-30; //FIXME!!!!
	
	    /**
	     * Build an optimizer for least squares problems with default values
	     * for all the tuning parameters (see the {@link
	     * #LevenbergMarquardtOptimizer(double,double,double,double,double)
	     * other contructor}.
	     * The default values for the algorithm settings are:
	     * <ul>
	     *  <li>Initial step bound factor: 100</li>
	     *  <li>Cost relative tolerance: 1e-10</li>
	     *  <li>Parameters relative tolerance: 1e-10</li>
	     *  <li>Orthogonality tolerance: 1e-10</li>
	     *  <li>QR ranking threshold: {@link Precision#SAFE_MIN}</li>
	     * </ul>
	     */
	    this.init = function () {
	        this.init1(100, 1e-10, 1e-10, 1e-10, SAFE_MIN);
	    };
	
	    /**
	     * Build an optimizer for least squares problems with default values
	     * for some of the tuning parameters (see the {@link
	     * #LevenbergMarquardtOptimizer(double,double,double,double,double)
	     * other contructor}.
	     * The default values for the algorithm settings are:
	     * <ul>
	     *  <li>Initial step bound factor}: 100</li>
	     *  <li>QR ranking threshold}: {@link Precision#SAFE_MIN}</li>
	     * </ul>
	     *
	     * @param costRelativeTolerance Desired relative error in the sum of
	     * squares.
	     * @param parRelativeTolerance Desired relative error in the approximate
	     * solution parameters.
	     * @param orthoTolerance Desired max cosine on the orthogonality between
	     * the function vector and the columns of the Jacobian.
	     */
	    this.init0 = function (costRelativeTolerance, parRelativeTolerance, orthoTolerance) {
	        this.init1(100, costRelativeTolerance, parRelativeTolerance, orthoTolerance, SAFE_MIN);
	    };
	
	    /**
	     * The arguments control the behaviour of the default convergence checking
	     * procedure.
	     * Additional criteria can defined through the setting of a {@link
	     * ConvergenceChecker}.
	     *
	     * @param initialStepBoundFactor Positive input variable used in
	     * determining the initial step bound. This bound is set to the
	     * product of initialStepBoundFactor and the euclidean norm of
	     * {@code diag * x} if non-zero, or else to {@code initialStepBoundFactor}
	     * itself. In most cases factor should lie in the interval
	     * {@code (0.1, 100.0)}. {@code 100} is a generally recommended value.
	     * @param costRelativeTolerance Desired relative error in the sum of
	     * squares.
	     * @param parRelativeTolerance Desired relative error in the approximate
	     * solution parameters.
	     * @param orthoTolerance Desired max cosine on the orthogonality between
	     * the function vector and the columns of the Jacobian.
	     * @param threshold Desired threshold for QR ranking. If the squared norm
	     * of a column vector is smaller or equal to this threshold during QR
	     * decomposition, it is considered to be a zero vector and hence the rank
	     * of the matrix is reduced.
	     */
	    this.init1 = function (initialStepBoundFactor, costRelativeTolerance, parRelativeTolerance, orthoTolerance, threshold) {
	        this.initialStepBoundFactor = initialStepBoundFactor;
	        this.costRelativeTolerance = costRelativeTolerance;
	        this.parRelativeTolerance = parRelativeTolerance;
	        this.orthoTolerance = orthoTolerance;
	        this.qrRankingThreshold = threshold;
	    };
	
	    /** {@inheritDoc} */
	
	    this.doOptimize = function () {
	        var nR = this.target.length; // Number of observed data.
	        var currentPoint = this.startPoint;
	        var nC = currentPoint.length; // Number of parameters.
	
	        // arrays shared with the other private methods
	        this.solvedCols = Math.min(nR, nC);
	        this.diagR = arr(nC);
	        this.jacNorm = arr(nC);
	        this.beta = arr(nC);
	        this.permutation = arr(nC);
	        this.lmDir = arr(nC);
	
	        // local point
	        var delta = 0;
	        var xNorm = 0;
	        var diag = arr(nC);
	        var oldX = arr(nC);
	        var oldRes = arr(nR);
	        var oldObj = arr(nR);
	        var qtf = arr(nR);
	        var work1 = arr(nC);
	        var work2 = arr(nC);
	        var work3 = arr(nC);
	
	        var weightMatrixSqrt = this.getWeightSquareRoot();
	
	        // Evaluate the function at the starting point and calculate its norm.
	        var currentObjective = this.computeObjectiveValue(currentPoint);
	        var currentResiduals = this.computeResiduals(currentObjective);
	        var current = [currentPoint, currentObjective];
	        var currentCost = this.computeCost(currentResiduals);
	
	        // Outer loop.
	        this.lmPar = 0;
	        var firstIteration = true;
	        var iter = 0;
	
	        while (true) {
	            ++iter;
	            var previous = current;
	
	            // QR decomposition of the jacobian matrix
	            this.qrDecomposition(this.computeWeightedJacobian(currentPoint));
	
	            this.weightedResidual = this.operate(weightMatrixSqrt, currentResiduals);
	            for (var i = 0; i < nR; i++) {
	                qtf[i] = this.weightedResidual[i];
	            }
	
	            // compute Qt.res
	            this.qTy(qtf);
	
	            // now we don't need Q anymore,
	            // so let jacobian contain the R matrix with its diagonal elements
	            for (var k = 0; k < this.solvedCols; ++k) {
	                var pk = this.permutation[k];
	                this.weightedJacobian[k][pk] = this.diagR[pk];
	            }
	
	            if (firstIteration) {
	                // scale the point according to the norms of the columns
	                // of the initial jacobian
	                xNorm = 0;
	                for (var k = 0; k < nC; ++k) {
	                    var dk = this.jacNorm[k];
	                    if (dk == 0) {
	                        dk = 1.0;
	                    }
	                    var xk = dk * currentPoint[k];
	                    xNorm += xk * xk;
	                    diag[k] = dk;
	                }
	                xNorm = Math.sqrt(xNorm);
	
	                // initialize the step bound delta
	                delta = xNorm == 0 ? this.initialStepBoundFactor : this.initialStepBoundFactor * xNorm;
	            }
	
	            // check orthogonality between function vector and jacobian columns
	            var maxCosine = 0;
	            if (currentCost != 0) {
	                for (var j = 0; j < this.solvedCols; ++j) {
	                    var pj = this.permutation[j];
	                    var s = this.jacNorm[pj];
	                    if (s != 0) {
	                        var sum = 0;
	                        for (var i = 0; i <= j; ++i) {
	                            sum += this.weightedJacobian[i][pj] * qtf[i];
	                        }
	                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * currentCost));
	                    }
	                }
	            }
	            if (maxCosine <= this.orthoTolerance) {
	                // Convergence has been reached.
	                this.setCost(currentCost);
	                return current;
	            }
	
	            // rescale if necessary
	            for (var j = 0; j < nC; ++j) {
	                diag[j] = Math.max(diag[j], this.jacNorm[j]);
	            }
	
	            // Inner loop.
	            for (var ratio = 0; ratio < 1.0e-4;) {
	
	                // save the state
	                for (var j = 0; j < this.solvedCols; ++j) {
	                    var pj = this.permutation[j];
	                    oldX[pj] = currentPoint[pj];
	                }
	                var previousCost = currentCost;
	                var tmpVec = this.weightedResidual;
	                this.weightedResidual = oldRes;
	                oldRes = tmpVec;
	                tmpVec = currentObjective;
	                currentObjective = oldObj;
	                oldObj = tmpVec;
	
	                // determine the Levenberg-Marquardt parameter
	                this.determineLMParameter(qtf, delta, diag, work1, work2, work3);
	
	                // compute the new point and the norm of the evolution direction
	                var lmNorm = 0;
	                for (var j = 0; j < this.solvedCols; ++j) {
	                    var pj = this.permutation[j];
	                    this.lmDir[pj] = -this.lmDir[pj];
	                    currentPoint[pj] = oldX[pj] + this.lmDir[pj];
	                    var s = diag[pj] * this.lmDir[pj];
	                    lmNorm += s * s;
	                }
	                lmNorm = Math.sqrt(lmNorm);
	                // on the first iteration, adjust the initial step bound.
	                if (firstIteration) {
	                    delta = Math.min(delta, lmNorm);
	                }
	
	                // Evaluate the function at x + p and calculate its norm.
	                currentObjective = this.computeObjectiveValue(currentPoint);
	                currentResiduals = this.computeResiduals(currentObjective);
	                current = [currentPoint, currentObjective];
	                currentCost = this.computeCost(currentResiduals);
	
	                // compute the scaled actual reduction
	                var actRed = -1.0;
	                if (0.1 * currentCost < previousCost) {
	                    var r = currentCost / previousCost;
	                    actRed = 1.0 - r * r;
	                }
	
	                // compute the scaled predicted reduction
	                // and the scaled directional derivative
	                for (var j = 0; j < this.solvedCols; ++j) {
	                    var pj = this.permutation[j];
	                    var dirJ = this.lmDir[pj];
	                    work1[j] = 0;
	                    for (var i = 0; i <= j; ++i) {
	                        work1[i] += this.weightedJacobian[i][pj] * dirJ;
	                    }
	                }
	                var coeff1 = 0;
	                for (var j = 0; j < this.solvedCols; ++j) {
	                    coeff1 += work1[j] * work1[j];
	                }
	                var pc2 = previousCost * previousCost;
	                coeff1 = coeff1 / pc2;
	                var coeff2 = this.lmPar * lmNorm * lmNorm / pc2;
	                var preRed = coeff1 + 2 * coeff2;
	                var dirDer = -(coeff1 + coeff2);
	
	                // ratio of the actual to the predicted reduction
	                ratio = preRed == 0 ? 0 : actRed / preRed;
	
	                // update the step bound
	                if (ratio <= 0.25) {
	                    var tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;
	                    if (0.1 * currentCost >= previousCost || tmp < 0.1) {
	                        tmp = 0.1;
	                    }
	                    delta = tmp * Math.min(delta, 10.0 * lmNorm);
	                    this.lmPar /= tmp;
	                } else if (this.lmPar == 0 || ratio >= 0.75) {
	                    delta = 2 * lmNorm;
	                    this.lmPar *= 0.5;
	                }
	
	                // test for successful iteration.
	                if (ratio >= 1.0e-4) {
	                    // successful iteration, update the norm
	                    firstIteration = false;
	                    xNorm = 0;
	                    for (var k = 0; k < nC; ++k) {
	                        var xK = diag[k] * currentPoint[k];
	                        xNorm += xK * xK;
	                    }
	                    xNorm = Math.sqrt(xNorm);
	
	                    // tests for convergence.
	                    if (this.checker != null) {
	                        // we use the vectorial convergence checker
	                        if (this.checker.call(iter, previous, current)) {
	                            this.setCost(currentCost);
	                            return current;
	                        }
	                    }
	                } else {
	                    // failed iteration, reset the previous values
	                    currentCost = previousCost;
	                    for (var j = 0; j < this.solvedCols; ++j) {
	                        var pj = this.permutation[j];
	                        currentPoint[pj] = oldX[pj];
	                    }
	                    tmpVec = this.weightedResidual;
	                    this.weightedResidual = oldRes;
	                    oldRes = tmpVec;
	                    tmpVec = currentObjective;
	                    currentObjective = oldObj;
	                    oldObj = tmpVec;
	                    // Reset "current" to previous values.
	                    current = [currentPoint, currentObjective];
	                }
	
	                // Default convergence criteria.
	                if (Math.abs(actRed) <= this.costRelativeTolerance && preRed <= this.costRelativeTolerance && ratio <= 2.0 || delta <= this.parRelativeTolerance * xNorm) {
	                    this.setCost(currentCost);
	                    return current;
	                }
	
	                // tests for termination and stringent tolerances
	                // (2.2204e-16 is the machine epsilon for IEEE754)
	                if (Math.abs(actRed) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {
	                    throw "TOO_SMALL_COST_RELATIVE_TOLERANCE: " + this.costRelativeTolerance;
	                } else if (delta <= 2.2204e-16 * xNorm) {
	                    throw "TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE: " + this.parRelativeTolerance;
	                } else if (maxCosine <= 2.2204e-16) {
	                    throw "TOO_SMALL_ORTHOGONALITY_TOLERANCE: " + this.orthoTolerance;
	                }
	            }
	        }
	    };
	
	    /**
	     * Determine the Levenberg-Marquardt parameter.
	     * <p>This implementation is a translation in Java of the MINPACK
	     * <a href="http://www.netlib.org/minpack/lmpar.f">lmpar</a>
	     * routine.</p>
	     * <p>This method sets the lmPar and lmDir attributes.</p>
	     * <p>The authors of the original fortran function are:</p>
	     * <ul>
	     *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>
	     *   <li>Burton  S. Garbow</li>
	     *   <li>Kenneth E. Hillstrom</li>
	     *   <li>Jorge   J. More</li>
	     * </ul>
	     * <p>Luc Maisonobe did the Java translation.</p>
	     *
	     * @param qy array containing qTy
	     * @param delta upper bound on the euclidean norm of diagR * lmDir
	     * @param diag diagonal matrix
	     * @param work1 work array
	     * @param work2 work array
	     * @param work3 work array
	     */
	    this.determineLMParameter = function (qy, delta, diag, work1, work2, work3) {
	        var nC = this.weightedJacobian[0].length;
	
	        // compute and store in x the gauss-newton direction, if the
	        // jacobian is rank-deficient, obtain a least squares solution
	        for (var j = 0; j < this.rank; ++j) {
	            this.lmDir[this.permutation[j]] = qy[j];
	        }
	        for (var j = this.rank; j < nC; ++j) {
	            this.lmDir[this.permutation[j]] = 0;
	        }
	        for (var k = this.rank - 1; k >= 0; --k) {
	            var pk = this.permutation[k];
	            var ypk = this.lmDir[pk] / this.diagR[pk];
	            for (var i = 0; i < k; ++i) {
	                this.lmDir[this.permutation[i]] -= ypk * this.weightedJacobian[i][pk];
	            }
	            this.lmDir[pk] = ypk;
	        }
	
	        // evaluate the function at the origin, and test
	        // for acceptance of the Gauss-Newton direction
	        var dxNorm = 0;
	        for (var j = 0; j < this.solvedCols; ++j) {
	            var pj = this.permutation[j];
	            var s = diag[pj] * this.lmDir[pj];
	            work1[pj] = s;
	            dxNorm += s * s;
	        }
	        dxNorm = Math.sqrt(dxNorm);
	        var fp = dxNorm - delta;
	        if (fp <= 0.1 * delta) {
	            this.lmPar = 0;
	            return;
	        }
	
	        // if the jacobian is not rank deficient, the Newton step provides
	        // a lower bound, parl, for the zero of the function,
	        // otherwise set this bound to zero
	        var sum2;
	        var parl = 0;
	        if (this.rank == this.solvedCols) {
	            for (var j = 0; j < this.solvedCols; ++j) {
	                var pj = this.permutation[j];
	                work1[pj] *= diag[pj] / dxNorm;
	            }
	            sum2 = 0;
	            for (var j = 0; j < this.solvedCols; ++j) {
	                var pj = this.permutation[j];
	                var sum = 0;
	                for (var i = 0; i < j; ++i) {
	                    sum += this.weightedJacobian[i][pj] * work1[this.permutation[i]];
	                }
	                var s = (work1[pj] - sum) / this.diagR[pj];
	                work1[pj] = s;
	                sum2 += s * s;
	            }
	            parl = fp / (delta * sum2);
	        }
	
	        // calculate an upper bound, paru, for the zero of the function
	        sum2 = 0;
	        for (var j = 0; j < this.solvedCols; ++j) {
	            var pj = this.permutation[j];
	            var sum = 0;
	            for (var i = 0; i <= j; ++i) {
	                sum += this.weightedJacobian[i][pj] * qy[i];
	            }
	            sum /= diag[pj];
	            sum2 += sum * sum;
	        }
	        var gNorm = Math.sqrt(sum2);
	        var paru = gNorm / delta;
	        if (paru == 0) {
	            // 2.2251e-308 is the smallest positive real for IEE754
	            paru = 2.2251e-308 / Math.min(delta, 0.1);
	        }
	
	        // if the input par lies outside of the interval (parl,paru),
	        // set par to the closer endpoint
	        this.lmPar = Math.min(paru, Math.max(this.lmPar, parl));
	        if (this.lmPar == 0) {
	            this.lmPar = gNorm / dxNorm;
	        }
	
	        for (var countdown = 10; countdown >= 0; --countdown) {
	
	            // evaluate the function at the current value of lmPar
	            if (this.lmPar == 0) {
	                this.lmPar = Math.max(2.2251e-308, 0.001 * paru);
	            }
	            var sPar = Math.sqrt(this.lmPar);
	            for (var j = 0; j < this.solvedCols; ++j) {
	                var pj = this.permutation[j];
	                work1[pj] = sPar * diag[pj];
	            }
	            this.determineLMDirection(qy, work1, work2, work3);
	
	            dxNorm = 0;
	            for (var j = 0; j < this.solvedCols; ++j) {
	                var pj = this.permutation[j];
	                var s = diag[pj] * this.lmDir[pj];
	                work3[pj] = s;
	                dxNorm += s * s;
	            }
	            dxNorm = Math.sqrt(dxNorm);
	            var previousFP = fp;
	            fp = dxNorm - delta;
	
	            // if the function is small enough, accept the current value
	            // of lmPar, also test for the exceptional cases where parl is zero
	            if (Math.abs(fp) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {
	                return;
	            }
	
	            // compute the Newton correction
	            for (var j = 0; j < this.solvedCols; ++j) {
	                var pj = this.permutation[j];
	                work1[pj] = work3[pj] * diag[pj] / dxNorm;
	            }
	            for (var j = 0; j < this.solvedCols; ++j) {
	                var pj = this.permutation[j];
	                work1[pj] /= work2[j];
	                var tmp = work1[pj];
	                for (var i = j + 1; i < this.solvedCols; ++i) {
	                    work1[this.permutation[i]] -= this.weightedJacobian[i][pj] * tmp;
	                }
	            }
	            sum2 = 0;
	            for (var j = 0; j < this.solvedCols; ++j) {
	                var s = work1[this.permutation[j]];
	                sum2 += s * s;
	            }
	            var correction = fp / (delta * sum2);
	
	            // depending on the sign of the function, update parl or paru.
	            if (fp > 0) {
	                parl = Math.max(parl, this.lmPar);
	            } else if (fp < 0) {
	                paru = Math.min(paru, this.lmPar);
	            }
	
	            // compute an improved estimate for lmPar
	            this.lmPar = Math.max(parl, this.lmPar + correction);
	        }
	    };
	
	    /**
	     * Solve a*x = b and d*x = 0 in the least squares sense.
	     * <p>This implementation is a translation in Java of the MINPACK
	     * <a href="http://www.netlib.org/minpack/qrsolv.f">qrsolv</a>
	     * routine.</p>
	     * <p>This method sets the lmDir and lmDiag attributes.</p>
	     * <p>The authors of the original fortran function are:</p>
	     * <ul>
	     *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>
	     *   <li>Burton  S. Garbow</li>
	     *   <li>Kenneth E. Hillstrom</li>
	     *   <li>Jorge   J. More</li>
	     * </ul>
	     * <p>Luc Maisonobe did the Java translation.</p>
	     *
	     * @param qy array containing qTy
	     * @param diag diagonal matrix
	     * @param lmDiag diagonal elements associated with lmDir
	     * @param work work array
	     */
	    this.determineLMDirection = function (qy, diag, lmDiag, work) {
	
	        // copy R and Qty to preserve input and initialize s
	        //  in particular, save the diagonal elements of R in lmDir
	        for (var j = 0; j < this.solvedCols; ++j) {
	            var pj = this.permutation[j];
	            for (var i = j + 1; i < this.solvedCols; ++i) {
	                this.weightedJacobian[i][pj] = this.weightedJacobian[j][this.permutation[i]];
	            }
	            this.lmDir[j] = this.diagR[pj];
	            work[j] = qy[j];
	        }
	
	        // eliminate the diagonal matrix d using a Givens rotation
	        for (var j = 0; j < this.solvedCols; ++j) {
	
	            // prepare the row of d to be eliminated, locating the
	            // diagonal element using p from the Q.R. factorization
	            var pj = this.permutation[j];
	            var dpj = diag[pj];
	            if (dpj != 0) {
	                Arrays_fill(lmDiag, j + 1, lmDiag.length, 0);
	            }
	            lmDiag[j] = dpj;
	
	            //  the transformations to eliminate the row of d
	            // modify only a single element of Qty
	            // beyond the first n, which is initially zero.
	            var qtbpj = 0;
	            for (var k = j; k < this.solvedCols; ++k) {
	                var pk = this.permutation[k];
	
	                // determine a Givens rotation which eliminates the
	                // appropriate element in the current row of d
	                if (lmDiag[k] != 0) {
	
	                    var sin;
	                    var cos;
	                    var rkk = this.weightedJacobian[k][pk];
	                    if (Math.abs(rkk) < Math.abs(lmDiag[k])) {
	                        var cotan = rkk / lmDiag[k];
	                        sin = 1.0 / Math.sqrt(1.0 + cotan * cotan);
	                        cos = sin * cotan;
	                    } else {
	                        var tan = lmDiag[k] / rkk;
	                        cos = 1.0 / Math.sqrt(1.0 + tan * tan);
	                        sin = cos * tan;
	                    }
	
	                    // compute the modified diagonal element of R and
	                    // the modified element of (Qty,0)
	                    this.weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];
	                    var temp = cos * work[k] + sin * qtbpj;
	                    qtbpj = -sin * work[k] + cos * qtbpj;
	                    work[k] = temp;
	
	                    // accumulate the tranformation in the row of s
	                    for (var i = k + 1; i < this.solvedCols; ++i) {
	                        var rik = this.weightedJacobian[i][pk];
	                        var temp2 = cos * rik + sin * lmDiag[i];
	                        lmDiag[i] = -sin * rik + cos * lmDiag[i];
	                        this.weightedJacobian[i][pk] = temp2;
	                    }
	                }
	            }
	
	            // store the diagonal element of s and restore
	            // the corresponding diagonal element of R
	            lmDiag[j] = this.weightedJacobian[j][this.permutation[j]];
	            this.weightedJacobian[j][this.permutation[j]] = this.lmDir[j];
	        }
	
	        // solve the triangular system for z, if the system is
	        // singular, then obtain a least squares solution
	        var nSing = this.solvedCols;
	        for (var j = 0; j < this.solvedCols; ++j) {
	            if (lmDiag[j] == 0 && nSing == this.solvedCols) {
	                nSing = j;
	            }
	            if (nSing < this.solvedCols) {
	                work[j] = 0;
	            }
	        }
	        if (nSing > 0) {
	            for (var j = nSing - 1; j >= 0; --j) {
	                var pj = this.permutation[j];
	                var sum = 0;
	                for (var i = j + 1; i < nSing; ++i) {
	                    sum += this.weightedJacobian[i][pj] * work[i];
	                }
	                work[j] = (work[j] - sum) / lmDiag[j];
	            }
	        }
	
	        // permute the components of z back to components of lmDir
	        for (var j = 0; j < this.lmDir.length; ++j) {
	            this.lmDir[this.permutation[j]] = work[j];
	        }
	    };
	
	    /**
	     * Decompose a matrix A as A.P = Q.R using Householder transforms.
	     * <p>As suggested in the P. Lascaux and R. Theodor book
	     * <i>Analyse num&eacute;rique matricielle appliqu&eacute;e &agrave;
	     * l'art de l'ing&eacute;nieur</i> (Masson, 1986), instead of representing
	     * the Householder transforms with u<sub>k</sub> unit vectors such that:
	     * <pre>
	     * H<sub>k</sub> = I - 2u<sub>k</sub>.u<sub>k</sub><sup>t</sup>
	     * </pre>
	     * we use <sub>k</sub> non-unit vectors such that:
	     * <pre>
	     * H<sub>k</sub> = I - beta<sub>k</sub>v<sub>k</sub>.v<sub>k</sub><sup>t</sup>
	     * </pre>
	     * where v<sub>k</sub> = a<sub>k</sub> - alpha<sub>k</sub> e<sub>k</sub>.
	     * The beta<sub>k</sub> coefficients are provided upon exit as recomputing
	     * them from the v<sub>k</sub> vectors would be costly.</p>
	     * <p>This decomposition handles rank deficient cases since the tranformations
	     * are performed in non-increasing columns norms order thanks to columns
	     * pivoting. The diagonal elements of the R matrix are therefore also in
	     * non-increasing absolute values order.</p>
	     *
	     * @param jacobian Weighted Jacobian matrix at the current point.
	     * @exception ConvergenceException if the decomposition cannot be performed
	     */
	    this.qrDecomposition = function (jacobian) {
	        // Code in this class assumes that the weighted Jacobian is -(W^(1/2) J),
	        // hence the multiplication by -1.
	        this.weightedJacobian = this.scalarMultiply(jacobian, -1);
	
	        var nR = this.weightedJacobian.length;
	        var nC = this.weightedJacobian[0].length;
	
	        // initializations
	        for (var k = 0; k < nC; ++k) {
	            this.permutation[k] = k;
	            var norm2 = 0;
	            for (var i = 0; i < nR; ++i) {
	                var akk = this.weightedJacobian[i][k];
	                norm2 += akk * akk;
	            }
	            this.jacNorm[k] = Math.sqrt(norm2);
	        }
	
	        // transform the matrix column after column
	        for (var k = 0; k < nC; ++k) {
	
	            // select the column with the greatest norm on active components
	            var nextColumn = -1;
	            var ak2 = Number.NEGATIVE_INFINITY;
	            for (var i = k; i < nC; ++i) {
	                var norm2 = 0;
	                for (var j = k; j < nR; ++j) {
	                    var aki = this.weightedJacobian[j][this.permutation[i]];
	                    norm2 += aki * aki;
	                }
	                if (!isFinite(norm2)) {
	                    throw "UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN";
	                }
	                if (norm2 > ak2) {
	                    nextColumn = i;
	                    ak2 = norm2;
	                }
	            }
	            if (ak2 <= this.qrRankingThreshold) {
	                this.rank = k;
	                return;
	            }
	            var pk = this.permutation[nextColumn];
	            this.permutation[nextColumn] = this.permutation[k];
	            this.permutation[k] = pk;
	
	            // choose alpha such that Hk.u = alpha ek
	            var akk = this.weightedJacobian[k][pk];
	            var alpha = akk > 0 ? -Math.sqrt(ak2) : Math.sqrt(ak2);
	            var betak = 1.0 / (ak2 - akk * alpha);
	            this.beta[pk] = betak;
	
	            // transform the current column
	            this.diagR[pk] = alpha;
	            this.weightedJacobian[k][pk] -= alpha;
	
	            // transform the remaining columns
	            for (var dk = nC - 1 - k; dk > 0; --dk) {
	                var gamma = 0;
	                for (var j = k; j < nR; ++j) {
	                    gamma += this.weightedJacobian[j][pk] * this.weightedJacobian[j][this.permutation[k + dk]];
	                }
	                gamma *= betak;
	                for (var j = k; j < nR; ++j) {
	                    this.weightedJacobian[j][this.permutation[k + dk]] -= gamma * this.weightedJacobian[j][pk];
	                }
	            }
	        }
	        this.rank = this.solvedCols;
	    };
	
	    /**
	     * Compute the product Qt.y for some Q.R. decomposition.
	     *
	     * @param y vector to multiply (will be overwritten with the result)
	     */
	    this.qTy = function (y) {
	        var nR = this.weightedJacobian.length;
	        var nC = this.weightedJacobian[0].length;
	
	        for (var k = 0; k < nC; ++k) {
	            var pk = this.permutation[k];
	            var gamma = 0;
	            for (var i = k; i < nR; ++i) {
	                gamma += this.weightedJacobian[i][pk] * y[i];
	            }
	            gamma *= this.beta[pk];
	            for (var i = k; i < nR; ++i) {
	                y[i] -= gamma * this.weightedJacobian[i][pk];
	            }
	        }
	    };
	
	    /**
	     * Computes the weighted Jacobian matrix.
	     *
	     * @param params Model parameters at which to compute the Jacobian.
	     * @return the weighted Jacobian: W<sup>1/2</sup> J.
	     * @throws DimensionMismatchException if the Jacobian dimension does not
	     * match problem dimension.
	     */
	    this.computeWeightedJacobian = function (params) {
	        //        return this.weightMatrixSqrt.multiply(this.jacobian(params));
	
	        //TODO: since weighted matrix is always identity return jacobian itself
	        return this.jacobian(params);
	    };
	
	    this.scalarMultiply = function (m, s) {
	        var rowCount = m.length;
	        var columnCount = m[0].length;
	        var out = [];
	        for (var row = 0; row < rowCount; ++row) {
	            out.push([]);
	            for (var col = 0; col < columnCount; ++col) {
	                out[row].push(m[row][col] * s);
	            }
	        }
	
	        return out;
	    };
	
	    this.operate = function (m, v) {
	        var nRows = m.length;
	        var nCols = m[0].length;
	        if (v.length != nCols) {
	            throw "DimensionMismatchException: " + v.length + "!=" + nCols;
	        }
	        var out = [];
	        for (var row = 0; row < nRows; row++) {
	            var dataRow = m[row];
	            var sum = 0;
	            for (var i = 0; i < nCols; i++) {
	                sum += dataRow[i] * v[i];
	            }
	            out[row] = sum;
	        }
	        return out;
	    };
	
	    /**
	     * Computes the cost.
	     *
	     * @param residuals Residuals.
	     * @return the cost.
	     * @see #computeResiduals(double[])
	     */
	    this.computeCost = function (residuals) {
	        return Math.sqrt(this.dotProduct(residuals, this.operate(this.getWeight(), residuals)));
	    };
	
	    this.dotProduct = function (v1, v2) {
	        var dot = 0;
	        for (var i = 0; i < v1.length; i++) {
	            dot += v1[i] * v2[i];
	        }
	        return dot;
	    };
	
	    /**
	     * Gets the root-mean-square (RMS) value.
	     *
	     * The RMS the root of the arithmetic mean of the square of all weighted
	     * residuals.
	     * This is related to the criterion that is minimized by the optimizer
	     * as follows: If <em>c</em> if the criterion, and <em>n</em> is the
	     * number of measurements, then the RMS is <em>sqrt (c/n)</em>.
	     *
	     * @return the RMS value.
	     */
	    this.getRMS = function () {
	        return Math.sqrt(this.getChiSquare() / this.target.length);
	    };
	
	    /**
	     * Get a Chi-Square-like value assuming the N residuals follow N
	     * distinct normal distributions centered on 0 and whose variances are
	     * the reciprocal of the weights.
	     * @return chi-square value
	     */
	    this.getChiSquare = function () {
	        return this.cost * this.cost;
	    };
	
	    /**
	     * Gets the square-root of the weight matrix.
	     *
	     * @return the square-root of the weight matrix.
	     */
	    this.getWeightSquareRoot = function () {
	        return this.weightMatrixSqrt; //.copy(); FIXME for now it's always identity
	    };
	
	    this.getWeight = function () {
	        return this.weightMatrix; //.copy(); FIXME for now it's always identity
	    };
	
	    /**
	     * Sets the cost.
	     *
	     * @param cost Cost value.
	     */
	    this.setCost = function (cost) {
	        this.cost = cost;
	    };
	
	    /**
	     * Computes the residuals.
	     * The residual is the difference between the observed (target)
	     * values and the model (objective function) value.
	     * There is one residual for each element of the vector-valued
	     * function.
	     *
	     * @param objectiveValue Value of the the objective function. This is
	     * the value returned from a call to
	     * {@link #computeObjectiveValue(double[]) computeObjectiveValue}
	     * (whose array argument contains the model parameters).
	     * @return the residuals.
	     * @throws DimensionMismatchException if {@code params} has a wrong
	     * length.
	     */
	    this.computeResiduals = function (objectiveValue) {
	        var target = this.target;
	        if (objectiveValue.length != target.length) {
	            throw "DimensionMismatchException: " + target.length + " != " + objectiveValue.length;
	        }
	
	        var residuals = arr(target.length);
	        for (var i = 0; i < target.length; i++) {
	            residuals[i] = target[i] - objectiveValue[i];
	        }
	
	        return residuals;
	    };
	
	    this.computeObjectiveValue = function (params) {
	        if (++this.evalCount > this.evalMaximalCount) {
	            throw "TOO MANY FUNCTION EVALUATION";
	        }
	        return this.model(params);
	    };
	}

/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ConstantWrapper = exports.EqualsTo = exports.createByConstraintName = undefined;
	
	var _utils = __webpack_require__(330);
	
	/**
	 * This intermediate layer should be eliminated since constraint server isn't used anymore
	 */
	function createByConstraintName(name, params, values) {
	  switch (name) {
	    case "equal":
	      return new Equal(params);
	    case "equalsTo":
	      return new EqualsTo(params, values[0]);
	    case "Diff":
	      return new Diff(params, values[0]);
	    case "MinLength":
	      return new MinLength(params, values[0]);
	    case "perpendicular":
	      return new Perpendicular(params);
	    case "parallel":
	      return new Parallel(params);
	    case "P2LDistanceSigned":
	      return new P2LDistanceSigned(params, values[0]);
	    case "P2LDistance":
	      return new P2LDistance(params, values[0]);
	    case "P2LDistanceV":
	      return new P2LDistanceV(params);
	    case "P2PDistance":
	      return new P2PDistance(params, values[0]);
	    case "P2PDistanceV":
	      return new P2PDistanceV(params);
	    case "PointOnEllipse":
	      return new PointOnEllipse(params);
	    case "EllipseTangent":
	      return new EllipseTangent(params);
	    case "angle":
	      return new Angle(params);
	    case "angleConst":
	      var _ = true,
	          x = false;
	      // Exclude angle value from parameters
	      return new ConstantWrapper(new Angle(params), [x, x, x, x, x, x, x, x, _]);
	    case 'LockConvex':
	      return new LockConvex(params);
	    case 'GreaterThan':
	      return new GreaterThan(params, values[0]);
	
	  }
	}
	
	function Equal(params) {
	
	  this.params = params;
	
	  this.error = function () {
	    return this.params[0].get() - this.params[1].get();
	  };
	
	  this.gradient = function (out) {
	    out[0] = 1;
	    out[1] = -1;
	  };
	}
	
	function MinLength(params, distance) {
	
	  this.params = params;
	  this.distance = distance;
	
	  var p1x = 0;
	  var p1y = 1;
	  var p2x = 2;
	  var p2y = 3;
	
	  this.error = function () {
	    var dx = params[p1x].get() - params[p2x].get();
	    var dy = params[p1y].get() - params[p2y].get();
	    var d = Math.sqrt(dx * dx + dy * dy);
	    return d < this.distance ? d - this.distance : 0;
	  };
	
	  this.gradient = function (out) {
	    var dx = params[p1x].get() - params[p2x].get();
	    var dy = params[p1y].get() - params[p2y].get();
	    var d = Math.sqrt(dx * dx + dy * dy);
	    if (d == 0) {
	      d = 0.000001;
	    }
	    if (d >= this.distance) {
	      out[p1x] = 0;
	      out[p1y] = 0;
	      out[p2x] = 0;
	      out[p2y] = 0;
	    }
	    out[p1x] = dx / d;
	    out[p1y] = dy / d;
	    out[p2x] = -dx / d;
	    out[p2y] = -dy / d;
	  };
	}
	
	function LockConvex(params) {
	  this.params = params;
	
	  var _pcx = 0;
	  var _pcy = 1;
	  var _pax = 2;
	  var _pay = 3;
	  var _ptx = 4;
	  var _pty = 5;
	
	  this.error = function () {
	    var cx = params[_pcx].get();
	    var cy = params[_pcy].get();
	    var ax = params[_pax].get();
	    var ay = params[_pay].get();
	    var tx = params[_ptx].get();
	    var ty = params[_pty].get();
	
	    var crossProductNorm = (cx - ax) * (ty - ay) - (cy - ay) * (tx - ax);
	
	    var violate = crossProductNorm < 0;
	    return violate ? crossProductNorm : 0;
	  };
	
	  this.gradient = function (out) {
	    var cx = params[_pcx].get();
	    var cy = params[_pcy].get();
	    var ax = params[_pax].get();
	    var ay = params[_pay].get();
	    var tx = params[_ptx].get();
	    var ty = params[_pty].get();
	
	    out[_pcx] = ty - ay;
	    out[_pcy] = ax - tx;
	    out[_pax] = cy - ty;
	    out[_pay] = tx - cx;
	    out[_ptx] = ay - cy;
	    out[_pty] = cx - ax;
	  };
	}
	
	function ConstantWrapper(constr, mask) {
	
	  this.params = [];
	  this.grad = [];
	
	  for (var j = 0; j < constr.params.length; j++) {
	    if (!mask[j]) {
	      this.params.push(constr.params[j]);
	    }
	    this.grad.push(0);
	  }
	
	  this.error = function () {
	    return constr.error();
	  };
	
	  this.gradient = function (out) {
	    (0, _utils.fillArray)(this.grad, 0, this.grad.length, 0);
	    constr.gradient(this.grad);
	    var jj = 0;
	    for (var _j = 0; _j < mask.length; _j++) {
	      if (!mask[_j]) {
	        out[jj++] = this.grad[_j];
	      }
	    }
	  };
	}
	
	function Weighted(constr, weight) {
	
	  this.weight = weight;
	  this.params = constr.params;
	  this.constr = constr;
	
	  this.error = function () {
	    return constr.error() * this.weight;
	  };
	
	  this.gradient = function (out) {
	    constr.gradient(out);
	    for (var i = 0; i < out.length; i++) {
	      out[i] *= this.weight;
	    }
	  };
	}
	
	function EqualsTo(params, value) {
	
	  this.params = params;
	  this.value = value;
	
	  this.error = function () {
	    return this.params[0].get() - this.value;
	  };
	
	  this.gradient = function (out) {
	    out[0] = 1;
	  };
	}
	
	function Diff(params, value) {
	
	  this.params = params;
	  this.value = value;
	
	  this.error = function () {
	    return this.params[0].get() - this.params[1].get() - this.value;
	  };
	
	  this.gradient = function (out) {
	    out[0] = 1;
	    out[1] = -1;
	  };
	}
	
	function P2LDistanceSigned(params, value) {
	
	  var TX = 0;
	  var TY = 1;
	  var AX = 2;
	  var AY = 3;
	  var BX = 4;
	  var BY = 5;
	
	  this.params = params;
	  this.value = value;
	
	  this.error = function () {
	    var tx = params[TX].get(),
	        ax = params[AX].get(),
	        bx = params[BX].get();
	    var ty = params[TY].get(),
	        ay = params[AY].get(),
	        by = params[BY].get();
	    var d = Math.sqrt(sq(by - ay) + sq(bx - ax));
	
	    return -(by - ay) * (tx - ax) / d + (bx - ax) * (ty - ay) / d - this.value;
	  };
	
	  this.gradient = NumericGradient;
	}
	
	function P2LDistance(params, distance) {
	
	  this.params = params;
	  this.distance = distance;
	
	  var TX = 0;
	  var TY = 1;
	  var LP1X = 2;
	  var LP1Y = 3;
	  var LP2X = 4;
	  var LP2Y = 5;
	
	  this.error = function () {
	    var x0 = params[TX].get(),
	        x1 = params[LP1X].get(),
	        x2 = params[LP2X].get();
	    var y0 = params[TY].get(),
	        y1 = params[LP1Y].get(),
	        y2 = params[LP2Y].get();
	    var dx = x2 - x1;
	    var dy = y2 - y1;
	    var d = Math.sqrt(dx * dx + dy * dy);
	    if (d == 0) {
	      return 0;
	    }
	    var A = -x0 * dy + y0 * dx + x1 * y2 - x2 * y1;
	    return Math.abs(A) / d - this.distance;
	  };
	
	  this.gradient = function (out) {
	    var x0 = params[TX].get(),
	        x1 = params[LP1X].get(),
	        x2 = params[LP2X].get();
	    var y0 = params[TY].get(),
	        y1 = params[LP1Y].get(),
	        y2 = params[LP2Y].get();
	    var dx = x2 - x1;
	    var dy = y2 - y1;
	    var d2 = dx * dx + dy * dy;
	    var d = Math.sqrt(d2);
	    var d3 = d * d2;
	    //    var AA = -x0 * (y2 - y1) + y0 * (x2 - x1) + x1 * y2 - x2 * y1;
	    var A = -x0 * dy + y0 * dx + x1 * y2 - x2 * y1;
	    var AM = Math.abs(A);
	    var j = A < 0 ? -1 : 1;
	
	    out[TX] = j * (y1 - y2) / d;
	    out[TY] = j * (x2 - x1) / d;
	
	    out[LP1X] = j * (y2 - y0) / d + AM * dx / d3;
	    out[LP1Y] = j * (x0 - x2) / d + AM * dy / d3;
	    out[LP2X] = j * (y0 - y1) / d - AM * dx / d3;
	    out[LP2Y] = j * (x1 - x0) / d - AM * dy / d3;
	
	    _fixNaN(out);
	  };
	}
	
	function P2LDistanceV(params) {
	
	  this.params = params; //.slice(0, params.length -1);
	
	  var TX = 0;
	  var TY = 1;
	  var LP1X = 2;
	  var LP1Y = 3;
	  var LP2X = 4;
	  var LP2Y = 5;
	  var D = 6;
	
	  this.error = function () {
	    var x0 = params[TX].get(),
	        x1 = params[LP1X].get(),
	        x2 = params[LP2X].get();
	    var y0 = params[TY].get(),
	        y1 = params[LP1Y].get(),
	        y2 = params[LP2Y].get();
	    var dist = this.params[D].get();
	    var dx = x2 - x1;
	    var dy = y2 - y1;
	    var d = Math.sqrt(dx * dx + dy * dy);
	    if (d == 0) {
	      return 0;
	    }
	    var A = -x0 * dy + y0 * dx + x1 * y2 - x2 * y1;
	    return Math.abs(A) / d - dist;
	  };
	
	  this.gradient = function (out) {
	    var x0 = params[TX].get(),
	        x1 = params[LP1X].get(),
	        x2 = params[LP2X].get();
	    var y0 = params[TY].get(),
	        y1 = params[LP1Y].get(),
	        y2 = params[LP2Y].get();
	    var dx = x2 - x1;
	    var dy = y2 - y1;
	    var d2 = dx * dx + dy * dy;
	    var d = Math.sqrt(d2);
	    var d3 = d * d2;
	    //    var AA = -x0 * (y2 - y1) + y0 * (x2 - x1) + x1 * y2 - x2 * y1;
	    var A = -x0 * dy + y0 * dx + x1 * y2 - x2 * y1;
	    var AM = Math.abs(A);
	    var j = A < 0 ? -1 : 1;
	
	    out[TX] = j * (y1 - y2) / d;
	    out[TY] = j * (x2 - x1) / d;
	
	    out[LP1X] = j * (y2 - y0) / d + AM * dx / d3;
	    out[LP1Y] = j * (x0 - x2) / d + AM * dy / d3;
	    out[LP2X] = j * (y0 - y1) / d - AM * dx / d3;
	    out[LP2Y] = j * (x1 - x0) / d - AM * dy / d3;
	    out[D] = -1;
	
	    _fixNaN(out);
	  };
	}
	
	function P2PDistance(params, distance) {
	
	  this.params = params;
	  this.distance = distance;
	
	  var p1x = 0;
	  var p1y = 1;
	  var p2x = 2;
	  var p2y = 3;
	
	  this.error = function () {
	    var dx = params[p1x].get() - params[p2x].get();
	    var dy = params[p1y].get() - params[p2y].get();
	    var d = Math.sqrt(dx * dx + dy * dy);
	    return d - this.distance;
	  };
	
	  this.gradient = function (out) {
	    var dx = params[p1x].get() - params[p2x].get();
	    var dy = params[p1y].get() - params[p2y].get();
	    var d = Math.sqrt(dx * dx + dy * dy);
	    if (d == 0) {
	      if (this.distance == 0) return;
	      d = 0.000001;
	    }
	    out[p1x] = dx / d;
	    out[p1y] = dy / d;
	    out[p2x] = -dx / d;
	    out[p2y] = -dy / d;
	  };
	}
	
	function P2PDistanceV(params) {
	
	  this.params = params;
	
	  var p1x = 0;
	  var p1y = 1;
	  var p2x = 2;
	  var p2y = 3;
	  var D = 4;
	
	  this.error = function () {
	    var dx = params[p1x].get() - params[p2x].get();
	    var dy = params[p1y].get() - params[p2y].get();
	    var d = Math.sqrt(dx * dx + dy * dy);
	    return d - params[D].get();
	  };
	
	  this.gradient = function (out) {
	    var dx = params[p1x].get() - params[p2x].get();
	    var dy = params[p1y].get() - params[p2y].get();
	    var d = Math.sqrt(dx * dx + dy * dy);
	    if (d == 0) {
	      if (params[D].get() == 0) return;
	      d = 0.000001;
	    }
	    out[p1x] = dx / d;
	    out[p1y] = dy / d;
	    out[p2x] = -dx / d;
	    out[p2y] = -dy / d;
	    out[D] = -1;
	  };
	}
	
	function Parallel(params) {
	
	  this.params = params;
	
	  var l1p1x = 0;
	  var l1p1y = 1;
	  var l1p2x = 2;
	  var l1p2y = 3;
	  var l2p1x = 4;
	  var l2p1y = 5;
	  var l2p2x = 6;
	  var l2p2y = 7;
	
	  this.error = function () {
	    var dx1 = params[l1p1x].get() - params[l1p2x].get();
	    var dy1 = params[l1p1y].get() - params[l1p2y].get();
	    var dx2 = params[l2p1x].get() - params[l2p2x].get();
	    var dy2 = params[l2p1y].get() - params[l2p2y].get();
	    return dx1 * dy2 - dy1 * dx2;
	  };
	
	  this.gradient = function (out) {
	    out[l1p1x] = params[l2p1y].get() - params[l2p2y].get();
	    out[l1p2x] = -(params[l2p1y].get() - params[l2p2y].get());
	    out[l1p1y] = -(params[l2p1x].get() - params[l2p2x].get());
	    out[l1p2y] = params[l2p1x].get() - params[l2p2x].get();
	    out[l2p1x] = -(params[l1p1y].get() - params[l1p2y].get());
	    out[l2p2x] = params[l1p1y].get() - params[l1p2y].get();
	    out[l2p1y] = params[l1p1x].get() - params[l1p2x].get();
	    out[l2p2y] = -(params[l1p1x].get() - params[l1p2x].get());
	  };
	}
	
	function Perpendicular(params) {
	
	  this.params = params;
	
	  var l1p1x = 0;
	  var l1p1y = 1;
	  var l1p2x = 2;
	  var l1p2y = 3;
	  var l2p1x = 4;
	  var l2p1y = 5;
	  var l2p2x = 6;
	  var l2p2y = 7;
	
	  this.error = function () {
	    var dx1 = params[l1p1x].get() - params[l1p2x].get();
	    var dy1 = params[l1p1y].get() - params[l1p2y].get();
	    var dx2 = params[l2p1x].get() - params[l2p2x].get();
	    var dy2 = params[l2p1y].get() - params[l2p2y].get();
	    //dot product shows how the lines off to be perpendicular
	    return dx1 * dx2 + dy1 * dy2;
	  };
	
	  this.gradient = function (out) {
	    out[l1p1x] = params[l2p1x].get() - params[l2p2x].get();
	    out[l1p2x] = -(params[l2p1x].get() - params[l2p2x].get());
	    out[l1p1y] = params[l2p1y].get() - params[l2p2y].get();
	    out[l1p2y] = -(params[l2p1y].get() - params[l2p2y].get());
	    out[l2p1x] = params[l1p1x].get() - params[l1p2x].get();
	    out[l2p2x] = -(params[l1p1x].get() - params[l1p2x].get());
	    out[l2p1y] = params[l1p1y].get() - params[l1p2y].get();
	    out[l2p2y] = -(params[l1p1y].get() - params[l1p2y].get());
	  };
	}
	
	function Angle(params) {
	
	  this.params = params;
	
	  var l1p1x = 0;
	  var l1p1y = 1;
	  var l1p2x = 2;
	  var l1p2y = 3;
	  var l2p1x = 4;
	  var l2p1y = 5;
	  var l2p2x = 6;
	  var l2p2y = 7;
	  var angle = 8;
	  var scale = 1000; // we need scale to get same order of measure units(radians are to small)
	
	  function p(ref) {
	    return params[ref].get();
	  }
	
	  this.error = function () {
	    var dx1 = p(l1p2x) - p(l1p1x);
	    var dy1 = p(l1p2y) - p(l1p1y);
	    var dx2 = p(l2p2x) - p(l2p1x);
	    var dy2 = p(l2p2y) - p(l2p1y);
	    var a = Math.atan2(dy1, dx1) + p(angle);
	    var ca = Math.cos(a);
	    var sa = Math.sin(a);
	    var x2 = dx2 * ca + dy2 * sa;
	    var y2 = -dx2 * sa + dy2 * ca;
	    return Math.atan2(y2, x2) * scale;
	  };
	
	  this.gradient = function (out) {
	    var dx1 = p(l1p2x) - p(l1p1x);
	    var dy1 = p(l1p2y) - p(l1p1y);
	    var r2 = dx1 * dx1 + dy1 * dy1;
	    out[l1p1x] = -dy1 / r2;
	    out[l1p1y] = dx1 / r2;
	    out[l1p2x] = dy1 / r2;
	    out[l1p2y] = -dx1 / r2;
	    dx1 = p(l1p2x) - p(l1p1x);
	    dy1 = p(l1p2y) - p(l1p1y);
	    var dx2 = p(l2p2x) - p(l2p1x);
	    var dy2 = p(l2p2y) - p(l2p1y);
	    var a = Math.atan2(dy1, dx1) + p(angle);
	    var ca = Math.cos(a);
	    var sa = Math.sin(a);
	    var x2 = dx2 * ca + dy2 * sa;
	    var y2 = -dx2 * sa + dy2 * ca;
	    r2 = dx2 * dx2 + dy2 * dy2;
	    dx2 = -y2 / r2;
	    dy2 = x2 / r2;
	    out[l2p1x] = -ca * dx2 + sa * dy2;
	    out[l2p1y] = -sa * dx2 - ca * dy2;
	    out[l2p2x] = ca * dx2 - sa * dy2;
	    out[l2p2y] = sa * dx2 + ca * dy2;
	    out[angle] = -1;
	    rescale(out, scale);
	  };
	}
	
	function PointOnEllipse(params) {
	
	  this.params = params;
	
	  var PX = 0;
	  var PY = 1;
	  var EP1X = 2;
	  var EP1Y = 3;
	  var EP2X = 4;
	  var EP2Y = 5;
	  var R = 6;
	
	  this.error = function () {
	    var px = params[PX].get();
	    var py = params[PY].get();
	    var ep1x = params[EP1X].get();
	    var ep1y = params[EP1Y].get();
	    var ep2x = params[EP2X].get();
	    var ep2y = params[EP2Y].get();
	    var radiusY = params[R].get();
	
	    var centerX = ep1x + (ep2x - ep1x) * 0.5;
	    var centerY = ep1y + (ep2y - ep1y) * 0.5;
	    var rotation = Math.atan2(ep2y - ep1y, ep2x - ep1x);
	
	    var x = px - centerX;
	    var y = py - centerY;
	
	    var polarAngle = Math.atan2(y, x) - rotation;
	    var polarRadius = Math.sqrt(x * x + y * y);
	    var radiusX = Math.sqrt(sq(ep1x - ep2x) + sq(ep1y - ep2y)) * 0.5;
	
	    var L = Math.sqrt(1 / (sq(Math.cos(polarAngle) / radiusX) + sq(Math.sin(polarAngle) / radiusY)));
	    return L - polarRadius;
	  };
	
	  this.gradient = NumericGradient;
	}
	
	function EllipseTangent(params) {
	
	  this.params = params;
	
	  var P1X = 0;
	  var P1Y = 1;
	  var P2X = 2;
	  var P2Y = 3;
	  var EP1X = 4;
	  var EP1Y = 5;
	  var EP2X = 6;
	  var EP2Y = 7;
	  var R = 8;
	
	  this.error = function (gr) {
	    var p1x = params[P1X].get();
	    var p1y = params[P1Y].get();
	    var p2x = params[P2X].get();
	    var p2y = params[P2Y].get();
	
	    var ep1x = params[EP1X].get();
	    var ep1y = params[EP1Y].get();
	    var ep2x = params[EP2X].get();
	    var ep2y = params[EP2Y].get();
	
	    var radiusY = params[R].get();
	
	    var axisX = ep2x - ep1x;
	    var axisY = ep2y - ep1y;
	    var radiusX = Math.sqrt(sq(axisX) + sq(axisY)) * 0.5;
	    var scaleToCircleSpace = radiusY / radiusX;
	    var rotation = -Math.atan2(axisY, axisX);
	    function tr(x, y) {
	      var xx = x * Math.cos(rotation) - y * Math.sin(rotation);
	      var yy = x * Math.sin(rotation) + y * Math.cos(rotation);
	      xx *= scaleToCircleSpace;
	      return { x: xx, y: yy };
	    }
	
	    var axis = tr(axisX, axisY);
	    var p1 = tr(p1x, p1y);
	    var p2 = tr(p2x, p2y);
	    var ep1 = tr(ep1x, ep1y);
	
	    var centerX = ep1.x + axis.x * 0.5;
	    var centerY = ep1.y + axis.y * 0.5;
	
	    var normalX = -(p2.y - p1.y);
	    var normalY = p2.x - p1.x;
	
	    var normalD = Math.sqrt(sq(normalX) + sq(normalY));
	    normalX /= normalD;
	    normalY /= normalD;
	
	    //this length of normal of line to center 
	    var perpendicularLength = (centerX - p1.x) * normalX + (centerY - p1.y) * normalY;
	
	    if (perpendicularLength < 0) {
	      perpendicularLength *= -1;
	    } else {}
	
	    return radiusY - perpendicularLength; //*1000;
	  };
	
	  this.gradient = NumericGradient;
	}
	
	function GreaterThan(params, limit) {
	
	  this.params = params;
	
	  this.error = function () {
	    var value = this.params[0].get();
	    var error = value <= limit ? limit - value : 0;
	    console.log("GreaterThan: " + error + ", value: " + value);
	    return error;
	  };
	
	  this.gradient = function (out) {
	    out[0] = -1;
	  };
	}
	
	function NumericGradient(out) {
	  var _this = this;
	
	  var h = 1;
	  var approx = function approx(param) {
	    var fx = _this.error();
	    _this.params[param].set(_this.params[param].get() + h);
	    var fhx = _this.error();
	    _this.params[param].set(_this.params[param].get() - h);
	    return (fhx - fx) / h;
	  };
	
	  for (var i = 0; i < out.length; i++) {
	    out[i] = approx(i);
	  }
	}
	
	function _fixNaN(grad) {
	  for (var i = 0; i < grad.length; i++) {
	    if (isNaN(grad[i])) {
	      grad[i] = 0;
	    }
	  }
	}
	
	function rescale(grad, factor) {
	  for (var i = 0; i < grad.length; i++) {
	    grad[i] *= factor;
	  }
	}
	
	var sq = function sq(x) {
	  return x * x;
	};
	
	exports.createByConstraintName = createByConstraintName;
	exports.EqualsTo = EqualsTo;
	exports.ConstantWrapper = ConstantWrapper;

/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.optim = exports.dog_leg = undefined;
	
	var _numeric = __webpack_require__(422);
	
	var _numeric2 = _interopRequireDefault(_numeric);
	
	var _math = __webpack_require__(304);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	//Added strong wolfe condition to numeric's uncmin
	var bfgs_ = function bfgs_(f, x0, tol, gradient, maxit, callback, options) {
	  var grad = _numeric2.default.gradient;
	  if (typeof options === "undefined") {
	    options = {};
	  }
	  if (typeof tol === "undefined") {
	    tol = 1e-8;
	  }
	  if (typeof gradient === "undefined") {
	    gradient = function gradient(x) {
	      return grad(f, x);
	    };
	  }
	  if (typeof maxit === "undefined") maxit = 1000;
	  x0 = _numeric2.default.clone(x0);
	  var n = x0.length;
	  var f0 = f(x0),
	      f1,
	      df0;
	  if (isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
	  var max = Math.max,
	      norm2 = _numeric2.default.norm2;
	  tol = max(tol, _numeric2.default.epsilon);
	  var step,
	      g0,
	      g1,
	      H1 = options.Hinv || _numeric2.default.identity(n);
	  var dot = _numeric2.default.dot,
	      inv = _numeric2.default.inv,
	      sub = _numeric2.default.sub,
	      add = _numeric2.default.add,
	      ten = _numeric2.default.tensor,
	      div = _numeric2.default.div,
	      mul = _numeric2.default.mul;
	  var all = _numeric2.default.all,
	      isfinite = _numeric2.default.isFinite,
	      neg = _numeric2.default.neg;
	  var it = 0,
	      i,
	      s,
	      x1,
	      y,
	      Hy,
	      Hs,
	      ys,
	      i0,
	      t,
	      nstep,
	      t1,
	      t2;
	  var msg = "";
	  g0 = gradient(x0);
	  while (it < maxit) {
	    if (typeof callback === "function") {
	      if (callback(it, x0, f0, g0, H1)) {
	        msg = "Callback returned true";break;
	      }
	    }
	    if (!all(isfinite(g0))) {
	      msg = "Gradient has Infinity or NaN";break;
	    }
	    step = neg(dot(H1, g0));
	    if (!all(isfinite(step))) {
	      msg = "Search direction has Infinity or NaN";break;
	    }
	    nstep = norm2(step);
	    if (nstep < tol) {
	      msg = "Newton step smaller than tol";break;
	    }
	    t = 1;
	    df0 = dot(g0, step);
	    // line search
	    x1 = x0;
	    var tL = 0;
	    var tR = 100;
	    while (it < maxit) {
	      if (t * nstep < tol) {
	        break;
	      }
	      s = mul(step, t);
	      x1 = add(x0, s);
	      f1 = f(x1);
	      //Nocadel, 3.7(a,b)
	      if (f1 - f0 >= 0.1 * t * df0 || isNaN(f1)) {
	        tR = t;
	        t = (tL + tR) * 0.5;
	        ++it;
	      } else {
	        var slope = dot(gradient(x1), step);
	        if (slope <= 0.9 * Math.abs(df0)) {
	          break;
	        } else if (slope >= 0.9 * df0) {
	          tR = t;
	          t = (tL + tR) * 0.5;
	        } else {
	          tL = t;
	          t = (tL + tR) * 0.5;
	        }
	      }
	    }
	    if (t * nstep < tol) {
	      msg = "Line search step size smaller than tol";break;
	    }
	    if (it === maxit) {
	      msg = "maxit reached during line search";break;
	    }
	    g1 = gradient(x1);
	    y = sub(g1, g0);
	    ys = dot(y, s);
	    Hy = dot(H1, y);
	
	    // BFGS update on H1
	    H1 = sub(add(H1, mul((ys + dot(y, Hy)) / (ys * ys), ten(s, s))), div(add(ten(Hy, s), ten(s, Hy)), ys));
	    x0 = x1;
	    f0 = f1;
	    g0 = g1;
	    ++it;
	  }
	  return { solution: x0, f: f0, gradient: g0, invHessian: H1, iterations: it, message: msg };
	};
	
	var bfgs = function bfgs(f, x0, tol, gradient, maxit, callback, options) {
	  var grad = _numeric2.default.gradient;
	  if (typeof options === "undefined") {
	    options = {};
	  }
	  if (typeof tol === "undefined") {
	    tol = 1e-8;
	  }
	  if (typeof gradient === "undefined") {
	    gradient = function gradient(x) {
	      return grad(f, x);
	    };
	  }
	  if (typeof maxit === "undefined") maxit = 1000;
	  x0 = _numeric2.default.clone(x0);
	  var n = x0.length;
	  var f0 = f(x0),
	      f1,
	      df0;
	  if (isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
	  var max = Math.max,
	      norm2 = _numeric2.default.norm2;
	  tol = max(tol, _numeric2.default.epsilon);
	  var step,
	      g0,
	      g1,
	      H1 = options.Hinv || _numeric2.default.identity(n);
	  var dot = _numeric2.default.dot,
	      inv = _numeric2.default.inv,
	      sub = _numeric2.default.sub,
	      add = _numeric2.default.add,
	      ten = _numeric2.default.tensor,
	      div = _numeric2.default.div,
	      mul = _numeric2.default.mul;
	  var all = _numeric2.default.all,
	      isfinite = _numeric2.default.isFinite,
	      neg = _numeric2.default.neg;
	  var it = 0,
	      i,
	      s,
	      x1,
	      y,
	      Hy,
	      Hs,
	      ys,
	      i0,
	      t,
	      nstep,
	      t1,
	      t2;
	  var msg = "";
	  g0 = gradient(x0);
	  while (it < maxit) {
	    if (typeof callback === "function") {
	      if (callback(it, x0, f0, g0, H1)) {
	        msg = "Callback returned true";break;
	      }
	    }
	    if (!all(isfinite(g0))) {
	      msg = "Gradient has Infinity or NaN";break;
	    }
	    step = neg(dot(H1, g0));
	    if (!all(isfinite(step))) {
	      msg = "Search direction has Infinity or NaN";break;
	    }
	    nstep = norm2(step);
	    if (nstep < tol) {
	      msg = "Newton step smaller than tol";break;
	    }
	
	    df0 = dot(g0, step);
	    // line search
	    t1 = 0.0;
	    f1 = f0;
	
	    t2 = 1.0;
	    s = mul(step, t2);
	    x1 = add(x0, s);
	    var f2 = f(x1);
	
	    var t3 = 2.0;
	    s = mul(step, t3);
	    x1 = add(x0, s);
	    var f3 = f(x1);
	    var tMax = 1e23;
	
	    while ((f2 > f1 || f2 > f3) && it < maxit) {
	      if (t * nstep < tol) {
	        break;
	      }
	      if (f2 > f1) {
	        //If f2 is greater than f1 then we shorten alpha2 and alpha3 closer to f1
	        //Effectively both are shortened by a factor of two.
	        t3 = t2;
	        f3 = f2;
	        t2 = t2 / 2;
	
	        s = mul(step, t2);
	        x1 = add(x0, s);
	        f2 = f(x1);
	      } else if (f2 > f3) {
	        if (t3 >= tMax) break;
	        //If f2 is greater than f3 then we increase alpha2 and alpha3 away from f1
	        //Effectively both are lengthened by a factor of two.
	        t2 = t3;
	        f2 = f3;
	        t3 = t3 * 2;
	
	        s = mul(step, t3);
	        x1 = add(x0, s);
	        f3 = f(x1);
	      }
	      it++;
	    }
	
	    //Get the alpha for the minimum f of the quadratic approximation
	    var ts = t2 + (t2 - t1) * (f1 - f3) / (3 * (f1 - 2 * f2 + f3));
	
	    //Guarantee that the new alphaStar is within the bracket
	    if (ts >= t3 || ts <= t1) ts = t2;
	
	    if (ts > tMax) ts = tMax;
	
	    if (ts != ts) ts = 0.;
	
	    //Take a final step to alphaStar
	    s = mul(step, ts);
	    x1 = add(x0, s);
	    f1 = f(x1);
	
	    if (t * nstep < tol) {
	      msg = "Line search step size smaller than tol";break;
	    }
	    if (it === maxit) {
	      msg = "maxit reached during line search";break;
	    }
	    g1 = gradient(x1);
	    y = sub(g1, g0);
	    ys = dot(y, s);
	    Hy = dot(H1, y);
	
	    // BFGS update on H1
	    H1 = sub(add(H1, mul((ys + dot(y, Hy)) / (ys * ys), ten(s, s))), div(add(ten(Hy, s), ten(s, Hy)), ys));
	    x0 = x1;
	    f0 = f1;
	    g0 = g1;
	    ++it;
	  }
	  return { solution: x0, f: f0, gradient: g0, invHessian: H1, iterations: it, message: msg };
	};
	
	var bfgs_updater = function bfgs_updater(gradient, x0) {
	  var n = x0.length;
	  var max = Math.max,
	      norm2 = _numeric2.default.norm2;
	  var g0,
	      g1,
	      H1 = _numeric2.default.identity(n);
	  var dot = _numeric2.default.dot,
	      inv = _numeric2.default.inv,
	      sub = _numeric2.default.sub,
	      add = _numeric2.default.add,
	      ten = _numeric2.default.tensor,
	      div = _numeric2.default.div,
	      mul = _numeric2.default.mul;
	  var all = _numeric2.default.all,
	      isfinite = _numeric2.default.isFinite,
	      neg = _numeric2.default.neg;
	  var y, Hy, Hs, ys;
	  var msg = "";
	  g0 = gradient(x0);
	
	  function step() {
	    return neg(dot(H1, g0));
	  }
	
	  function update(x, real_step) {
	    var s = real_step;
	
	    g1 = gradient(x);
	    y = sub(g1, g0);
	    ys = dot(y, s);
	    Hy = dot(H1, y);
	
	    // BFGS update on H1
	    H1 = sub(add(H1, mul((ys + dot(y, Hy)) / (ys * ys), ten(s, s))), div(add(ten(Hy, s), ten(s, Hy)), ys));
	    g0 = g1;
	  }
	  return { step: step, update: update };
	};
	
	var inv = function inv(A) {
	  A = _numeric2.default.clone(A);
	  var s = _numeric2.default.dim(A),
	      abs = Math.abs,
	      m = s[0],
	      n = s[1];
	  var Ai, Aj;
	  var I = _numeric2.default.identity(m),
	      Ii,
	      Ij;
	  var i, j, k, x;
	  for (j = 0; j < n; ++j) {
	    var i0 = -1;
	    var v0 = -1;
	    for (i = j; i !== m; ++i) {
	      k = abs(A[i][j]);if (k > v0) {
	        i0 = i;v0 = k;
	      }
	    }
	    Aj = A[i0];A[i0] = A[j];A[j] = Aj;
	    Ij = I[i0];I[i0] = I[j];I[j] = Ij;
	    x = Aj[j];
	    if (x === 0) {
	      console.log("CAN' INVERSE MATRIX");
	      x = 1e-32;
	    }
	    for (k = j; k !== n; ++k) {
	      Aj[k] /= x;
	    }for (k = n - 1; k !== -1; --k) {
	      Ij[k] /= x;
	    }for (i = m - 1; i !== -1; --i) {
	      if (i !== j) {
	        Ai = A[i];
	        Ii = I[i];
	        x = Ai[j];
	        for (k = j + 1; k !== n; ++k) {
	          Ai[k] -= Aj[k] * x;
	        }for (k = n - 1; k > 0; --k) {
	          Ii[k] -= Ij[k] * x;--k;Ii[k] -= Ij[k] * x;
	        }
	        if (k === 0) Ii[0] -= Ij[0] * x;
	      }
	    }
	  }
	  return I;
	};
	
	var _result = function _result(evalCount, error, returnCode) {
	  this.evalCount = evalCount;
	  this.error = error;
	  this.returnCode = returnCode;
	};
	
	var dog_leg = function dog_leg(subsys, rough) {
	  //rough = true
	  //var tolg = rough ? 1e-3 : 1e-4;
	  var tolg, tolf;
	  if (rough) {
	    tolg = 1e-3;
	    tolf = 1e-3;
	  } else {
	    tolg = 1e-6;
	    tolf = 1e-6;
	  }
	
	  var tolx = 1e-80;
	
	  var xsize = subsys.params.length;
	  var csize = subsys.constraints.length;
	
	  if (xsize == 0) {
	    return new _result(0, 0, 1);
	  }
	
	  var vec = _math._vec;
	  var mx = _math._matrix;
	
	  var n = _numeric2.default;
	
	  var x = vec(xsize);
	  var x_new = vec(xsize);
	
	  var fx = vec(csize);
	  var fx_new = vec(csize);
	
	  var J = mx(csize, xsize);
	  var J_new = mx(csize, xsize);
	  var gn_step = vec(xsize);
	  var dl_step = vec(xsize);
	
	  subsys.fillParams(x);
	  var err = subsys.calcResidual(fx);
	  subsys.fillJacobian(J);
	
	  function lsolve_slow(A, b) {
	    var At = n.transpose(A);
	    var res = n.dot(n.dot(At, inv(n.dot(A, At))), b);
	    return res;
	  }
	
	  function lsolve(A, b) {
	    if (csize < xsize) {
	      var At = n.transpose(A);
	      var sol = n.solve(n.dot(A, At), b, true);
	      return n.dot(At, sol);
	    } else {
	      return n.solve(A, b, false);
	    }
	  }
	
	  var g = n.dot(n.transpose(J), fx);
	  var g_inf = n.norminf(g);
	  var fx_inf = n.norminf(fx);
	
	  var iterLimit = 100;
	  var divergenceLimit = 1e6 * (err + 1e6);
	
	  var delta = 10;
	  var alpha = 0.;
	  var iter = 0,
	      returnCode = 0;
	  //var log = [];
	
	  var SUCCESS = 1,
	      ITER_LIMIT = 2,
	      SMALL_DELTA = 3,
	      SMALL_STEP = 4,
	      DIVERGENCE = 5,
	      INVALID_STATE = 6;
	
	  while (returnCode === 0) {
	    optim.DEBUG_HANDLER(iter, err);
	
	    if (fx_inf <= tolf) {
	      returnCode = SUCCESS;
	    } else if (g_inf <= tolg) {
	      returnCode = SUCCESS;
	    } else if (iter >= iterLimit) {
	      returnCode = ITER_LIMIT;
	    } else if (delta <= tolx * (tolx + n.norm2(x))) {
	      returnCode = SMALL_DELTA;
	    } else if (err > divergenceLimit) {
	      returnCode = DIVERGENCE;
	    } else if (isNaN(err)) {
	      returnCode = INVALID_STATE;
	    }
	
	    if (returnCode != 0) {
	      break;
	    }
	
	    // get the gauss-newton step
	    //gn_step = n.solve(J, n.mul(fx, -1));
	    gn_step = lsolve(J, n.mul(fx, -1));
	
	    //LU-Decomposition
	    //gn_step = lusolve(J, n.mul(fx, -1));
	
	    //Conjugate gradient method
	    //gn_step = cg(J, gn_step, n.mul(fx, -1), 1e-8, iterLimit);
	
	    //solve linear problem using svd formula to get the gauss-newton step
	    //gn_step = lls(J, n.mul(fx, -1));
	
	    var hitBoundary = false;
	
	    var gnorm = n.norm2(g);
	    var gnNorm = n.norm2(gn_step);
	    if (gnNorm < delta) {
	      dl_step = gn_step;
	    } else {
	      var Jt = n.transpose(J);
	      var B = n.dot(Jt, J);
	      var gBg = n.dot(g, n.dot(B, g));
	      alpha = n.norm2Squared(g) / gBg;
	      if (alpha * gnorm >= delta) {
	        dl_step = n.mul(g, -delta / gnorm);
	        hitBoundary = true;
	      } else {
	        var sd_step = n.mul(g, -alpha);
	        if (isNaN(gnNorm)) {
	          dl_step = sd_step;
	        } else {
	
	          var d = n.sub(gn_step, sd_step);
	
	          var a = n.dot(d, d);
	          var b = 2 * n.dot(sd_step, d);
	          var c = n.dot(sd_step, sd_step) - delta * delta;
	
	          var sqrt_discriminant = Math.sqrt(b * b - 4 * a * c);
	
	          var beta = (-b + sqrt_discriminant) / (2 * a);
	
	          dl_step = n.add(sd_step, n.mul(beta, d));
	          hitBoundary = true;
	        }
	      }
	    }
	
	    var dl_norm = n.norm2(dl_step);
	
	    //    if (dl_norm <= tolx) {
	    //      returnCode = SMALL_STEP;
	    //      break;
	    //    }
	
	    x_new = n.add(x, dl_step);
	    subsys.setParams(x_new);
	    var err_new = subsys.calcResidual(fx_new);
	    subsys.fillJacobian(J_new);
	
	    var fxNormSq = n.norm2Squared(fx);
	    var dF = fxNormSq - n.norm2Squared(fx_new);
	    var dL = fxNormSq - n.norm2Squared(n.add(fx, n.dot(J, dl_step)));
	
	    var acceptCandidate;
	
	    if (dF == 0 || dL == 0) {
	      acceptCandidate = true;
	    } else {
	      var rho = dF / dL;
	      if (rho < 0.25) {
	        // if the model is a poor predictor reduce the size of the trust region
	        delta = 0.25 * dl_norm;
	        //delta *= 0.5;
	      } else {
	        // only increase the size of the trust region if it is taking a step of maximum size
	        // otherwise just assume it's doing good enough job
	        if (rho > 0.75 && hitBoundary) {
	          //delta = Math.max(delta,3*dl_norm);
	          delta *= 2;
	        }
	      }
	      acceptCandidate = rho > 0; // could be 0 .. 0.25
	    }
	    //log.push([stepKind,err,  delta,rho]);
	
	    if (acceptCandidate) {
	      x = n.clone(x_new);
	      J = n.clone(J_new);
	      fx = n.clone(fx_new);
	      err = err_new;
	
	      g = n.dot(n.transpose(J), fx);
	
	      // get infinity norms
	      g_inf = n.norminf(g);
	      fx_inf = n.norminf(fx);
	    }
	
	    iter++;
	  }
	  //log.push(returnCode);
	  //window.___log(log);
	  return new _result(iter, err, returnCode);
	};
	
	var cg = function cg(A, x, b, tol, maxIt) {
	
	  var _ = _numeric2.default;
	
	  var tr = _.transpose;
	  var At = tr(A);
	  if (A.length != A[0].length) {
	    A = _.dot(At, A);
	    b = _.dot(At, b);
	  }
	
	  var r = _.sub(_.dot(A, x), b);
	  var p = _.mul(r, -1);
	  var rr = _.dotVV(r, r);
	
	  var a;
	  var _rr;
	  var beta;
	
	  for (var i = 0; i < maxIt; ++i) {
	    if (_.norm2(r) <= tol) break;
	    var Axp = _.dot(A, p);
	    a = rr / _.dotVV(Axp, p);
	    x = _.add(x, _.mul(p, a));
	    r = _.add(r, _.mul(Axp, a));
	    _rr = rr;
	    rr = _.dotVV(r, r);
	    beta = rr / _rr;
	    p = _.add(_.mul(r, -1), _.mul(p, beta));
	  }
	  //  console.log("liner problem solved in " + i);
	  return x;
	};
	
	var optim = { DEBUG_HANDLER: function DEBUG_HANDLER() {} }; //backward compatibility
	
	exports.dog_leg = dog_leg;
	exports.optim = optim;

/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var numeric = ( false)?(function numeric() {}):(exports);
	if(typeof global !== "undefined") { global.numeric = numeric; }
	
	numeric.version = "1.2.6";
	
	// 1. Utility functions
	numeric.bench = function bench (f,interval) {
	    var t1,t2,n,i;
	    if(typeof interval === "undefined") { interval = 15; }
	    n = 0.5;
	    t1 = new Date();
	    while(1) {
	        n*=2;
	        for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
	        while(i>0) { f(); i--; }
	        t2 = new Date();
	        if(t2-t1 > interval) break;
	    }
	    for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
	    while(i>0) { f(); i--; }
	    t2 = new Date();
	    return 1000*(3*n-1)/(t2-t1);
	}
	
	numeric._myIndexOf = (function _myIndexOf(w) {
	    var n = this.length,k;
	    for(k=0;k<n;++k) if(this[k]===w) return k;
	    return -1;
	});
	numeric.myIndexOf = (Array.prototype.indexOf)?Array.prototype.indexOf:numeric._myIndexOf;
	
	numeric.Function = Function;
	numeric.precision = 4;
	numeric.largeArray = 50;
	
	numeric.prettyPrint = function prettyPrint(x) {
	    function fmtnum(x) {
	        if(x === 0) { return '0'; }
	        if(isNaN(x)) { return 'NaN'; }
	        if(x<0) { return '-'+fmtnum(-x); }
	        if(isFinite(x)) {
	            var scale = Math.floor(Math.log(x) / Math.log(10));
	            var normalized = x / Math.pow(10,scale);
	            var basic = normalized.toPrecision(numeric.precision);
	            if(parseFloat(basic) === 10) { scale++; normalized = 1; basic = normalized.toPrecision(numeric.precision); }
	            return parseFloat(basic).toString()+'e'+scale.toString();
	        }
	        return 'Infinity';
	    }
	    var ret = [];
	    function foo(x) {
	        var k;
	        if(typeof x === "undefined") { ret.push(Array(numeric.precision+8).join(' ')); return false; }
	        if(typeof x === "string") { ret.push('"'+x+'"'); return false; }
	        if(typeof x === "boolean") { ret.push(x.toString()); return false; }
	        if(typeof x === "number") {
	            var a = fmtnum(x);
	            var b = x.toPrecision(numeric.precision);
	            var c = parseFloat(x.toString()).toString();
	            var d = [a,b,c,parseFloat(b).toString(),parseFloat(c).toString()];
	            for(k=1;k<d.length;k++) { if(d[k].length < a.length) a = d[k]; }
	            ret.push(Array(numeric.precision+8-a.length).join(' ')+a);
	            return false;
	        }
	        if(x === null) { ret.push("null"); return false; }
	        if(typeof x === "function") { 
	            ret.push(x.toString());
	            var flag = false;
	            for(k in x) { if(x.hasOwnProperty(k)) { 
	                if(flag) ret.push(',\n');
	                else ret.push('\n{');
	                flag = true; 
	                ret.push(k); 
	                ret.push(': \n'); 
	                foo(x[k]); 
	            } }
	            if(flag) ret.push('}\n');
	            return true;
	        }
	        if(x instanceof Array) {
	            if(x.length > numeric.largeArray) { ret.push('...Large Array...'); return true; }
	            var flag = false;
	            ret.push('[');
	            for(k=0;k<x.length;k++) { if(k>0) { ret.push(','); if(flag) ret.push('\n '); } flag = foo(x[k]); }
	            ret.push(']');
	            return true;
	        }
	        ret.push('{');
	        var flag = false;
	        for(k in x) { if(x.hasOwnProperty(k)) { if(flag) ret.push(',\n'); flag = true; ret.push(k); ret.push(': \n'); foo(x[k]); } }
	        ret.push('}');
	        return true;
	    }
	    foo(x);
	    return ret.join('');
	}
	
	numeric.parseDate = function parseDate(d) {
	    function foo(d) {
	        if(typeof d === 'string') { return Date.parse(d.replace(/-/g,'/')); }
	        if(!(d instanceof Array)) { throw new Error("parseDate: parameter must be arrays of strings"); }
	        var ret = [],k;
	        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
	        return ret;
	    }
	    return foo(d);
	}
	
	numeric.parseFloat = function parseFloat_(d) {
	    function foo(d) {
	        if(typeof d === 'string') { return parseFloat(d); }
	        if(!(d instanceof Array)) { throw new Error("parseFloat: parameter must be arrays of strings"); }
	        var ret = [],k;
	        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
	        return ret;
	    }
	    return foo(d);
	}
	
	numeric.parseCSV = function parseCSV(t) {
	    var foo = t.split('\n');
	    var j,k;
	    var ret = [];
	    var pat = /(([^'",]*)|('[^']*')|("[^"]*")),/g;
	    var patnum = /^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/;
	    var stripper = function(n) { return n.substr(0,n.length-1); }
	    var count = 0;
	    for(k=0;k<foo.length;k++) {
	      var bar = (foo[k]+",").match(pat),baz;
	      if(bar.length>0) {
	          ret[count] = [];
	          for(j=0;j<bar.length;j++) {
	              baz = stripper(bar[j]);
	              if(patnum.test(baz)) { ret[count][j] = parseFloat(baz); }
	              else ret[count][j] = baz;
	          }
	          count++;
	      }
	    }
	    return ret;
	}
	
	numeric.toCSV = function toCSV(A) {
	    var s = numeric.dim(A);
	    var i,j,m,n,row,ret;
	    m = s[0];
	    n = s[1];
	    ret = [];
	    for(i=0;i<m;i++) {
	        row = [];
	        for(j=0;j<m;j++) { row[j] = A[i][j].toString(); }
	        ret[i] = row.join(', ');
	    }
	    return ret.join('\n')+'\n';
	}
	
	numeric.getURL = function getURL(url) {
	    var client = new XMLHttpRequest();
	    client.open("GET",url,false);
	    client.send();
	    return client;
	}
	
	numeric.imageURL = function imageURL(img) {
	    function base64(A) {
	        var n = A.length, i,x,y,z,p,q,r,s;
	        var key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	        var ret = "";
	        for(i=0;i<n;i+=3) {
	            x = A[i];
	            y = A[i+1];
	            z = A[i+2];
	            p = x >> 2;
	            q = ((x & 3) << 4) + (y >> 4);
	            r = ((y & 15) << 2) + (z >> 6);
	            s = z & 63;
	            if(i+1>=n) { r = s = 64; }
	            else if(i+2>=n) { s = 64; }
	            ret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);
	            }
	        return ret;
	    }
	    function crc32Array (a,from,to) {
	        if(typeof from === "undefined") { from = 0; }
	        if(typeof to === "undefined") { to = a.length; }
	        var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
	                     0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 
	                     0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
	                     0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 
	                     0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 
	                     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 
	                     0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
	                     0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
	                     0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
	                     0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 
	                     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 
	                     0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 
	                     0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 
	                     0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 
	                     0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 
	                     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 
	                     0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 
	                     0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 
	                     0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 
	                     0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 
	                     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 
	                     0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 
	                     0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 
	                     0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 
	                     0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 
	                     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 
	                     0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 
	                     0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 
	                     0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 
	                     0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 
	                     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 
	                     0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];
	     
	        var crc = -1, y = 0, n = a.length,i;
	
	        for (i = from; i < to; i++) {
	            y = (crc ^ a[i]) & 0xFF;
	            crc = (crc >>> 8) ^ table[y];
	        }
	     
	        return crc ^ (-1);
	    }
	
	    var h = img[0].length, w = img[0][0].length, s1, s2, next,k,length,a,b,i,j,adler32,crc32;
	    var stream = [
	                  137, 80, 78, 71, 13, 10, 26, 10,                           //  0: PNG signature
	                  0,0,0,13,                                                  //  8: IHDR Chunk length
	                  73, 72, 68, 82,                                            // 12: "IHDR" 
	                  (w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w&255,   // 16: Width
	                  (h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h&255,   // 20: Height
	                  8,                                                         // 24: bit depth
	                  2,                                                         // 25: RGB
	                  0,                                                         // 26: deflate
	                  0,                                                         // 27: no filter
	                  0,                                                         // 28: no interlace
	                  -1,-2,-3,-4,                                               // 29: CRC
	                  -5,-6,-7,-8,                                               // 33: IDAT Chunk length
	                  73, 68, 65, 84,                                            // 37: "IDAT"
	                  // RFC 1950 header starts here
	                  8,                                                         // 41: RFC1950 CMF
	                  29                                                         // 42: RFC1950 FLG
	                  ];
	    crc32 = crc32Array(stream,12,29);
	    stream[29] = (crc32>>24)&255;
	    stream[30] = (crc32>>16)&255;
	    stream[31] = (crc32>>8)&255;
	    stream[32] = (crc32)&255;
	    s1 = 1;
	    s2 = 0;
	    for(i=0;i<h;i++) {
	        if(i<h-1) { stream.push(0); }
	        else { stream.push(1); }
	        a = (3*w+1+(i===0))&255; b = ((3*w+1+(i===0))>>8)&255;
	        stream.push(a); stream.push(b);
	        stream.push((~a)&255); stream.push((~b)&255);
	        if(i===0) stream.push(0);
	        for(j=0;j<w;j++) {
	            for(k=0;k<3;k++) {
	                a = img[k][i][j];
	                if(a>255) a = 255;
	                else if(a<0) a=0;
	                else a = Math.round(a);
	                s1 = (s1 + a )%65521;
	                s2 = (s2 + s1)%65521;
	                stream.push(a);
	            }
	        }
	        stream.push(0);
	    }
	    adler32 = (s2<<16)+s1;
	    stream.push((adler32>>24)&255);
	    stream.push((adler32>>16)&255);
	    stream.push((adler32>>8)&255);
	    stream.push((adler32)&255);
	    length = stream.length - 41;
	    stream[33] = (length>>24)&255;
	    stream[34] = (length>>16)&255;
	    stream[35] = (length>>8)&255;
	    stream[36] = (length)&255;
	    crc32 = crc32Array(stream,37);
	    stream.push((crc32>>24)&255);
	    stream.push((crc32>>16)&255);
	    stream.push((crc32>>8)&255);
	    stream.push((crc32)&255);
	    stream.push(0);
	    stream.push(0);
	    stream.push(0);
	    stream.push(0);
	//    a = stream.length;
	    stream.push(73);  // I
	    stream.push(69);  // E
	    stream.push(78);  // N
	    stream.push(68);  // D
	    stream.push(174); // CRC1
	    stream.push(66);  // CRC2
	    stream.push(96);  // CRC3
	    stream.push(130); // CRC4
	    return 'data:image/png;base64,'+base64(stream);
	}
	
	// 2. Linear algebra with Arrays.
	numeric._dim = function _dim(x) {
	    var ret = [];
	    while(typeof x === "object") { ret.push(x.length); x = x[0]; }
	    return ret;
	}
	
	numeric.dim = function dim(x) {
	    var y,z;
	    if(typeof x === "object") {
	        y = x[0];
	        if(typeof y === "object") {
	            z = y[0];
	            if(typeof z === "object") {
	                return numeric._dim(x);
	            }
	            return [x.length,y.length];
	        }
	        return [x.length];
	    }
	    return [];
	}
	
	numeric.mapreduce = function mapreduce(body,init) {
	    return Function('x','accum','_s','_k',
	            'if(typeof accum === "undefined") accum = '+init+';\n'+
	            'if(typeof x === "number") { var xi = x; '+body+'; return accum; }\n'+
	            'if(typeof _s === "undefined") _s = numeric.dim(x);\n'+
	            'if(typeof _k === "undefined") _k = 0;\n'+
	            'var _n = _s[_k];\n'+
	            'var i,xi;\n'+
	            'if(_k < _s.length-1) {\n'+
	            '    for(i=_n-1;i>=0;i--) {\n'+
	            '        accum = arguments.callee(x[i],accum,_s,_k+1);\n'+
	            '    }'+
	            '    return accum;\n'+
	            '}\n'+
	            'for(i=_n-1;i>=1;i-=2) { \n'+
	            '    xi = x[i];\n'+
	            '    '+body+';\n'+
	            '    xi = x[i-1];\n'+
	            '    '+body+';\n'+
	            '}\n'+
	            'if(i === 0) {\n'+
	            '    xi = x[i];\n'+
	            '    '+body+'\n'+
	            '}\n'+
	            'return accum;'
	            );
	}
	numeric.mapreduce2 = function mapreduce2(body,setup) {
	    return Function('x',
	            'var n = x.length;\n'+
	            'var i,xi;\n'+setup+';\n'+
	            'for(i=n-1;i!==-1;--i) { \n'+
	            '    xi = x[i];\n'+
	            '    '+body+';\n'+
	            '}\n'+
	            'return accum;'
	            );
	}
	
	
	numeric.same = function same(x,y) {
	    var i,n;
	    if(!(x instanceof Array) || !(y instanceof Array)) { return false; }
	    n = x.length;
	    if(n !== y.length) { return false; }
	    for(i=0;i<n;i++) {
	        if(x[i] === y[i]) { continue; }
	        if(typeof x[i] === "object") { if(!same(x[i],y[i])) return false; }
	        else { return false; }
	    }
	    return true;
	}
	
	numeric.rep = function rep(s,v,k) {
	    if(typeof k === "undefined") { k=0; }
	    var n = s[k], ret = Array(n), i;
	    if(k === s.length-1) {
	        for(i=n-2;i>=0;i-=2) { ret[i+1] = v; ret[i] = v; }
	        if(i===-1) { ret[0] = v; }
	        return ret;
	    }
	    for(i=n-1;i>=0;i--) { ret[i] = numeric.rep(s,v,k+1); }
	    return ret;
	}
	
	
	numeric.dotMMsmall = function dotMMsmall(x,y) {
	    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0;
	    p = x.length; q = y.length; r = y[0].length;
	    ret = Array(p);
	    for(i=p-1;i>=0;i--) {
	        foo = Array(r);
	        bar = x[i];
	        for(k=r-1;k>=0;k--) {
	            woo = bar[q-1]*y[q-1][k];
	            for(j=q-2;j>=1;j-=2) {
	                i0 = j-1;
	                woo += bar[j]*y[j][k] + bar[i0]*y[i0][k];
	            }
	            if(j===0) { woo += bar[0]*y[0][k]; }
	            foo[k] = woo;
	        }
	        ret[i] = foo;
	    }
	    return ret;
	}
	numeric._getCol = function _getCol(A,j,x) {
	    var n = A.length, i;
	    for(i=n-1;i>0;--i) {
	        x[i] = A[i][j];
	        --i;
	        x[i] = A[i][j];
	    }
	    if(i===0) x[0] = A[0][j];
	}
	numeric.dotMMbig = function dotMMbig(x,y){
	    var gc = numeric._getCol, p = y.length, v = Array(p);
	    var m = x.length, n = y[0].length, A = new Array(m), xj;
	    var VV = numeric.dotVV;
	    var i,j,k,z;
	    --p;
	    --m;
	    for(i=m;i!==-1;--i) A[i] = Array(n);
	    --n;
	    for(i=n;i!==-1;--i) {
	        gc(y,i,v);
	        for(j=m;j!==-1;--j) {
	            z=0;
	            xj = x[j];
	            A[j][i] = VV(xj,v);
	        }
	    }
	    return A;
	}
	
	numeric.dotMV = function dotMV(x,y) {
	    var p = x.length, q = y.length,i;
	    var ret = Array(p), dotVV = numeric.dotVV;
	    for(i=p-1;i>=0;i--) { ret[i] = dotVV(x[i],y); }
	    return ret;
	}
	
	numeric.dotVM = function dotVM(x,y) {
	    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0,s1,s2,s3,baz,accum;
	    p = x.length; q = y[0].length;
	    ret = Array(q);
	    for(k=q-1;k>=0;k--) {
	        woo = x[p-1]*y[p-1][k];
	        for(j=p-2;j>=1;j-=2) {
	            i0 = j-1;
	            woo += x[j]*y[j][k] + x[i0]*y[i0][k];
	        }
	        if(j===0) { woo += x[0]*y[0][k]; }
	        ret[k] = woo;
	    }
	    return ret;
	}
	
	numeric.dotVV = function dotVV(x,y) {
	    var i,n=x.length,i1,ret = x[n-1]*y[n-1];
	    for(i=n-2;i>=1;i-=2) {
	        i1 = i-1;
	        ret += x[i]*y[i] + x[i1]*y[i1];
	    }
	    if(i===0) { ret += x[0]*y[0]; }
	    return ret;
	}
	
	numeric.dot = function dot(x,y) {
	    var d = numeric.dim;
	    switch(d(x).length*1000+d(y).length) {
	    case 2002:
	        if(y.length < 10) return numeric.dotMMsmall(x,y);
	        else return numeric.dotMMbig(x,y);
	    case 2001: return numeric.dotMV(x,y);
	    case 1002: return numeric.dotVM(x,y);
	    case 1001: return numeric.dotVV(x,y);
	    case 1000: return numeric.mulVS(x,y);
	    case 1: return numeric.mulSV(x,y);
	    case 0: return x*y;
	    default: throw new Error('numeric.dot only works on vectors and matrices');
	    }
	}
	
	numeric.diag = function diag(d) {
	    var i,i1,j,n = d.length, A = Array(n), Ai;
	    for(i=n-1;i>=0;i--) {
	        Ai = Array(n);
	        i1 = i+2;
	        for(j=n-1;j>=i1;j-=2) {
	            Ai[j] = 0;
	            Ai[j-1] = 0;
	        }
	        if(j>i) { Ai[j] = 0; }
	        Ai[i] = d[i];
	        for(j=i-1;j>=1;j-=2) {
	            Ai[j] = 0;
	            Ai[j-1] = 0;
	        }
	        if(j===0) { Ai[0] = 0; }
	        A[i] = Ai;
	    }
	    return A;
	}
	numeric.getDiag = function(A) {
	    var n = Math.min(A.length,A[0].length),i,ret = Array(n);
	    for(i=n-1;i>=1;--i) {
	        ret[i] = A[i][i];
	        --i;
	        ret[i] = A[i][i];
	    }
	    if(i===0) {
	        ret[0] = A[0][0];
	    }
	    return ret;
	}
	
	numeric.identity = function identity(n) { return numeric.diag(numeric.rep([n],1)); }
	numeric.pointwise = function pointwise(params,body,setup) {
	    if(typeof setup === "undefined") { setup = ""; }
	    var fun = [];
	    var k;
	    var avec = /\[i\]$/,p,thevec = '';
	    var haveret = false;
	    for(k=0;k<params.length;k++) {
	        if(avec.test(params[k])) {
	            p = params[k].substring(0,params[k].length-3);
	            thevec = p;
	        } else { p = params[k]; }
	        if(p==='ret') haveret = true;
	        fun.push(p);
	    }
	    fun[params.length] = '_s';
	    fun[params.length+1] = '_k';
	    fun[params.length+2] = (
	            'if(typeof _s === "undefined") _s = numeric.dim('+thevec+');\n'+
	            'if(typeof _k === "undefined") _k = 0;\n'+
	            'var _n = _s[_k];\n'+
	            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
	            'if(_k < _s.length-1) {\n'+
	            '    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee('+params.join(',')+',_s,_k+1);\n'+
	            '    return ret;\n'+
	            '}\n'+
	            setup+'\n'+
	            'for(i=_n-1;i!==-1;--i) {\n'+
	            '    '+body+'\n'+
	            '}\n'+
	            'return ret;'
	            );
	    return Function.apply(null,fun);
	}
	numeric.pointwise2 = function pointwise2(params,body,setup) {
	    if(typeof setup === "undefined") { setup = ""; }
	    var fun = [];
	    var k;
	    var avec = /\[i\]$/,p,thevec = '';
	    var haveret = false;
	    for(k=0;k<params.length;k++) {
	        if(avec.test(params[k])) {
	            p = params[k].substring(0,params[k].length-3);
	            thevec = p;
	        } else { p = params[k]; }
	        if(p==='ret') haveret = true;
	        fun.push(p);
	    }
	    fun[params.length] = (
	            'var _n = '+thevec+'.length;\n'+
	            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
	            setup+'\n'+
	            'for(i=_n-1;i!==-1;--i) {\n'+
	            body+'\n'+
	            '}\n'+
	            'return ret;'
	            );
	    return Function.apply(null,fun);
	}
	numeric._biforeach = (function _biforeach(x,y,s,k,f) {
	    if(k === s.length-1) { f(x,y); return; }
	    var i,n=s[k];
	    for(i=n-1;i>=0;i--) { _biforeach(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
	});
	numeric._biforeach2 = (function _biforeach2(x,y,s,k,f) {
	    if(k === s.length-1) { return f(x,y); }
	    var i,n=s[k],ret = Array(n);
	    for(i=n-1;i>=0;--i) { ret[i] = _biforeach2(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
	    return ret;
	});
	numeric._foreach = (function _foreach(x,s,k,f) {
	    if(k === s.length-1) { f(x); return; }
	    var i,n=s[k];
	    for(i=n-1;i>=0;i--) { _foreach(x[i],s,k+1,f); }
	});
	numeric._foreach2 = (function _foreach2(x,s,k,f) {
	    if(k === s.length-1) { return f(x); }
	    var i,n=s[k], ret = Array(n);
	    for(i=n-1;i>=0;i--) { ret[i] = _foreach2(x[i],s,k+1,f); }
	    return ret;
	});
	
	/*numeric.anyV = numeric.mapreduce('if(xi) return true;','false');
	numeric.allV = numeric.mapreduce('if(!xi) return false;','true');
	numeric.any = function(x) { if(typeof x.length === "undefined") return x; return numeric.anyV(x); }
	numeric.all = function(x) { if(typeof x.length === "undefined") return x; return numeric.allV(x); }*/
	
	numeric.ops2 = {
	        add: '+',
	        sub: '-',
	        mul: '*',
	        div: '/',
	        mod: '%',
	        and: '&&',
	        or:  '||',
	        eq:  '===',
	        neq: '!==',
	        lt:  '<',
	        gt:  '>',
	        leq: '<=',
	        geq: '>=',
	        band: '&',
	        bor: '|',
	        bxor: '^',
	        lshift: '<<',
	        rshift: '>>',
	        rrshift: '>>>'
	};
	numeric.opseq = {
	        addeq: '+=',
	        subeq: '-=',
	        muleq: '*=',
	        diveq: '/=',
	        modeq: '%=',
	        lshifteq: '<<=',
	        rshifteq: '>>=',
	        rrshifteq: '>>>=',
	        bandeq: '&=',
	        boreq: '|=',
	        bxoreq: '^='
	};
	numeric.mathfuns = ['abs','acos','asin','atan','ceil','cos',
	                    'exp','floor','log','round','sin','sqrt','tan',
	                    'isNaN','isFinite'];
	numeric.mathfuns2 = ['atan2','pow','max','min'];
	numeric.ops1 = {
	        neg: '-',
	        not: '!',
	        bnot: '~',
	        clone: ''
	};
	numeric.mapreducers = {
	        any: ['if(xi) return true;','var accum = false;'],
	        all: ['if(!xi) return false;','var accum = true;'],
	        sum: ['accum += xi;','var accum = 0;'],
	        prod: ['accum *= xi;','var accum = 1;'],
	        norm2Squared: ['accum += xi*xi;','var accum = 0;'],
	        norminf: ['accum = max(accum,abs(xi));','var accum = 0, max = Math.max, abs = Math.abs;'],
	        norm1: ['accum += abs(xi)','var accum = 0, abs = Math.abs;'],
	        sup: ['accum = max(accum,xi);','var accum = -Infinity, max = Math.max;'],
	        inf: ['accum = min(accum,xi);','var accum = Infinity, min = Math.min;']
	};
	
	(function () {
	    var i,o;
	    for(i=0;i<numeric.mathfuns2.length;++i) {
	        o = numeric.mathfuns2[i];
	        numeric.ops2[o] = o;
	    }
	    for(i in numeric.ops2) {
	        if(numeric.ops2.hasOwnProperty(i)) {
	            o = numeric.ops2[i];
	            var code, codeeq, setup = '';
	            if(numeric.myIndexOf.call(numeric.mathfuns2,i)!==-1) {
	                setup = 'var '+o+' = Math.'+o+';\n';
	                code = function(r,x,y) { return r+' = '+o+'('+x+','+y+')'; };
	                codeeq = function(x,y) { return x+' = '+o+'('+x+','+y+')'; };
	            } else {
	                code = function(r,x,y) { return r+' = '+x+' '+o+' '+y; };
	                if(numeric.opseq.hasOwnProperty(i+'eq')) {
	                    codeeq = function(x,y) { return x+' '+o+'= '+y; };
	                } else {
	                    codeeq = function(x,y) { return x+' = '+x+' '+o+' '+y; };                    
	                }
	            }
	            numeric[i+'VV'] = numeric.pointwise2(['x[i]','y[i]'],code('ret[i]','x[i]','y[i]'),setup);
	            numeric[i+'SV'] = numeric.pointwise2(['x','y[i]'],code('ret[i]','x','y[i]'),setup);
	            numeric[i+'VS'] = numeric.pointwise2(['x[i]','y'],code('ret[i]','x[i]','y'),setup);
	            numeric[i] = Function(
	                    'var n = arguments.length, i, x = arguments[0], y;\n'+
	                    'var VV = numeric.'+i+'VV, VS = numeric.'+i+'VS, SV = numeric.'+i+'SV;\n'+
	                    'var dim = numeric.dim;\n'+
	                    'for(i=1;i!==n;++i) { \n'+
	                    '  y = arguments[i];\n'+
	                    '  if(typeof x === "object") {\n'+
	                    '      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n'+
	                    '      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n'+
	                    '  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n'+
	                    '  else '+codeeq('x','y')+'\n'+
	                    '}\nreturn x;\n');
	            numeric[o] = numeric[i];
	            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]','x[i]'], codeeq('ret[i]','x[i]'),setup);
	            numeric[i+'eqS'] = numeric.pointwise2(['ret[i]','x'], codeeq('ret[i]','x'),setup);
	            numeric[i+'eq'] = Function(
	                    'var n = arguments.length, i, x = arguments[0], y;\n'+
	                    'var V = numeric.'+i+'eqV, S = numeric.'+i+'eqS\n'+
	                    'var s = numeric.dim(x);\n'+
	                    'for(i=1;i!==n;++i) { \n'+
	                    '  y = arguments[i];\n'+
	                    '  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n'+
	                    '  else numeric._biforeach(x,y,s,0,S);\n'+
	                    '}\nreturn x;\n');
	        }
	    }
	    for(i=0;i<numeric.mathfuns2.length;++i) {
	        o = numeric.mathfuns2[i];
	        delete numeric.ops2[o];
	    }
	    for(i=0;i<numeric.mathfuns.length;++i) {
	        o = numeric.mathfuns[i];
	        numeric.ops1[o] = o;
	    }
	    for(i in numeric.ops1) {
	        if(numeric.ops1.hasOwnProperty(i)) {
	            setup = '';
	            o = numeric.ops1[i];
	            if(numeric.myIndexOf.call(numeric.mathfuns,i)!==-1) {
	                if(Math.hasOwnProperty(o)) setup = 'var '+o+' = Math.'+o+';\n';
	            }
	            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]'],'ret[i] = '+o+'(ret[i]);',setup);
	            numeric[i+'eq'] = Function('x',
	                    'if(typeof x !== "object") return '+o+'x\n'+
	                    'var i;\n'+
	                    'var V = numeric.'+i+'eqV;\n'+
	                    'var s = numeric.dim(x);\n'+
	                    'numeric._foreach(x,s,0,V);\n'+
	                    'return x;\n');
	            numeric[i+'V'] = numeric.pointwise2(['x[i]'],'ret[i] = '+o+'(x[i]);',setup);
	            numeric[i] = Function('x',
	                    'if(typeof x !== "object") return '+o+'(x)\n'+
	                    'var i;\n'+
	                    'var V = numeric.'+i+'V;\n'+
	                    'var s = numeric.dim(x);\n'+
	                    'return numeric._foreach2(x,s,0,V);\n');
	        }
	    }
	    for(i=0;i<numeric.mathfuns.length;++i) {
	        o = numeric.mathfuns[i];
	        delete numeric.ops1[o];
	    }
	    for(i in numeric.mapreducers) {
	        if(numeric.mapreducers.hasOwnProperty(i)) {
	            o = numeric.mapreducers[i];
	            numeric[i+'V'] = numeric.mapreduce2(o[0],o[1]);
	            numeric[i] = Function('x','s','k',
	                    o[1]+
	                    'if(typeof x !== "object") {'+
	                    '    xi = x;\n'+
	                    o[0]+';\n'+
	                    '    return accum;\n'+
	                    '}'+
	                    'if(typeof s === "undefined") s = numeric.dim(x);\n'+
	                    'if(typeof k === "undefined") k = 0;\n'+
	                    'if(k === s.length-1) return numeric.'+i+'V(x);\n'+
	                    'var xi;\n'+
	                    'var n = x.length, i;\n'+
	                    'for(i=n-1;i!==-1;--i) {\n'+
	                    '   xi = arguments.callee(x[i]);\n'+
	                    o[0]+';\n'+
	                    '}\n'+
	                    'return accum;\n');
	        }
	    }
	}());
	
	numeric.truncVV = numeric.pointwise(['x[i]','y[i]'],'ret[i] = round(x[i]/y[i])*y[i];','var round = Math.round;');
	numeric.truncVS = numeric.pointwise(['x[i]','y'],'ret[i] = round(x[i]/y)*y;','var round = Math.round;');
	numeric.truncSV = numeric.pointwise(['x','y[i]'],'ret[i] = round(x/y[i])*y[i];','var round = Math.round;');
	numeric.trunc = function trunc(x,y) {
	    if(typeof x === "object") {
	        if(typeof y === "object") return numeric.truncVV(x,y);
	        return numeric.truncVS(x,y);
	    }
	    if (typeof y === "object") return numeric.truncSV(x,y);
	    return Math.round(x/y)*y;
	}
	
	numeric.inv = function inv(x) {
	    var s = numeric.dim(x), abs = Math.abs, m = s[0], n = s[1];
	    var A = numeric.clone(x), Ai, Aj;
	    var I = numeric.identity(m), Ii, Ij;
	    var i,j,k,x;
	    for(j=0;j<n;++j) {
	        var i0 = -1;
	        var v0 = -1;
	        for(i=j;i!==m;++i) { k = abs(A[i][j]); if(k>v0) { i0 = i; v0 = k; } }
	        Aj = A[i0]; A[i0] = A[j]; A[j] = Aj;
	        Ij = I[i0]; I[i0] = I[j]; I[j] = Ij;
	        x = Aj[j];
	        for(k=j;k!==n;++k)    Aj[k] /= x; 
	        for(k=n-1;k!==-1;--k) Ij[k] /= x;
	        for(i=m-1;i!==-1;--i) {
	            if(i!==j) {
	                Ai = A[i];
	                Ii = I[i];
	                x = Ai[j];
	                for(k=j+1;k!==n;++k)  Ai[k] -= Aj[k]*x;
	                for(k=n-1;k>0;--k) { Ii[k] -= Ij[k]*x; --k; Ii[k] -= Ij[k]*x; }
	                if(k===0) Ii[0] -= Ij[0]*x;
	            }
	        }
	    }
	    return I;
	}
	
	numeric.det = function det(x) {
	    var s = numeric.dim(x);
	    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: det() only works on square matrices'); }
	    var n = s[0], ret = 1,i,j,k,A = numeric.clone(x),Aj,Ai,alpha,temp,k1,k2,k3;
	    for(j=0;j<n-1;j++) {
	        k=j;
	        for(i=j+1;i<n;i++) { if(Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }
	        if(k !== j) {
	            temp = A[k]; A[k] = A[j]; A[j] = temp;
	            ret *= -1;
	        }
	        Aj = A[j];
	        for(i=j+1;i<n;i++) {
	            Ai = A[i];
	            alpha = Ai[j]/Aj[j];
	            for(k=j+1;k<n-1;k+=2) {
	                k1 = k+1;
	                Ai[k] -= Aj[k]*alpha;
	                Ai[k1] -= Aj[k1]*alpha;
	            }
	            if(k!==n) { Ai[k] -= Aj[k]*alpha; }
	        }
	        if(Aj[j] === 0) { return 0; }
	        ret *= Aj[j];
	    }
	    return ret*A[j][j];
	}
	
	numeric.transpose = function transpose(x) {
	    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
	    for(j=0;j<n;j++) ret[j] = Array(m);
	    for(i=m-1;i>=1;i-=2) {
	        A1 = x[i];
	        A0 = x[i-1];
	        for(j=n-1;j>=1;--j) {
	            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
	            --j;
	            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
	        }
	        if(j===0) {
	            Bj = ret[0]; Bj[i] = A1[0]; Bj[i-1] = A0[0];
	        }
	    }
	    if(i===0) {
	        A0 = x[0];
	        for(j=n-1;j>=1;--j) {
	            ret[j][0] = A0[j];
	            --j;
	            ret[j][0] = A0[j];
	        }
	        if(j===0) { ret[0][0] = A0[0]; }
	    }
	    return ret;
	}
	numeric.negtranspose = function negtranspose(x) {
	    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
	    for(j=0;j<n;j++) ret[j] = Array(m);
	    for(i=m-1;i>=1;i-=2) {
	        A1 = x[i];
	        A0 = x[i-1];
	        for(j=n-1;j>=1;--j) {
	            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
	            --j;
	            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
	        }
	        if(j===0) {
	            Bj = ret[0]; Bj[i] = -A1[0]; Bj[i-1] = -A0[0];
	        }
	    }
	    if(i===0) {
	        A0 = x[0];
	        for(j=n-1;j>=1;--j) {
	            ret[j][0] = -A0[j];
	            --j;
	            ret[j][0] = -A0[j];
	        }
	        if(j===0) { ret[0][0] = -A0[0]; }
	    }
	    return ret;
	}
	
	numeric._random = function _random(s,k) {
	    var i,n=s[k],ret=Array(n), rnd;
	    if(k === s.length-1) {
	        rnd = Math.random;
	        for(i=n-1;i>=1;i-=2) {
	            ret[i] = rnd();
	            ret[i-1] = rnd();
	        }
	        if(i===0) { ret[0] = rnd(); }
	        return ret;
	    }
	    for(i=n-1;i>=0;i--) ret[i] = _random(s,k+1);
	    return ret;
	}
	numeric.random = function random(s) { return numeric._random(s,0); }
	
	numeric.norm2 = function norm2(x) { return Math.sqrt(numeric.norm2Squared(x)); }
	
	numeric.linspace = function linspace(a,b,n) {
	    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
	    if(n<2) { return n===1?[a]:[]; }
	    var i,ret = Array(n);
	    n--;
	    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
	    return ret;
	}
	
	numeric.getBlock = function getBlock(x,from,to) {
	    var s = numeric.dim(x);
	    function foo(x,k) {
	        var i,a = from[k], n = to[k]-a, ret = Array(n);
	        if(k === s.length-1) {
	            for(i=n;i>=0;i--) { ret[i] = x[i+a]; }
	            return ret;
	        }
	        for(i=n;i>=0;i--) { ret[i] = foo(x[i+a],k+1); }
	        return ret;
	    }
	    return foo(x,0);
	}
	
	numeric.setBlock = function setBlock(x,from,to,B) {
	    var s = numeric.dim(x);
	    function foo(x,y,k) {
	        var i,a = from[k], n = to[k]-a;
	        if(k === s.length-1) { for(i=n;i>=0;i--) { x[i+a] = y[i]; } }
	        for(i=n;i>=0;i--) { foo(x[i+a],y[i],k+1); }
	    }
	    foo(x,B,0);
	    return x;
	}
	
	numeric.getRange = function getRange(A,I,J) {
	    var m = I.length, n = J.length;
	    var i,j;
	    var B = Array(m), Bi, AI;
	    for(i=m-1;i!==-1;--i) {
	        B[i] = Array(n);
	        Bi = B[i];
	        AI = A[I[i]];
	        for(j=n-1;j!==-1;--j) Bi[j] = AI[J[j]];
	    }
	    return B;
	}
	
	numeric.blockMatrix = function blockMatrix(X) {
	    var s = numeric.dim(X);
	    if(s.length<4) return numeric.blockMatrix([X]);
	    var m=s[0],n=s[1],M,N,i,j,Xij;
	    M = 0; N = 0;
	    for(i=0;i<m;++i) M+=X[i][0].length;
	    for(j=0;j<n;++j) N+=X[0][j][0].length;
	    var Z = Array(M);
	    for(i=0;i<M;++i) Z[i] = Array(N);
	    var I=0,J,ZI,k,l,Xijk;
	    for(i=0;i<m;++i) {
	        J=N;
	        for(j=n-1;j!==-1;--j) {
	            Xij = X[i][j];
	            J -= Xij[0].length;
	            for(k=Xij.length-1;k!==-1;--k) {
	                Xijk = Xij[k];
	                ZI = Z[I+k];
	                for(l = Xijk.length-1;l!==-1;--l) ZI[J+l] = Xijk[l];
	            }
	        }
	        I += X[i][0].length;
	    }
	    return Z;
	}
	
	numeric.tensor = function tensor(x,y) {
	    if(typeof x === "number" || typeof y === "number") return numeric.mul(x,y);
	    var s1 = numeric.dim(x), s2 = numeric.dim(y);
	    if(s1.length !== 1 || s2.length !== 1) {
	        throw new Error('numeric: tensor product is only defined for vectors');
	    }
	    var m = s1[0], n = s2[0], A = Array(m), Ai, i,j,xi;
	    for(i=m-1;i>=0;i--) {
	        Ai = Array(n);
	        xi = x[i];
	        for(j=n-1;j>=3;--j) {
	            Ai[j] = xi * y[j];
	            --j;
	            Ai[j] = xi * y[j];
	            --j;
	            Ai[j] = xi * y[j];
	            --j;
	            Ai[j] = xi * y[j];
	        }
	        while(j>=0) { Ai[j] = xi * y[j]; --j; }
	        A[i] = Ai;
	    }
	    return A;
	}
	
	// 3. The Tensor type T
	numeric.T = function T(x,y) { this.x = x; this.y = y; }
	numeric.t = function t(x,y) { return new numeric.T(x,y); }
	
	numeric.Tbinop = function Tbinop(rr,rc,cr,cc,setup) {
	    var io = numeric.indexOf;
	    if(typeof setup !== "string") {
	        var k;
	        setup = '';
	        for(k in numeric) {
	            if(numeric.hasOwnProperty(k) && (rr.indexOf(k)>=0 || rc.indexOf(k)>=0 || cr.indexOf(k)>=0 || cc.indexOf(k)>=0) && k.length>1) {
	                setup += 'var '+k+' = numeric.'+k+';\n';
	            }
	        }
	    }
	    return Function(['y'],
	            'var x = this;\n'+
	            'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n'+
	            setup+'\n'+
	            'if(x.y) {'+
	            '  if(y.y) {'+
	            '    return new numeric.T('+cc+');\n'+
	            '  }\n'+
	            '  return new numeric.T('+cr+');\n'+
	            '}\n'+
	            'if(y.y) {\n'+
	            '  return new numeric.T('+rc+');\n'+
	            '}\n'+
	            'return new numeric.T('+rr+');\n'
	    );
	}
	
	numeric.T.prototype.add = numeric.Tbinop(
	        'add(x.x,y.x)',
	        'add(x.x,y.x),y.y',
	        'add(x.x,y.x),x.y',
	        'add(x.x,y.x),add(x.y,y.y)');
	numeric.T.prototype.sub = numeric.Tbinop(
	        'sub(x.x,y.x)',
	        'sub(x.x,y.x),neg(y.y)',
	        'sub(x.x,y.x),x.y',
	        'sub(x.x,y.x),sub(x.y,y.y)');
	numeric.T.prototype.mul = numeric.Tbinop(
	        'mul(x.x,y.x)',
	        'mul(x.x,y.x),mul(x.x,y.y)',
	        'mul(x.x,y.x),mul(x.y,y.x)',
	        'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');
	
	numeric.T.prototype.reciprocal = function reciprocal() {
	    var mul = numeric.mul, div = numeric.div;
	    if(this.y) {
	        var d = numeric.add(mul(this.x,this.x),mul(this.y,this.y));
	        return new numeric.T(div(this.x,d),div(numeric.neg(this.y),d));
	    }
	    return new T(div(1,this.x));
	}
	numeric.T.prototype.div = function div(y) {
	    if(!(y instanceof numeric.T)) y = new numeric.T(y);
	    if(y.y) { return this.mul(y.reciprocal()); }
	    var div = numeric.div;
	    if(this.y) { return new numeric.T(div(this.x,y.x),div(this.y,y.x)); }
	    return new numeric.T(div(this.x,y.x));
	}
	numeric.T.prototype.dot = numeric.Tbinop(
	        'dot(x.x,y.x)',
	        'dot(x.x,y.x),dot(x.x,y.y)',
	        'dot(x.x,y.x),dot(x.y,y.x)',
	        'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'
	        );
	numeric.T.prototype.transpose = function transpose() {
	    var t = numeric.transpose, x = this.x, y = this.y;
	    if(y) { return new numeric.T(t(x),t(y)); }
	    return new numeric.T(t(x));
	}
	numeric.T.prototype.transjugate = function transjugate() {
	    var t = numeric.transpose, x = this.x, y = this.y;
	    if(y) { return new numeric.T(t(x),numeric.negtranspose(y)); }
	    return new numeric.T(t(x));
	}
	numeric.Tunop = function Tunop(r,c,s) {
	    if(typeof s !== "string") { s = ''; }
	    return Function(
	            'var x = this;\n'+
	            s+'\n'+
	            'if(x.y) {'+
	            '  '+c+';\n'+
	            '}\n'+
	            r+';\n'
	    );
	}
	
	numeric.T.prototype.exp = numeric.Tunop(
	        'return new numeric.T(ex)',
	        'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',
	        'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');
	numeric.T.prototype.conj = numeric.Tunop(
	        'return new numeric.T(x.x);',
	        'return new numeric.T(x.x,numeric.neg(x.y));');
	numeric.T.prototype.neg = numeric.Tunop(
	        'return new numeric.T(neg(x.x));',
	        'return new numeric.T(neg(x.x),neg(x.y));',
	        'var neg = numeric.neg;');
	numeric.T.prototype.sin = numeric.Tunop(
	        'return new numeric.T(numeric.sin(x.x))',
	        'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');
	numeric.T.prototype.cos = numeric.Tunop(
	        'return new numeric.T(numeric.cos(x.x))',
	        'return x.exp().add(x.neg().exp()).div(2);');
	numeric.T.prototype.abs = numeric.Tunop(
	        'return new numeric.T(numeric.abs(x.x));',
	        'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',
	        'var mul = numeric.mul;');
	numeric.T.prototype.log = numeric.Tunop(
	        'return new numeric.T(numeric.log(x.x));',
	        'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\n'+
	        'return new numeric.T(numeric.log(r.x),theta.x);');
	numeric.T.prototype.norm2 = numeric.Tunop(
	        'return numeric.norm2(x.x);',
	        'var f = numeric.norm2Squared;\n'+
	        'return Math.sqrt(f(x.x)+f(x.y));');
	numeric.T.prototype.inv = function inv() {
	    var A = this;
	    if(typeof A.y === "undefined") { return new numeric.T(numeric.inv(A.x)); }
	    var n = A.x.length, i, j, k;
	    var Rx = numeric.identity(n),Ry = numeric.rep([n,n],0);
	    var Ax = numeric.clone(A.x), Ay = numeric.clone(A.y);
	    var Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;
	    var i,j,k,d,d1,ax,ay,bx,by,temp;
	    for(i=0;i<n;i++) {
	        ax = Ax[i][i]; ay = Ay[i][i];
	        d = ax*ax+ay*ay;
	        k = i;
	        for(j=i+1;j<n;j++) {
	            ax = Ax[j][i]; ay = Ay[j][i];
	            d1 = ax*ax+ay*ay;
	            if(d1 > d) { k=j; d = d1; }
	        }
	        if(k!==i) {
	            temp = Ax[i]; Ax[i] = Ax[k]; Ax[k] = temp;
	            temp = Ay[i]; Ay[i] = Ay[k]; Ay[k] = temp;
	            temp = Rx[i]; Rx[i] = Rx[k]; Rx[k] = temp;
	            temp = Ry[i]; Ry[i] = Ry[k]; Ry[k] = temp;
	        }
	        Aix = Ax[i]; Aiy = Ay[i];
	        Rix = Rx[i]; Riy = Ry[i];
	        ax = Aix[i]; ay = Aiy[i];
	        for(j=i+1;j<n;j++) {
	            bx = Aix[j]; by = Aiy[j];
	            Aix[j] = (bx*ax+by*ay)/d;
	            Aiy[j] = (by*ax-bx*ay)/d;
	        }
	        for(j=0;j<n;j++) {
	            bx = Rix[j]; by = Riy[j];
	            Rix[j] = (bx*ax+by*ay)/d;
	            Riy[j] = (by*ax-bx*ay)/d;
	        }
	        for(j=i+1;j<n;j++) {
	            Ajx = Ax[j]; Ajy = Ay[j];
	            Rjx = Rx[j]; Rjy = Ry[j];
	            ax = Ajx[i]; ay = Ajy[i];
	            for(k=i+1;k<n;k++) {
	                bx = Aix[k]; by = Aiy[k];
	                Ajx[k] -= bx*ax-by*ay;
	                Ajy[k] -= by*ax+bx*ay;
	            }
	            for(k=0;k<n;k++) {
	                bx = Rix[k]; by = Riy[k];
	                Rjx[k] -= bx*ax-by*ay;
	                Rjy[k] -= by*ax+bx*ay;
	            }
	        }
	    }
	    for(i=n-1;i>0;i--) {
	        Rix = Rx[i]; Riy = Ry[i];
	        for(j=i-1;j>=0;j--) {
	            Rjx = Rx[j]; Rjy = Ry[j];
	            ax = Ax[j][i]; ay = Ay[j][i];
	            for(k=n-1;k>=0;k--) {
	                bx = Rix[k]; by = Riy[k];
	                Rjx[k] -= ax*bx - ay*by;
	                Rjy[k] -= ax*by + ay*bx;
	            }
	        }
	    }
	    return new numeric.T(Rx,Ry);
	}
	numeric.T.prototype.get = function get(i) {
	    var x = this.x, y = this.y, k = 0, ik, n = i.length;
	    if(y) {
	        while(k<n) {
	            ik = i[k];
	            x = x[ik];
	            y = y[ik];
	            k++;
	        }
	        return new numeric.T(x,y);
	    }
	    while(k<n) {
	        ik = i[k];
	        x = x[ik];
	        k++;
	    }
	    return new numeric.T(x);
	}
	numeric.T.prototype.set = function set(i,v) {
	    var x = this.x, y = this.y, k = 0, ik, n = i.length, vx = v.x, vy = v.y;
	    if(n===0) {
	        if(vy) { this.y = vy; }
	        else if(y) { this.y = undefined; }
	        this.x = x;
	        return this;
	    }
	    if(vy) {
	        if(y) { /* ok */ }
	        else {
	            y = numeric.rep(numeric.dim(x),0);
	            this.y = y;
	        }
	        while(k<n-1) {
	            ik = i[k];
	            x = x[ik];
	            y = y[ik];
	            k++;
	        }
	        ik = i[k];
	        x[ik] = vx;
	        y[ik] = vy;
	        return this;
	    }
	    if(y) {
	        while(k<n-1) {
	            ik = i[k];
	            x = x[ik];
	            y = y[ik];
	            k++;
	        }
	        ik = i[k];
	        x[ik] = vx;
	        if(vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx),0);
	        else y[ik] = 0;
	        return this;
	    }
	    while(k<n-1) {
	        ik = i[k];
	        x = x[ik];
	        k++;
	    }
	    ik = i[k];
	    x[ik] = vx;
	    return this;
	}
	numeric.T.prototype.getRows = function getRows(i0,i1) {
	    var n = i1-i0+1, j;
	    var rx = Array(n), ry, x = this.x, y = this.y;
	    for(j=i0;j<=i1;j++) { rx[j-i0] = x[j]; }
	    if(y) {
	        ry = Array(n);
	        for(j=i0;j<=i1;j++) { ry[j-i0] = y[j]; }
	        return new numeric.T(rx,ry);
	    }
	    return new numeric.T(rx);
	}
	numeric.T.prototype.setRows = function setRows(i0,i1,A) {
	    var j;
	    var rx = this.x, ry = this.y, x = A.x, y = A.y;
	    for(j=i0;j<=i1;j++) { rx[j] = x[j-i0]; }
	    if(y) {
	        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
	        for(j=i0;j<=i1;j++) { ry[j] = y[j-i0]; }
	    } else if(ry) {
	        for(j=i0;j<=i1;j++) { ry[j] = numeric.rep([x[j-i0].length],0); }
	    }
	    return this;
	}
	numeric.T.prototype.getRow = function getRow(k) {
	    var x = this.x, y = this.y;
	    if(y) { return new numeric.T(x[k],y[k]); }
	    return new numeric.T(x[k]);
	}
	numeric.T.prototype.setRow = function setRow(i,v) {
	    var rx = this.x, ry = this.y, x = v.x, y = v.y;
	    rx[i] = x;
	    if(y) {
	        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
	        ry[i] = y;
	    } else if(ry) {
	        ry = numeric.rep([x.length],0);
	    }
	    return this;
	}
	
	numeric.T.prototype.getBlock = function getBlock(from,to) {
	    var x = this.x, y = this.y, b = numeric.getBlock;
	    if(y) { return new numeric.T(b(x,from,to),b(y,from,to)); }
	    return new numeric.T(b(x,from,to));
	}
	numeric.T.prototype.setBlock = function setBlock(from,to,A) {
	    if(!(A instanceof numeric.T)) A = new numeric.T(A);
	    var x = this.x, y = this.y, b = numeric.setBlock, Ax = A.x, Ay = A.y;
	    if(Ay) {
	        if(!y) { this.y = numeric.rep(numeric.dim(this),0); y = this.y; }
	        b(x,from,to,Ax);
	        b(y,from,to,Ay);
	        return this;
	    }
	    b(x,from,to,Ax);
	    if(y) b(y,from,to,numeric.rep(numeric.dim(Ax),0));
	}
	numeric.T.rep = function rep(s,v) {
	    var T = numeric.T;
	    if(!(v instanceof T)) v = new T(v);
	    var x = v.x, y = v.y, r = numeric.rep;
	    if(y) return new T(r(s,x),r(s,y));
	    return new T(r(s,x));
	}
	numeric.T.diag = function diag(d) {
	    if(!(d instanceof numeric.T)) d = new numeric.T(d);
	    var x = d.x, y = d.y, diag = numeric.diag;
	    if(y) return new numeric.T(diag(x),diag(y));
	    return new numeric.T(diag(x));
	}
	numeric.T.eig = function eig() {
	    if(this.y) { throw new Error('eig: not implemented for complex matrices.'); }
	    return numeric.eig(this.x);
	}
	numeric.T.identity = function identity(n) { return new numeric.T(numeric.identity(n)); }
	numeric.T.prototype.getDiag = function getDiag() {
	    var n = numeric;
	    var x = this.x, y = this.y;
	    if(y) { return new n.T(n.getDiag(x),n.getDiag(y)); }
	    return new n.T(n.getDiag(x));
	}
	
	// 4. Eigenvalues of real matrices
	
	numeric.house = function house(x) {
	    var v = numeric.clone(x);
	    var s = x[0] >= 0 ? 1 : -1;
	    var alpha = s*numeric.norm2(x);
	    v[0] += alpha;
	    var foo = numeric.norm2(v);
	    if(foo === 0) { /* this should not happen */ throw new Error('eig: internal error'); }
	    return numeric.div(v,foo);
	}
	
	numeric.toUpperHessenberg = function toUpperHessenberg(me) {
	    var s = numeric.dim(me);
	    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: toUpperHessenberg() only works on square matrices'); }
	    var m = s[0], i,j,k,x,v,A = numeric.clone(me),B,C,Ai,Ci,Q = numeric.identity(m),Qi;
	    for(j=0;j<m-2;j++) {
	        x = Array(m-j-1);
	        for(i=j+1;i<m;i++) { x[i-j-1] = A[i][j]; }
	        if(numeric.norm2(x)>0) {
	            v = numeric.house(x);
	            B = numeric.getBlock(A,[j+1,j],[m-1,m-1]);
	            C = numeric.tensor(v,numeric.dot(v,B));
	            for(i=j+1;i<m;i++) { Ai = A[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Ai[k] -= 2*Ci[k-j]; }
	            B = numeric.getBlock(A,[0,j+1],[m-1,m-1]);
	            C = numeric.tensor(numeric.dot(B,v),v);
	            for(i=0;i<m;i++) { Ai = A[i]; Ci = C[i]; for(k=j+1;k<m;k++) Ai[k] -= 2*Ci[k-j-1]; }
	            B = Array(m-j-1);
	            for(i=j+1;i<m;i++) B[i-j-1] = Q[i];
	            C = numeric.tensor(v,numeric.dot(v,B));
	            for(i=j+1;i<m;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
	        }
	    }
	    return {H:A, Q:Q};
	}
	
	numeric.epsilon = 2.220446049250313e-16;
	
	numeric.QRFrancis = function(H,maxiter) {
	    if(typeof maxiter === "undefined") { maxiter = 10000; }
	    H = numeric.clone(H);
	    var H0 = numeric.clone(H);
	    var s = numeric.dim(H),m=s[0],x,v,a,b,c,d,det,tr, Hloc, Q = numeric.identity(m), Qi, Hi, B, C, Ci,i,j,k,iter;
	    if(m<3) { return {Q:Q, B:[ [0,m-1] ]}; }
	    var epsilon = numeric.epsilon;
	    for(iter=0;iter<maxiter;iter++) {
	        for(j=0;j<m-1;j++) {
	            if(Math.abs(H[j+1][j]) < epsilon*(Math.abs(H[j][j])+Math.abs(H[j+1][j+1]))) {
	                var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[j,j]),maxiter);
	                var QH2 = numeric.QRFrancis(numeric.getBlock(H,[j+1,j+1],[m-1,m-1]),maxiter);
	                B = Array(j+1);
	                for(i=0;i<=j;i++) { B[i] = Q[i]; }
	                C = numeric.dot(QH1.Q,B);
	                for(i=0;i<=j;i++) { Q[i] = C[i]; }
	                B = Array(m-j-1);
	                for(i=j+1;i<m;i++) { B[i-j-1] = Q[i]; }
	                C = numeric.dot(QH2.Q,B);
	                for(i=j+1;i<m;i++) { Q[i] = C[i-j-1]; }
	                return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,j+1))};
	            }
	        }
	        a = H[m-2][m-2]; b = H[m-2][m-1];
	        c = H[m-1][m-2]; d = H[m-1][m-1];
	        tr = a+d;
	        det = (a*d-b*c);
	        Hloc = numeric.getBlock(H, [0,0], [2,2]);
	        if(tr*tr>=4*det) {
	            var s1,s2;
	            s1 = 0.5*(tr+Math.sqrt(tr*tr-4*det));
	            s2 = 0.5*(tr-Math.sqrt(tr*tr-4*det));
	            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
	                                           numeric.mul(Hloc,s1+s2)),
	                               numeric.diag(numeric.rep([3],s1*s2)));
	        } else {
	            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
	                                           numeric.mul(Hloc,tr)),
	                               numeric.diag(numeric.rep([3],det)));
	        }
	        x = [Hloc[0][0],Hloc[1][0],Hloc[2][0]];
	        v = numeric.house(x);
	        B = [H[0],H[1],H[2]];
	        C = numeric.tensor(v,numeric.dot(v,B));
	        for(i=0;i<3;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<m;k++) Hi[k] -= 2*Ci[k]; }
	        B = numeric.getBlock(H, [0,0],[m-1,2]);
	        C = numeric.tensor(numeric.dot(B,v),v);
	        for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<3;k++) Hi[k] -= 2*Ci[k]; }
	        B = [Q[0],Q[1],Q[2]];
	        C = numeric.tensor(v,numeric.dot(v,B));
	        for(i=0;i<3;i++) { Qi = Q[i]; Ci = C[i]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
	        var J;
	        for(j=0;j<m-2;j++) {
	            for(k=j;k<=j+1;k++) {
	                if(Math.abs(H[k+1][k]) < epsilon*(Math.abs(H[k][k])+Math.abs(H[k+1][k+1]))) {
	                    var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[k,k]),maxiter);
	                    var QH2 = numeric.QRFrancis(numeric.getBlock(H,[k+1,k+1],[m-1,m-1]),maxiter);
	                    B = Array(k+1);
	                    for(i=0;i<=k;i++) { B[i] = Q[i]; }
	                    C = numeric.dot(QH1.Q,B);
	                    for(i=0;i<=k;i++) { Q[i] = C[i]; }
	                    B = Array(m-k-1);
	                    for(i=k+1;i<m;i++) { B[i-k-1] = Q[i]; }
	                    C = numeric.dot(QH2.Q,B);
	                    for(i=k+1;i<m;i++) { Q[i] = C[i-k-1]; }
	                    return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,k+1))};
	                }
	            }
	            J = Math.min(m-1,j+3);
	            x = Array(J-j);
	            for(i=j+1;i<=J;i++) { x[i-j-1] = H[i][j]; }
	            v = numeric.house(x);
	            B = numeric.getBlock(H, [j+1,j],[J,m-1]);
	            C = numeric.tensor(v,numeric.dot(v,B));
	            for(i=j+1;i<=J;i++) { Hi = H[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Hi[k] -= 2*Ci[k-j]; }
	            B = numeric.getBlock(H, [0,j+1],[m-1,J]);
	            C = numeric.tensor(numeric.dot(B,v),v);
	            for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=j+1;k<=J;k++) Hi[k] -= 2*Ci[k-j-1]; }
	            B = Array(J-j);
	            for(i=j+1;i<=J;i++) B[i-j-1] = Q[i];
	            C = numeric.tensor(v,numeric.dot(v,B));
	            for(i=j+1;i<=J;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
	        }
	    }
	    throw new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');
	}
	
	numeric.eig = function eig(A,maxiter) {
	    var QH = numeric.toUpperHessenberg(A);
	    var QB = numeric.QRFrancis(QH.H,maxiter);
	    var T = numeric.T;
	    var n = A.length,i,k,flag = false,B = QB.B,H = numeric.dot(QB.Q,numeric.dot(QH.H,numeric.transpose(QB.Q)));
	    var Q = new T(numeric.dot(QB.Q,QH.Q)),Q0;
	    var m = B.length,j;
	    var a,b,c,d,p1,p2,disc,x,y,p,q,n1,n2;
	    var sqrt = Math.sqrt;
	    for(k=0;k<m;k++) {
	        i = B[k][0];
	        if(i === B[k][1]) {
	            // nothing
	        } else {
	            j = i+1;
	            a = H[i][i];
	            b = H[i][j];
	            c = H[j][i];
	            d = H[j][j];
	            if(b === 0 && c === 0) continue;
	            p1 = -a-d;
	            p2 = a*d-b*c;
	            disc = p1*p1-4*p2;
	            if(disc>=0) {
	                if(p1<0) x = -0.5*(p1-sqrt(disc));
	                else     x = -0.5*(p1+sqrt(disc));
	                n1 = (a-x)*(a-x)+b*b;
	                n2 = c*c+(d-x)*(d-x);
	                if(n1>n2) {
	                    n1 = sqrt(n1);
	                    p = (a-x)/n1;
	                    q = b/n1;
	                } else {
	                    n2 = sqrt(n2);
	                    p = c/n2;
	                    q = (d-x)/n2;
	                }
	                Q0 = new T([[q,-p],[p,q]]);
	                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
	            } else {
	                x = -0.5*p1;
	                y = 0.5*sqrt(-disc);
	                n1 = (a-x)*(a-x)+b*b;
	                n2 = c*c+(d-x)*(d-x);
	                if(n1>n2) {
	                    n1 = sqrt(n1+y*y);
	                    p = (a-x)/n1;
	                    q = b/n1;
	                    x = 0;
	                    y /= n1;
	                } else {
	                    n2 = sqrt(n2+y*y);
	                    p = c/n2;
	                    q = (d-x)/n2;
	                    x = y/n2;
	                    y = 0;
	                }
	                Q0 = new T([[q,-p],[p,q]],[[x,y],[y,-x]]);
	                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
	            }
	        }
	    }
	    var R = Q.dot(A).dot(Q.transjugate()), n = A.length, E = numeric.T.identity(n);
	    for(j=0;j<n;j++) {
	        if(j>0) {
	            for(k=j-1;k>=0;k--) {
	                var Rk = R.get([k,k]), Rj = R.get([j,j]);
	                if(numeric.neq(Rk.x,Rj.x) || numeric.neq(Rk.y,Rj.y)) {
	                    x = R.getRow(k).getBlock([k],[j-1]);
	                    y = E.getRow(j).getBlock([k],[j-1]);
	                    E.set([j,k],(R.get([k,j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));
	                } else {
	                    E.setRow(j,E.getRow(k));
	                    continue;
	                }
	            }
	        }
	    }
	    for(j=0;j<n;j++) {
	        x = E.getRow(j);
	        E.setRow(j,x.div(x.norm2()));
	    }
	    E = E.transpose();
	    E = Q.transjugate().dot(E);
	    return { lambda:R.getDiag(), E:E };
	};
	
	// 5. Compressed Column Storage matrices
	numeric.ccsSparse = function ccsSparse(A) {
	    var m = A.length,n,foo, i,j, counts = [];
	    for(i=m-1;i!==-1;--i) {
	        foo = A[i];
	        for(j in foo) {
	            j = parseInt(j);
	            while(j>=counts.length) counts[counts.length] = 0;
	            if(foo[j]!==0) counts[j]++;
	        }
	    }
	    var n = counts.length;
	    var Ai = Array(n+1);
	    Ai[0] = 0;
	    for(i=0;i<n;++i) Ai[i+1] = Ai[i] + counts[i];
	    var Aj = Array(Ai[n]), Av = Array(Ai[n]);
	    for(i=m-1;i!==-1;--i) {
	        foo = A[i];
	        for(j in foo) {
	            if(foo[j]!==0) {
	                counts[j]--;
	                Aj[Ai[j]+counts[j]] = i;
	                Av[Ai[j]+counts[j]] = foo[j];
	            }
	        }
	    }
	    return [Ai,Aj,Av];
	}
	numeric.ccsFull = function ccsFull(A) {
	    var Ai = A[0], Aj = A[1], Av = A[2], s = numeric.ccsDim(A), m = s[0], n = s[1], i,j,j0,j1,k;
	    var B = numeric.rep([m,n],0);
	    for(i=0;i<n;i++) {
	        j0 = Ai[i];
	        j1 = Ai[i+1];
	        for(j=j0;j<j1;++j) { B[Aj[j]][i] = Av[j]; }
	    }
	    return B;
	}
	numeric.ccsTSolve = function ccsTSolve(A,b,x,bj,xj) {
	    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, max = Math.max,n=0;
	    if(typeof bj === "undefined") x = numeric.rep([m],0);
	    if(typeof bj === "undefined") bj = numeric.linspace(0,x.length-1);
	    if(typeof xj === "undefined") xj = [];
	    function dfs(j) {
	        var k;
	        if(x[j] !== 0) return;
	        x[j] = 1;
	        for(k=Ai[j];k<Ai[j+1];++k) dfs(Aj[k]);
	        xj[n] = j;
	        ++n;
	    }
	    var i,j,j0,j1,k,l,l0,l1,a;
	    for(i=bj.length-1;i!==-1;--i) { dfs(bj[i]); }
	    xj.length = n;
	    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
	    for(i=bj.length-1;i!==-1;--i) { j = bj[i]; x[j] = b[j]; }
	    for(i=xj.length-1;i!==-1;--i) {
	        j = xj[i];
	        j0 = Ai[j];
	        j1 = max(Ai[j+1],j0);
	        for(k=j0;k!==j1;++k) { if(Aj[k] === j) { x[j] /= Av[k]; break; } }
	        a = x[j];
	        for(k=j0;k!==j1;++k) {
	            l = Aj[k];
	            if(l !== j) x[l] -= a*Av[k];
	        }
	    }
	    return x;
	}
	numeric.ccsDFS = function ccsDFS(n) {
	    this.k = Array(n);
	    this.k1 = Array(n);
	    this.j = Array(n);
	}
	numeric.ccsDFS.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv) {
	    var m = 0,foo,n=xj.length;
	    var k = this.k, k1 = this.k1, j = this.j,km,k11;
	    if(x[J]!==0) return;
	    x[J] = 1;
	    j[0] = J;
	    k[0] = km = Ai[J];
	    k1[0] = k11 = Ai[J+1];
	    while(1) {
	        if(km >= k11) {
	            xj[n] = j[m];
	            if(m===0) return;
	            ++n;
	            --m;
	            km = k[m];
	            k11 = k1[m];
	        } else {
	            foo = Pinv[Aj[km]];
	            if(x[foo] === 0) {
	                x[foo] = 1;
	                k[m] = km;
	                ++m;
	                j[m] = foo;
	                km = Ai[foo];
	                k1[m] = k11 = Ai[foo+1];
	            } else ++km;
	        }
	    }
	}
	numeric.ccsLPSolve = function ccsLPSolve(A,B,x,xj,I,Pinv,dfs) {
	    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
	    var Bi = B[0], Bj = B[1], Bv = B[2];
	    
	    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
	    i0 = Bi[I];
	    i1 = Bi[I+1];
	    xj.length = 0;
	    for(i=i0;i<i1;++i) { dfs.dfs(Pinv[Bj[i]],Ai,Aj,x,xj,Pinv); }
	    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
	    for(i=i0;i!==i1;++i) { j = Pinv[Bj[i]]; x[j] = Bv[i]; }
	    for(i=xj.length-1;i!==-1;--i) {
	        j = xj[i];
	        j0 = Ai[j];
	        j1 = Ai[j+1];
	        for(k=j0;k<j1;++k) { if(Pinv[Aj[k]] === j) { x[j] /= Av[k]; break; } }
	        a = x[j];
	        for(k=j0;k<j1;++k) {
	            l = Pinv[Aj[k]];
	            if(l !== j) x[l] -= a*Av[k];
	        }
	    }
	    return x;
	}
	numeric.ccsLUP1 = function ccsLUP1(A,threshold) {
	    var m = A[0].length-1;
	    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
	    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
	    var x = numeric.rep([m],0), xj = numeric.rep([m],0);
	    var i,j,k,j0,j1,a,e,c,d,K;
	    var sol = numeric.ccsLPSolve, max = Math.max, abs = Math.abs;
	    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
	    var dfs = new numeric.ccsDFS(m);
	    if(typeof threshold === "undefined") { threshold = 1; }
	    for(i=0;i<m;++i) {
	        sol(L,A,x,xj,i,Pinv,dfs);
	        a = -1;
	        e = -1;
	        for(j=xj.length-1;j!==-1;--j) {
	            k = xj[j];
	            if(k <= i) continue;
	            c = abs(x[k]);
	            if(c > a) { e = k; a = c; }
	        }
	        if(abs(x[i])<threshold*a) {
	            j = P[i];
	            a = P[e];
	            P[i] = a; Pinv[a] = i;
	            P[e] = j; Pinv[j] = e;
	            a = x[i]; x[i] = x[e]; x[e] = a;
	        }
	        a = Li[i];
	        e = Ui[i];
	        d = x[i];
	        Lj[a] = P[i];
	        Lv[a] = 1;
	        ++a;
	        for(j=xj.length-1;j!==-1;--j) {
	            k = xj[j];
	            c = x[k];
	            xj[j] = 0;
	            x[k] = 0;
	            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
	            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
	        }
	        Li[i+1] = a;
	        Ui[i+1] = e;
	    }
	    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
	    return {L:L, U:U, P:P, Pinv:Pinv};
	}
	numeric.ccsDFS0 = function ccsDFS0(n) {
	    this.k = Array(n);
	    this.k1 = Array(n);
	    this.j = Array(n);
	}
	numeric.ccsDFS0.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv,P) {
	    var m = 0,foo,n=xj.length;
	    var k = this.k, k1 = this.k1, j = this.j,km,k11;
	    if(x[J]!==0) return;
	    x[J] = 1;
	    j[0] = J;
	    k[0] = km = Ai[Pinv[J]];
	    k1[0] = k11 = Ai[Pinv[J]+1];
	    while(1) {
	        if(isNaN(km)) throw new Error("Ow!");
	        if(km >= k11) {
	            xj[n] = Pinv[j[m]];
	            if(m===0) return;
	            ++n;
	            --m;
	            km = k[m];
	            k11 = k1[m];
	        } else {
	            foo = Aj[km];
	            if(x[foo] === 0) {
	                x[foo] = 1;
	                k[m] = km;
	                ++m;
	                j[m] = foo;
	                foo = Pinv[foo];
	                km = Ai[foo];
	                k1[m] = k11 = Ai[foo+1];
	            } else ++km;
	        }
	    }
	}
	numeric.ccsLPSolve0 = function ccsLPSolve0(A,B,y,xj,I,Pinv,P,dfs) {
	    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
	    var Bi = B[0], Bj = B[1], Bv = B[2];
	    
	    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
	    i0 = Bi[I];
	    i1 = Bi[I+1];
	    xj.length = 0;
	    for(i=i0;i<i1;++i) { dfs.dfs(Bj[i],Ai,Aj,y,xj,Pinv,P); }
	    for(i=xj.length-1;i!==-1;--i) { j = xj[i]; y[P[j]] = 0; }
	    for(i=i0;i!==i1;++i) { j = Bj[i]; y[j] = Bv[i]; }
	    for(i=xj.length-1;i!==-1;--i) {
	        j = xj[i];
	        l = P[j];
	        j0 = Ai[j];
	        j1 = Ai[j+1];
	        for(k=j0;k<j1;++k) { if(Aj[k] === l) { y[l] /= Av[k]; break; } }
	        a = y[l];
	        for(k=j0;k<j1;++k) y[Aj[k]] -= a*Av[k];
	        y[l] = a;
	    }
	}
	numeric.ccsLUP0 = function ccsLUP0(A,threshold) {
	    var m = A[0].length-1;
	    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
	    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
	    var y = numeric.rep([m],0), xj = numeric.rep([m],0);
	    var i,j,k,j0,j1,a,e,c,d,K;
	    var sol = numeric.ccsLPSolve0, max = Math.max, abs = Math.abs;
	    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
	    var dfs = new numeric.ccsDFS0(m);
	    if(typeof threshold === "undefined") { threshold = 1; }
	    for(i=0;i<m;++i) {
	        sol(L,A,y,xj,i,Pinv,P,dfs);
	        a = -1;
	        e = -1;
	        for(j=xj.length-1;j!==-1;--j) {
	            k = xj[j];
	            if(k <= i) continue;
	            c = abs(y[P[k]]);
	            if(c > a) { e = k; a = c; }
	        }
	        if(abs(y[P[i]])<threshold*a) {
	            j = P[i];
	            a = P[e];
	            P[i] = a; Pinv[a] = i;
	            P[e] = j; Pinv[j] = e;
	        }
	        a = Li[i];
	        e = Ui[i];
	        d = y[P[i]];
	        Lj[a] = P[i];
	        Lv[a] = 1;
	        ++a;
	        for(j=xj.length-1;j!==-1;--j) {
	            k = xj[j];
	            c = y[P[k]];
	            xj[j] = 0;
	            y[P[k]] = 0;
	            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
	            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
	        }
	        Li[i+1] = a;
	        Ui[i+1] = e;
	    }
	    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
	    return {L:L, U:U, P:P, Pinv:Pinv};
	}
	numeric.ccsLUP = numeric.ccsLUP0;
	
	numeric.ccsDim = function ccsDim(A) { return [numeric.sup(A[1])+1,A[0].length-1]; }
	numeric.ccsGetBlock = function ccsGetBlock(A,i,j) {
	    var s = numeric.ccsDim(A),m=s[0],n=s[1];
	    if(typeof i === "undefined") { i = numeric.linspace(0,m-1); }
	    else if(typeof i === "number") { i = [i]; }
	    if(typeof j === "undefined") { j = numeric.linspace(0,n-1); }
	    else if(typeof j === "number") { j = [j]; }
	    var p,p0,p1,P = i.length,q,Q = j.length,r,jq,ip;
	    var Bi = numeric.rep([n],0), Bj=[], Bv=[], B = [Bi,Bj,Bv];
	    var Ai = A[0], Aj = A[1], Av = A[2];
	    var x = numeric.rep([m],0),count=0,flags = numeric.rep([m],0);
	    for(q=0;q<Q;++q) {
	        jq = j[q];
	        var q0 = Ai[jq];
	        var q1 = Ai[jq+1];
	        for(p=q0;p<q1;++p) {
	            r = Aj[p];
	            flags[r] = 1;
	            x[r] = Av[p];
	        }
	        for(p=0;p<P;++p) {
	            ip = i[p];
	            if(flags[ip]) {
	                Bj[count] = p;
	                Bv[count] = x[i[p]];
	                ++count;
	            }
	        }
	        for(p=q0;p<q1;++p) {
	            r = Aj[p];
	            flags[r] = 0;
	        }
	        Bi[q+1] = count;
	    }
	    return B;
	}
	
	numeric.ccsDot = function ccsDot(A,B) {
	    var Ai = A[0], Aj = A[1], Av = A[2];
	    var Bi = B[0], Bj = B[1], Bv = B[2];
	    var sA = numeric.ccsDim(A), sB = numeric.ccsDim(B);
	    var m = sA[0], n = sA[1], o = sB[1];
	    var x = numeric.rep([m],0), flags = numeric.rep([m],0), xj = Array(m);
	    var Ci = numeric.rep([o],0), Cj = [], Cv = [], C = [Ci,Cj,Cv];
	    var i,j,k,j0,j1,i0,i1,l,p,a,b;
	    for(k=0;k!==o;++k) {
	        j0 = Bi[k];
	        j1 = Bi[k+1];
	        p = 0;
	        for(j=j0;j<j1;++j) {
	            a = Bj[j];
	            b = Bv[j];
	            i0 = Ai[a];
	            i1 = Ai[a+1];
	            for(i=i0;i<i1;++i) {
	                l = Aj[i];
	                if(flags[l]===0) {
	                    xj[p] = l;
	                    flags[l] = 1;
	                    p = p+1;
	                }
	                x[l] = x[l] + Av[i]*b;
	            }
	        }
	        j0 = Ci[k];
	        j1 = j0+p;
	        Ci[k+1] = j1;
	        for(j=p-1;j!==-1;--j) {
	            b = j0+j;
	            i = xj[j];
	            Cj[b] = i;
	            Cv[b] = x[i];
	            flags[i] = 0;
	            x[i] = 0;
	        }
	        Ci[k+1] = Ci[k]+p;
	    }
	    return C;
	}
	
	numeric.ccsLUPSolve = function ccsLUPSolve(LUP,B) {
	    var L = LUP.L, U = LUP.U, P = LUP.P;
	    var Bi = B[0];
	    var flag = false;
	    if(typeof Bi !== "object") { B = [[0,B.length],numeric.linspace(0,B.length-1),B]; Bi = B[0]; flag = true; }
	    var Bj = B[1], Bv = B[2];
	    var n = L[0].length-1, m = Bi.length-1;
	    var x = numeric.rep([n],0), xj = Array(n);
	    var b = numeric.rep([n],0), bj = Array(n);
	    var Xi = numeric.rep([m+1],0), Xj = [], Xv = [];
	    var sol = numeric.ccsTSolve;
	    var i,j,j0,j1,k,J,N=0;
	    for(i=0;i<m;++i) {
	        k = 0;
	        j0 = Bi[i];
	        j1 = Bi[i+1];
	        for(j=j0;j<j1;++j) { 
	            J = LUP.Pinv[Bj[j]];
	            bj[k] = J;
	            b[J] = Bv[j];
	            ++k;
	        }
	        bj.length = k;
	        sol(L,b,x,bj,xj);
	        for(j=bj.length-1;j!==-1;--j) b[bj[j]] = 0;
	        sol(U,x,b,xj,bj);
	        if(flag) return b;
	        for(j=xj.length-1;j!==-1;--j) x[xj[j]] = 0;
	        for(j=bj.length-1;j!==-1;--j) {
	            J = bj[j];
	            Xj[N] = J;
	            Xv[N] = b[J];
	            b[J] = 0;
	            ++N;
	        }
	        Xi[i+1] = N;
	    }
	    return [Xi,Xj,Xv];
	}
	
	numeric.ccsbinop = function ccsbinop(body,setup) {
	    if(typeof setup === "undefined") setup='';
	    return Function('X','Y',
	            'var Xi = X[0], Xj = X[1], Xv = X[2];\n'+
	            'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\n'+
	            'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\n'+
	            'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\n'+
	            'var x = numeric.rep([m],0),y = numeric.rep([m],0);\n'+
	            'var xk,yk,zk;\n'+
	            'var i,j,j0,j1,k,p=0;\n'+
	            setup+
	            'for(i=0;i<n;++i) {\n'+
	            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
	            '  for(j=j0;j!==j1;++j) {\n'+
	            '    k = Xj[j];\n'+
	            '    x[k] = 1;\n'+
	            '    Zj[p] = k;\n'+
	            '    ++p;\n'+
	            '  }\n'+
	            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
	            '  for(j=j0;j!==j1;++j) {\n'+
	            '    k = Yj[j];\n'+
	            '    y[k] = Yv[j];\n'+
	            '    if(x[k] === 0) {\n'+
	            '      Zj[p] = k;\n'+
	            '      ++p;\n'+
	            '    }\n'+
	            '  }\n'+
	            '  Zi[i+1] = p;\n'+
	            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
	            '  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n'+
	            '  j0 = Zi[i]; j1 = Zi[i+1];\n'+
	            '  for(j=j0;j!==j1;++j) {\n'+
	            '    k = Zj[j];\n'+
	            '    xk = x[k];\n'+
	            '    yk = y[k];\n'+
	            body+'\n'+
	            '    Zv[j] = zk;\n'+
	            '  }\n'+
	            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
	            '  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n'+
	            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
	            '  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n'+
	            '}\n'+
	            'return [Zi,Zj,Zv];'
	            );
	};
	
	(function() {
	    var k,A,B,C;
	    for(k in numeric.ops2) {
	        if(isFinite(eval('1'+numeric.ops2[k]+'0'))) A = '[Y[0],Y[1],numeric.'+k+'(X,Y[2])]';
	        else A = 'NaN';
	        if(isFinite(eval('0'+numeric.ops2[k]+'1'))) B = '[X[0],X[1],numeric.'+k+'(X[2],Y)]';
	        else B = 'NaN';
	        if(isFinite(eval('1'+numeric.ops2[k]+'0')) && isFinite(eval('0'+numeric.ops2[k]+'1'))) C = 'numeric.ccs'+k+'MM(X,Y)';
	        else C = 'NaN';
	        numeric['ccs'+k+'MM'] = numeric.ccsbinop('zk = xk '+numeric.ops2[k]+'yk;');
	        numeric['ccs'+k] = Function('X','Y',
	                'if(typeof X === "number") return '+A+';\n'+
	                'if(typeof Y === "number") return '+B+';\n'+
	                'return '+C+';\n'
	                );
	    }
	}());
	
	numeric.ccsScatter = function ccsScatter(A) {
	    var Ai = A[0], Aj = A[1], Av = A[2];
	    var n = numeric.sup(Aj)+1,m=Ai.length;
	    var Ri = numeric.rep([n],0),Rj=Array(m), Rv = Array(m);
	    var counts = numeric.rep([n],0),i;
	    for(i=0;i<m;++i) counts[Aj[i]]++;
	    for(i=0;i<n;++i) Ri[i+1] = Ri[i] + counts[i];
	    var ptr = Ri.slice(0),k,Aii;
	    for(i=0;i<m;++i) {
	        Aii = Aj[i];
	        k = ptr[Aii];
	        Rj[k] = Ai[i];
	        Rv[k] = Av[i];
	        ptr[Aii]=ptr[Aii]+1;
	    }
	    return [Ri,Rj,Rv];
	}
	
	numeric.ccsGather = function ccsGather(A) {
	    var Ai = A[0], Aj = A[1], Av = A[2];
	    var n = Ai.length-1,m = Aj.length;
	    var Ri = Array(m), Rj = Array(m), Rv = Array(m);
	    var i,j,j0,j1,p;
	    p=0;
	    for(i=0;i<n;++i) {
	        j0 = Ai[i];
	        j1 = Ai[i+1];
	        for(j=j0;j!==j1;++j) {
	            Rj[p] = i;
	            Ri[p] = Aj[j];
	            Rv[p] = Av[j];
	            ++p;
	        }
	    }
	    return [Ri,Rj,Rv];
	}
	
	// The following sparse linear algebra routines are deprecated.
	
	numeric.sdim = function dim(A,ret,k) {
	    if(typeof ret === "undefined") { ret = []; }
	    if(typeof A !== "object") return ret;
	    if(typeof k === "undefined") { k=0; }
	    if(!(k in ret)) { ret[k] = 0; }
	    if(A.length > ret[k]) ret[k] = A.length;
	    var i;
	    for(i in A) {
	        if(A.hasOwnProperty(i)) dim(A[i],ret,k+1);
	    }
	    return ret;
	};
	
	numeric.sclone = function clone(A,k,n) {
	    if(typeof k === "undefined") { k=0; }
	    if(typeof n === "undefined") { n = numeric.sdim(A).length; }
	    var i,ret = Array(A.length);
	    if(k === n-1) {
	        for(i in A) { if(A.hasOwnProperty(i)) ret[i] = A[i]; }
	        return ret;
	    }
	    for(i in A) {
	        if(A.hasOwnProperty(i)) ret[i] = clone(A[i],k+1,n);
	    }
	    return ret;
	}
	
	numeric.sdiag = function diag(d) {
	    var n = d.length,i,ret = Array(n),i1,i2,i3;
	    for(i=n-1;i>=1;i-=2) {
	        i1 = i-1;
	        ret[i] = []; ret[i][i] = d[i];
	        ret[i1] = []; ret[i1][i1] = d[i1];
	    }
	    if(i===0) { ret[0] = []; ret[0][0] = d[i]; }
	    return ret;
	}
	
	numeric.sidentity = function identity(n) { return numeric.sdiag(numeric.rep([n],1)); }
	
	numeric.stranspose = function transpose(A) {
	    var ret = [], n = A.length, i,j,Ai;
	    for(i in A) {
	        if(!(A.hasOwnProperty(i))) continue;
	        Ai = A[i];
	        for(j in Ai) {
	            if(!(Ai.hasOwnProperty(j))) continue;
	            if(typeof ret[j] !== "object") { ret[j] = []; }
	            ret[j][i] = Ai[j];
	        }
	    }
	    return ret;
	}
	
	numeric.sLUP = function LUP(A,tol) {
	    throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.");
	};
	
	numeric.sdotMM = function dotMM(A,B) {
	    var p = A.length, q = B.length, BT = numeric.stranspose(B), r = BT.length, Ai, BTk;
	    var i,j,k,accum;
	    var ret = Array(p),reti;
	    for(i=p-1;i>=0;i--) {
	        reti = [];
	        Ai = A[i];
	        for(k=r-1;k>=0;k--) {
	            accum = 0;
	            BTk = BT[k];
	            for(j in Ai) {
	                if(!(Ai.hasOwnProperty(j))) continue;
	                if(j in BTk) { accum += Ai[j]*BTk[j]; }
	            }
	            if(accum) reti[k] = accum;
	        }
	        ret[i] = reti;
	    }
	    return ret;
	}
	
	numeric.sdotMV = function dotMV(A,x) {
	    var p = A.length, Ai, i,j;
	    var ret = Array(p), accum;
	    for(i=p-1;i>=0;i--) {
	        Ai = A[i];
	        accum = 0;
	        for(j in Ai) {
	            if(!(Ai.hasOwnProperty(j))) continue;
	            if(x[j]) accum += Ai[j]*x[j];
	        }
	        if(accum) ret[i] = accum;
	    }
	    return ret;
	}
	
	numeric.sdotVM = function dotMV(x,A) {
	    var i,j,Ai,alpha;
	    var ret = [], accum;
	    for(i in x) {
	        if(!x.hasOwnProperty(i)) continue;
	        Ai = A[i];
	        alpha = x[i];
	        for(j in Ai) {
	            if(!Ai.hasOwnProperty(j)) continue;
	            if(!ret[j]) { ret[j] = 0; }
	            ret[j] += alpha*Ai[j];
	        }
	    }
	    return ret;
	}
	
	numeric.sdotVV = function dotVV(x,y) {
	    var i,ret=0;
	    for(i in x) { if(x[i] && y[i]) ret+= x[i]*y[i]; }
	    return ret;
	}
	
	numeric.sdot = function dot(A,B) {
	    var m = numeric.sdim(A).length, n = numeric.sdim(B).length;
	    var k = m*1000+n;
	    switch(k) {
	    case 0: return A*B;
	    case 1001: return numeric.sdotVV(A,B);
	    case 2001: return numeric.sdotMV(A,B);
	    case 1002: return numeric.sdotVM(A,B);
	    case 2002: return numeric.sdotMM(A,B);
	    default: throw new Error('numeric.sdot not implemented for tensors of order '+m+' and '+n);
	    }
	}
	
	numeric.sscatter = function scatter(V) {
	    var n = V[0].length, Vij, i, j, m = V.length, A = [], Aj;
	    for(i=n-1;i>=0;--i) {
	        if(!V[m-1][i]) continue;
	        Aj = A;
	        for(j=0;j<m-2;j++) {
	            Vij = V[j][i];
	            if(!Aj[Vij]) Aj[Vij] = [];
	            Aj = Aj[Vij];
	        }
	        Aj[V[j][i]] = V[j+1][i];
	    }
	    return A;
	}
	
	numeric.sgather = function gather(A,ret,k) {
	    if(typeof ret === "undefined") ret = [];
	    if(typeof k === "undefined") k = [];
	    var n,i,Ai;
	    n = k.length;
	    for(i in A) {
	        if(A.hasOwnProperty(i)) {
	            k[n] = parseInt(i);
	            Ai = A[i];
	            if(typeof Ai === "number") {
	                if(Ai) {
	                    if(ret.length === 0) {
	                        for(i=n+1;i>=0;--i) ret[i] = [];
	                    }
	                    for(i=n;i>=0;--i) ret[i].push(k[i]);
	                    ret[n+1].push(Ai);
	                }
	            } else gather(Ai,ret,k);
	        }
	    }
	    if(k.length>n) k.pop();
	    return ret;
	}
	
	// 6. Coordinate matrices
	numeric.cLU = function LU(A) {
	    var I = A[0], J = A[1], V = A[2];
	    var p = I.length, m=0, i,j,k,a,b,c;
	    for(i=0;i<p;i++) if(I[i]>m) m=I[i];
	    m++;
	    var L = Array(m), U = Array(m), left = numeric.rep([m],Infinity), right = numeric.rep([m],-Infinity);
	    var Ui, Uj,alpha;
	    for(k=0;k<p;k++) {
	        i = I[k];
	        j = J[k];
	        if(j<left[i]) left[i] = j;
	        if(j>right[i]) right[i] = j;
	    }
	    for(i=0;i<m-1;i++) { if(right[i] > right[i+1]) right[i+1] = right[i]; }
	    for(i=m-1;i>=1;i--) { if(left[i]<left[i-1]) left[i-1] = left[i]; }
	    var countL = 0, countU = 0;
	    for(i=0;i<m;i++) {
	        U[i] = numeric.rep([right[i]-left[i]+1],0);
	        L[i] = numeric.rep([i-left[i]],0);
	        countL += i-left[i]+1;
	        countU += right[i]-i+1;
	    }
	    for(k=0;k<p;k++) { i = I[k]; U[i][J[k]-left[i]] = V[k]; }
	    for(i=0;i<m-1;i++) {
	        a = i-left[i];
	        Ui = U[i];
	        for(j=i+1;left[j]<=i && j<m;j++) {
	            b = i-left[j];
	            c = right[i]-i;
	            Uj = U[j];
	            alpha = Uj[b]/Ui[a];
	            if(alpha) {
	                for(k=1;k<=c;k++) { Uj[k+b] -= alpha*Ui[k+a]; }
	                L[j][i-left[j]] = alpha;
	            }
	        }
	    }
	    var Ui = [], Uj = [], Uv = [], Li = [], Lj = [], Lv = [];
	    var p,q,foo;
	    p=0; q=0;
	    for(i=0;i<m;i++) {
	        a = left[i];
	        b = right[i];
	        foo = U[i];
	        for(j=i;j<=b;j++) {
	            if(foo[j-a]) {
	                Ui[p] = i;
	                Uj[p] = j;
	                Uv[p] = foo[j-a];
	                p++;
	            }
	        }
	        foo = L[i];
	        for(j=a;j<i;j++) {
	            if(foo[j-a]) {
	                Li[q] = i;
	                Lj[q] = j;
	                Lv[q] = foo[j-a];
	                q++;
	            }
	        }
	        Li[q] = i;
	        Lj[q] = i;
	        Lv[q] = 1;
	        q++;
	    }
	    return {U:[Ui,Uj,Uv], L:[Li,Lj,Lv]};
	};
	
	numeric.cLUsolve = function LUsolve(lu,b) {
	    var L = lu.L, U = lu.U, ret = numeric.clone(b);
	    var Li = L[0], Lj = L[1], Lv = L[2];
	    var Ui = U[0], Uj = U[1], Uv = U[2];
	    var p = Ui.length, q = Li.length;
	    var m = ret.length,i,j,k;
	    k = 0;
	    for(i=0;i<m;i++) {
	        while(Lj[k] < i) {
	            ret[i] -= Lv[k]*ret[Lj[k]];
	            k++;
	        }
	        k++;
	    }
	    k = p-1;
	    for(i=m-1;i>=0;i--) {
	        while(Uj[k] > i) {
	            ret[i] -= Uv[k]*ret[Uj[k]];
	            k--;
	        }
	        ret[i] /= Uv[k];
	        k--;
	    }
	    return ret;
	};
	
	numeric.cgrid = function grid(n,shape) {
	    if(typeof n === "number") n = [n,n];
	    var ret = numeric.rep(n,-1);
	    var i,j,count;
	    if(typeof shape !== "function") {
	        switch(shape) {
	        case 'L':
	            shape = function(i,j) { return (i>=n[0]/2 || j<n[1]/2); }
	            break;
	        default:
	            shape = function(i,j) { return true; };
	            break;
	        }
	    }
	    count=0;
	    for(i=1;i<n[0]-1;i++) for(j=1;j<n[1]-1;j++) 
	        if(shape(i,j)) {
	            ret[i][j] = count;
	            count++;
	        }
	    return ret;
	}
	
	numeric.cdelsq = function delsq(g) {
	    var dir = [[-1,0],[0,-1],[0,1],[1,0]];
	    var s = numeric.dim(g), m = s[0], n = s[1], i,j,k,p,q;
	    var Li = [], Lj = [], Lv = [];
	    for(i=1;i<m-1;i++) for(j=1;j<n-1;j++) {
	        if(g[i][j]<0) continue;
	        for(k=0;k<4;k++) {
	            p = i+dir[k][0];
	            q = j+dir[k][1];
	            if(g[p][q]<0) continue;
	            Li.push(g[i][j]);
	            Lj.push(g[p][q]);
	            Lv.push(-1);
	        }
	        Li.push(g[i][j]);
	        Lj.push(g[i][j]);
	        Lv.push(4);
	    }
	    return [Li,Lj,Lv];
	}
	
	numeric.cdotMV = function dotMV(A,x) {
	    var ret, Ai = A[0], Aj = A[1], Av = A[2],k,p=Ai.length,N;
	    N=0;
	    for(k=0;k<p;k++) { if(Ai[k]>N) N = Ai[k]; }
	    N++;
	    ret = numeric.rep([N],0);
	    for(k=0;k<p;k++) { ret[Ai[k]]+=Av[k]*x[Aj[k]]; }
	    return ret;
	}
	
	// 7. Splines
	
	numeric.Spline = function Spline(x,yl,yr,kl,kr) { this.x = x; this.yl = yl; this.yr = yr; this.kl = kl; this.kr = kr; }
	numeric.Spline.prototype._at = function _at(x1,p) {
	    var x = this.x;
	    var yl = this.yl;
	    var yr = this.yr;
	    var kl = this.kl;
	    var kr = this.kr;
	    var x1,a,b,t;
	    var add = numeric.add, sub = numeric.sub, mul = numeric.mul;
	    a = sub(mul(kl[p],x[p+1]-x[p]),sub(yr[p+1],yl[p]));
	    b = add(mul(kr[p+1],x[p]-x[p+1]),sub(yr[p+1],yl[p]));
	    t = (x1-x[p])/(x[p+1]-x[p]);
	    var s = t*(1-t);
	    return add(add(add(mul(1-t,yl[p]),mul(t,yr[p+1])),mul(a,s*(1-t))),mul(b,s*t));
	}
	numeric.Spline.prototype.at = function at(x0) {
	    if(typeof x0 === "number") {
	        var x = this.x;
	        var n = x.length;
	        var p,q,mid,floor = Math.floor,a,b,t;
	        p = 0;
	        q = n-1;
	        while(q-p>1) {
	            mid = floor((p+q)/2);
	            if(x[mid] <= x0) p = mid;
	            else q = mid;
	        }
	        return this._at(x0,p);
	    }
	    var n = x0.length, i, ret = Array(n);
	    for(i=n-1;i!==-1;--i) ret[i] = this.at(x0[i]);
	    return ret;
	}
	numeric.Spline.prototype.diff = function diff() {
	    var x = this.x;
	    var yl = this.yl;
	    var yr = this.yr;
	    var kl = this.kl;
	    var kr = this.kr;
	    var n = yl.length;
	    var i,dx,dy;
	    var zl = kl, zr = kr, pl = Array(n), pr = Array(n);
	    var add = numeric.add, mul = numeric.mul, div = numeric.div, sub = numeric.sub;
	    for(i=n-1;i!==-1;--i) {
	        dx = x[i+1]-x[i];
	        dy = sub(yr[i+1],yl[i]);
	        pl[i] = div(add(mul(dy, 6),mul(kl[i],-4*dx),mul(kr[i+1],-2*dx)),dx*dx);
	        pr[i+1] = div(add(mul(dy,-6),mul(kl[i], 2*dx),mul(kr[i+1], 4*dx)),dx*dx);
	    }
	    return new numeric.Spline(x,zl,zr,pl,pr);
	}
	numeric.Spline.prototype.roots = function roots() {
	    function sqr(x) { return x*x; }
	    function heval(y0,y1,k0,k1,x) {
	        var A = k0*2-(y1-y0);
	        var B = -k1*2+(y1-y0);
	        var t = (x+1)*0.5;
	        var s = t*(1-t);
	        return (1-t)*y0+t*y1+A*s*(1-t)+B*s*t;
	    }
	    var ret = [];
	    var x = this.x, yl = this.yl, yr = this.yr, kl = this.kl, kr = this.kr;
	    if(typeof yl[0] === "number") {
	        yl = [yl];
	        yr = [yr];
	        kl = [kl];
	        kr = [kr];
	    }
	    var m = yl.length,n=x.length-1,i,j,k,y,s,t;
	    var ai,bi,ci,di, ret = Array(m),ri,k0,k1,y0,y1,A,B,D,dx,cx,stops,z0,z1,zm,t0,t1,tm;
	    var sqrt = Math.sqrt;
	    for(i=0;i!==m;++i) {
	        ai = yl[i];
	        bi = yr[i];
	        ci = kl[i];
	        di = kr[i];
	        ri = [];
	        for(j=0;j!==n;j++) {
	            if(j>0 && bi[j]*ai[j]<0) ri.push(x[j]);
	            dx = (x[j+1]-x[j]);
	            cx = x[j];
	            y0 = ai[j];
	            y1 = bi[j+1];
	            k0 = ci[j]/dx;
	            k1 = di[j+1]/dx;
	            D = sqr(k0-k1+3*(y0-y1)) + 12*k1*y0;
	            A = k1+3*y0+2*k0-3*y1;
	            B = 3*(k1+k0+2*(y0-y1));
	            if(D<=0) {
	                z0 = A/B;
	                if(z0>x[j] && z0<x[j+1]) stops = [x[j],z0,x[j+1]];
	                else stops = [x[j],x[j+1]];
	            } else {
	                z0 = (A-sqrt(D))/B;
	                z1 = (A+sqrt(D))/B;
	                stops = [x[j]];
	                if(z0>x[j] && z0<x[j+1]) stops.push(z0);
	                if(z1>x[j] && z1<x[j+1]) stops.push(z1);
	                stops.push(x[j+1]);
	            }
	            t0 = stops[0];
	            z0 = this._at(t0,j);
	            for(k=0;k<stops.length-1;k++) {
	                t1 = stops[k+1];
	                z1 = this._at(t1,j);
	                if(z0 === 0) {
	                    ri.push(t0); 
	                    t0 = t1;
	                    z0 = z1;
	                    continue;
	                }
	                if(z1 === 0 || z0*z1>0) {
	                    t0 = t1;
	                    z0 = z1;
	                    continue;
	                }
	                var side = 0;
	                while(1) {
	                    tm = (z0*t1-z1*t0)/(z0-z1);
	                    if(tm <= t0 || tm >= t1) { break; }
	                    zm = this._at(tm,j);
	                    if(zm*z1>0) {
	                        t1 = tm;
	                        z1 = zm;
	                        if(side === -1) z0*=0.5;
	                        side = -1;
	                    } else if(zm*z0>0) {
	                        t0 = tm;
	                        z0 = zm;
	                        if(side === 1) z1*=0.5;
	                        side = 1;
	                    } else break;
	                }
	                ri.push(tm);
	                t0 = stops[k+1];
	                z0 = this._at(t0, j);
	            }
	            if(z1 === 0) ri.push(t1);
	        }
	        ret[i] = ri;
	    }
	    if(typeof this.yl[0] === "number") return ret[0];
	    return ret;
	}
	numeric.spline = function spline(x,y,k1,kn) {
	    var n = x.length, b = [], dx = [], dy = [];
	    var i;
	    var sub = numeric.sub,mul = numeric.mul,add = numeric.add;
	    for(i=n-2;i>=0;i--) { dx[i] = x[i+1]-x[i]; dy[i] = sub(y[i+1],y[i]); }
	    if(typeof k1 === "string" || typeof kn === "string") { 
	        k1 = kn = "periodic";
	    }
	    // Build sparse tridiagonal system
	    var T = [[],[],[]];
	    switch(typeof k1) {
	    case "undefined":
	        b[0] = mul(3/(dx[0]*dx[0]),dy[0]);
	        T[0].push(0,0);
	        T[1].push(0,1);
	        T[2].push(2/dx[0],1/dx[0]);
	        break;
	    case "string":
	        b[0] = add(mul(3/(dx[n-2]*dx[n-2]),dy[n-2]),mul(3/(dx[0]*dx[0]),dy[0]));
	        T[0].push(0,0,0);
	        T[1].push(n-2,0,1);
	        T[2].push(1/dx[n-2],2/dx[n-2]+2/dx[0],1/dx[0]);
	        break;
	    default:
	        b[0] = k1;
	        T[0].push(0);
	        T[1].push(0);
	        T[2].push(1);
	        break;
	    }
	    for(i=1;i<n-1;i++) {
	        b[i] = add(mul(3/(dx[i-1]*dx[i-1]),dy[i-1]),mul(3/(dx[i]*dx[i]),dy[i]));
	        T[0].push(i,i,i);
	        T[1].push(i-1,i,i+1);
	        T[2].push(1/dx[i-1],2/dx[i-1]+2/dx[i],1/dx[i]);
	    }
	    switch(typeof kn) {
	    case "undefined":
	        b[n-1] = mul(3/(dx[n-2]*dx[n-2]),dy[n-2]);
	        T[0].push(n-1,n-1);
	        T[1].push(n-2,n-1);
	        T[2].push(1/dx[n-2],2/dx[n-2]);
	        break;
	    case "string":
	        T[1][T[1].length-1] = 0;
	        break;
	    default:
	        b[n-1] = kn;
	        T[0].push(n-1);
	        T[1].push(n-1);
	        T[2].push(1);
	        break;
	    }
	    if(typeof b[0] !== "number") b = numeric.transpose(b);
	    else b = [b];
	    var k = Array(b.length);
	    if(typeof k1 === "string") {
	        for(i=k.length-1;i!==-1;--i) {
	            k[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)),b[i]);
	            k[i][n-1] = k[i][0];
	        }
	    } else {
	        for(i=k.length-1;i!==-1;--i) {
	            k[i] = numeric.cLUsolve(numeric.cLU(T),b[i]);
	        }
	    }
	    if(typeof y[0] === "number") k = k[0];
	    else k = numeric.transpose(k);
	    return new numeric.Spline(x,y,y,k,k);
	}
	
	// 8. FFT
	numeric.fftpow2 = function fftpow2(x,y) {
	    var n = x.length;
	    if(n === 1) return;
	    var cos = Math.cos, sin = Math.sin, i,j;
	    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
	    j = n/2;
	    for(i=n-1;i!==-1;--i) {
	        --j;
	        xo[j] = x[i];
	        yo[j] = y[i];
	        --i;
	        xe[j] = x[i];
	        ye[j] = y[i];
	    }
	    fftpow2(xe,ye);
	    fftpow2(xo,yo);
	    j = n/2;
	    var t,k = (-6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
	    for(i=n-1;i!==-1;--i) {
	        --j;
	        if(j === -1) j = n/2-1;
	        t = k*i;
	        ci = cos(t);
	        si = sin(t);
	        x[i] = xe[j] + ci*xo[j] - si*yo[j];
	        y[i] = ye[j] + ci*yo[j] + si*xo[j];
	    }
	}
	numeric._ifftpow2 = function _ifftpow2(x,y) {
	    var n = x.length;
	    if(n === 1) return;
	    var cos = Math.cos, sin = Math.sin, i,j;
	    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
	    j = n/2;
	    for(i=n-1;i!==-1;--i) {
	        --j;
	        xo[j] = x[i];
	        yo[j] = y[i];
	        --i;
	        xe[j] = x[i];
	        ye[j] = y[i];
	    }
	    _ifftpow2(xe,ye);
	    _ifftpow2(xo,yo);
	    j = n/2;
	    var t,k = (6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
	    for(i=n-1;i!==-1;--i) {
	        --j;
	        if(j === -1) j = n/2-1;
	        t = k*i;
	        ci = cos(t);
	        si = sin(t);
	        x[i] = xe[j] + ci*xo[j] - si*yo[j];
	        y[i] = ye[j] + ci*yo[j] + si*xo[j];
	    }
	}
	numeric.ifftpow2 = function ifftpow2(x,y) {
	    numeric._ifftpow2(x,y);
	    numeric.diveq(x,x.length);
	    numeric.diveq(y,y.length);
	}
	numeric.convpow2 = function convpow2(ax,ay,bx,by) {
	    numeric.fftpow2(ax,ay);
	    numeric.fftpow2(bx,by);
	    var i,n = ax.length,axi,bxi,ayi,byi;
	    for(i=n-1;i!==-1;--i) {
	        axi = ax[i]; ayi = ay[i]; bxi = bx[i]; byi = by[i];
	        ax[i] = axi*bxi-ayi*byi;
	        ay[i] = axi*byi+ayi*bxi;
	    }
	    numeric.ifftpow2(ax,ay);
	}
	numeric.T.prototype.fft = function fft() {
	    var x = this.x, y = this.y;
	    var n = x.length, log = Math.log, log2 = log(2),
	        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
	    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
	    var k, c = (-3.141592653589793238462643383279502884197169399375105820/n),t;
	    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
	    for(k=0;k<n;k++) a[k] = x[k];
	    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
	    cx[0] = 1;
	    for(k=1;k<=m/2;k++) {
	        t = c*k*k;
	        cx[k] = cos(t);
	        cy[k] = sin(t);
	        cx[m-k] = cos(t);
	        cy[m-k] = sin(t)
	    }
	    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
	    X = X.mul(Y);
	    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
	    X = X.mul(Y);
	    X.x.length = n;
	    X.y.length = n;
	    return X;
	}
	numeric.T.prototype.ifft = function ifft() {
	    var x = this.x, y = this.y;
	    var n = x.length, log = Math.log, log2 = log(2),
	        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
	    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
	    var k, c = (3.141592653589793238462643383279502884197169399375105820/n),t;
	    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
	    for(k=0;k<n;k++) a[k] = x[k];
	    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
	    cx[0] = 1;
	    for(k=1;k<=m/2;k++) {
	        t = c*k*k;
	        cx[k] = cos(t);
	        cy[k] = sin(t);
	        cx[m-k] = cos(t);
	        cy[m-k] = sin(t)
	    }
	    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
	    X = X.mul(Y);
	    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
	    X = X.mul(Y);
	    X.x.length = n;
	    X.y.length = n;
	    return X.div(n);
	}
	
	//9. Unconstrained optimization
	numeric.gradient = function gradient(f,x) {
	    var n = x.length;
	    var f0 = f(x);
	    if(isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');
	    var max = Math.max;
	    var i,x0 = numeric.clone(x),f1,f2, J = Array(n);
	    var div = numeric.div, sub = numeric.sub,errest,roundoff,max = Math.max,eps = 1e-3,abs = Math.abs, min = Math.min;
	    var t0,t1,t2,it=0,d1,d2,N;
	    for(i=0;i<n;i++) {
	        var h = max(1e-6*f0,1e-8);
	        while(1) {
	            ++it;
	            if(it>20) { throw new Error("Numerical gradient fails"); }
	            x0[i] = x[i]+h;
	            f1 = f(x0);
	            x0[i] = x[i]-h;
	            f2 = f(x0);
	            x0[i] = x[i];
	            if(isNaN(f1) || isNaN(f2)) { h/=16; continue; }
	            J[i] = (f1-f2)/(2*h);
	            t0 = x[i]-h;
	            t1 = x[i];
	            t2 = x[i]+h;
	            d1 = (f1-f0)/h;
	            d2 = (f0-f2)/h;
	            N = max(abs(J[i]),abs(f0),abs(f1),abs(f2),abs(t0),abs(t1),abs(t2),1e-8);
	            errest = min(max(abs(d1-J[i]),abs(d2-J[i]),abs(d1-d2))/N,h/N);
	            if(errest>eps) { h/=16; }
	            else break;
	            }
	    }
	    return J;
	}
	
	numeric.uncmin = function uncmin(f,x0,tol,gradient,maxit,callback,options) {
	    var grad = numeric.gradient;
	    if(typeof options === "undefined") { options = {}; }
	    if(typeof tol === "undefined") { tol = 1e-8; }
	    if(typeof gradient === "undefined") { gradient = function(x) { return grad(f,x); }; }
	    if(typeof maxit === "undefined") maxit = 1000;
	    x0 = numeric.clone(x0);
	    var n = x0.length;
	    var f0 = f(x0),f1,df0;
	    if(isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
	    var max = Math.max, norm2 = numeric.norm2;
	    tol = max(tol,numeric.epsilon);
	    var step,g0,g1,H1 = options.Hinv || numeric.identity(n);
	    var dot = numeric.dot, inv = numeric.inv, sub = numeric.sub, add = numeric.add, ten = numeric.tensor, div = numeric.div, mul = numeric.mul;
	    var all = numeric.all, isfinite = numeric.isFinite, neg = numeric.neg;
	    var it=0,i,s,x1,y,Hy,Hs,ys,i0,t,nstep,t1,t2;
	    var msg = "";
	    g0 = gradient(x0);
	    while(it<maxit) {
	        if(typeof callback === "function") { if(callback(it,x0,f0,g0,H1)) { msg = "Callback returned true"; break; } }
	        if(!all(isfinite(g0))) { msg = "Gradient has Infinity or NaN"; break; }
	        step = neg(dot(H1,g0));
	        if(!all(isfinite(step))) { msg = "Search direction has Infinity or NaN"; break; }
	        nstep = norm2(step);
	        if(nstep < tol) { msg="Newton step smaller than tol"; break; }
	        t = 1;
	        df0 = dot(g0,step);
	        // line search
	        x1 = x0;
	        while(it < maxit) {
	            if(t*nstep < tol) { break; }
	            s = mul(step,t);
	            x1 = add(x0,s);
	            f1 = f(x1);
	            if(f1-f0 >= 0.1*t*df0 || isNaN(f1)) {
	                t *= 0.5;
	                ++it;
	                continue;
	            }
	            break;
	        }
	        if(t*nstep < tol) { msg = "Line search step size smaller than tol"; break; }
	        if(it === maxit) { msg = "maxit reached during line search"; break; }
	        g1 = gradient(x1);
	        y = sub(g1,g0);
	        ys = dot(y,s);
	        Hy = dot(H1,y);
	        H1 = sub(add(H1,
	                mul(
	                        (ys+dot(y,Hy))/(ys*ys),
	                        ten(s,s)    )),
	                div(add(ten(Hy,s),ten(s,Hy)),ys));
	        x0 = x1;
	        f0 = f1;
	        g0 = g1;
	        ++it;
	    }
	    return {solution: x0, f: f0, gradient: g0, invHessian: H1, iterations:it, message: msg};
	}
	
	// 10. Ode solver (Dormand-Prince)
	numeric.Dopri = function Dopri(x,y,f,ymid,iterations,msg,events) {
	    this.x = x;
	    this.y = y;
	    this.f = f;
	    this.ymid = ymid;
	    this.iterations = iterations;
	    this.events = events;
	    this.message = msg;
	}
	numeric.Dopri.prototype._at = function _at(xi,j) {
	    function sqr(x) { return x*x; }
	    var sol = this;
	    var xs = sol.x;
	    var ys = sol.y;
	    var k1 = sol.f;
	    var ymid = sol.ymid;
	    var n = xs.length;
	    var x0,x1,xh,y0,y1,yh,xi;
	    var floor = Math.floor,h;
	    var c = 0.5;
	    var add = numeric.add, mul = numeric.mul,sub = numeric.sub, p,q,w;
	    x0 = xs[j];
	    x1 = xs[j+1];
	    y0 = ys[j];
	    y1 = ys[j+1];
	    h  = x1-x0;
	    xh = x0+c*h;
	    yh = ymid[j];
	    p = sub(k1[j  ],mul(y0,1/(x0-xh)+2/(x0-x1)));
	    q = sub(k1[j+1],mul(y1,1/(x1-xh)+2/(x1-x0)));
	    w = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),
	         sqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),
	         sqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),
	         (xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0-x1) / (x0 - xh),
	         (xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0-x1) / (x1 - xh)];
	    return add(add(add(add(mul(y0,w[0]),
	                           mul(yh,w[1])),
	                           mul(y1,w[2])),
	                           mul( p,w[3])),
	                           mul( q,w[4]));
	}
	numeric.Dopri.prototype.at = function at(x) {
	    var i,j,k,floor = Math.floor;
	    if(typeof x !== "number") {
	        var n = x.length, ret = Array(n);
	        for(i=n-1;i!==-1;--i) {
	            ret[i] = this.at(x[i]);
	        }
	        return ret;
	    }
	    var x0 = this.x;
	    i = 0; j = x0.length-1;
	    while(j-i>1) {
	        k = floor(0.5*(i+j));
	        if(x0[k] <= x) i = k;
	        else j = k;
	    }
	    return this._at(x,i);
	}
	
	numeric.dopri = function dopri(x0,x1,y0,f,tol,maxit,event) {
	    if(typeof tol === "undefined") { tol = 1e-6; }
	    if(typeof maxit === "undefined") { maxit = 1000; }
	    var xs = [x0], ys = [y0], k1 = [f(x0,y0)], k2,k3,k4,k5,k6,k7, ymid = [];
	    var A2 = 1/5;
	    var A3 = [3/40,9/40];
	    var A4 = [44/45,-56/15,32/9];
	    var A5 = [19372/6561,-25360/2187,64448/6561,-212/729];
	    var A6 = [9017/3168,-355/33,46732/5247,49/176,-5103/18656];
	    var b = [35/384,0,500/1113,125/192,-2187/6784,11/84];
	    var bm = [0.5*6025192743/30085553152,
	              0,
	              0.5*51252292925/65400821598,
	              0.5*-2691868925/45128329728,
	              0.5*187940372067/1594534317056,
	              0.5*-1776094331/19743644256,
	              0.5*11237099/235043384];
	    var c = [1/5,3/10,4/5,8/9,1,1];
	    var e = [-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40];
	    var i = 0,er,j;
	    var h = (x1-x0)/10;
	    var it = 0;
	    var add = numeric.add, mul = numeric.mul, y1,erinf;
	    var max = Math.max, min = Math.min, abs = Math.abs, norminf = numeric.norminf,pow = Math.pow;
	    var any = numeric.any, lt = numeric.lt, and = numeric.and, sub = numeric.sub;
	    var e0, e1, ev;
	    var ret = new numeric.Dopri(xs,ys,k1,ymid,-1,"");
	    if(typeof event === "function") e0 = event(x0,y0);
	    while(x0<x1 && it<maxit) {
	        ++it;
	        if(x0+h>x1) h = x1-x0;
	        k2 = f(x0+c[0]*h,                add(y0,mul(   A2*h,k1[i])));
	        k3 = f(x0+c[1]*h,            add(add(y0,mul(A3[0]*h,k1[i])),mul(A3[1]*h,k2)));
	        k4 = f(x0+c[2]*h,        add(add(add(y0,mul(A4[0]*h,k1[i])),mul(A4[1]*h,k2)),mul(A4[2]*h,k3)));
	        k5 = f(x0+c[3]*h,    add(add(add(add(y0,mul(A5[0]*h,k1[i])),mul(A5[1]*h,k2)),mul(A5[2]*h,k3)),mul(A5[3]*h,k4)));
	        k6 = f(x0+c[4]*h,add(add(add(add(add(y0,mul(A6[0]*h,k1[i])),mul(A6[1]*h,k2)),mul(A6[2]*h,k3)),mul(A6[3]*h,k4)),mul(A6[4]*h,k5)));
	        y1 = add(add(add(add(add(y0,mul(k1[i],h*b[0])),mul(k3,h*b[2])),mul(k4,h*b[3])),mul(k5,h*b[4])),mul(k6,h*b[5]));
	        k7 = f(x0+h,y1);
	        er = add(add(add(add(add(mul(k1[i],h*e[0]),mul(k3,h*e[2])),mul(k4,h*e[3])),mul(k5,h*e[4])),mul(k6,h*e[5])),mul(k7,h*e[6]));
	        if(typeof er === "number") erinf = abs(er);
	        else erinf = norminf(er);
	        if(erinf > tol) { // reject
	            h = 0.2*h*pow(tol/erinf,0.25);
	            if(x0+h === x0) {
	                ret.msg = "Step size became too small";
	                break;
	            }
	            continue;
	        }
	        ymid[i] = add(add(add(add(add(add(y0,
	                mul(k1[i],h*bm[0])),
	                mul(k3   ,h*bm[2])),
	                mul(k4   ,h*bm[3])),
	                mul(k5   ,h*bm[4])),
	                mul(k6   ,h*bm[5])),
	                mul(k7   ,h*bm[6]));
	        ++i;
	        xs[i] = x0+h;
	        ys[i] = y1;
	        k1[i] = k7;
	        if(typeof event === "function") {
	            var yi,xl = x0,xr = x0+0.5*h,xi;
	            e1 = event(xr,ymid[i-1]);
	            ev = and(lt(e0,0),lt(0,e1));
	            if(!any(ev)) { xl = xr; xr = x0+h; e0 = e1; e1 = event(xr,y1); ev = and(lt(e0,0),lt(0,e1)); }
	            if(any(ev)) {
	                var xc, yc, en,ei;
	                var side=0, sl = 1.0, sr = 1.0;
	                while(1) {
	                    if(typeof e0 === "number") xi = (sr*e1*xl-sl*e0*xr)/(sr*e1-sl*e0);
	                    else {
	                        xi = xr;
	                        for(j=e0.length-1;j!==-1;--j) {
	                            if(e0[j]<0 && e1[j]>0) xi = min(xi,(sr*e1[j]*xl-sl*e0[j]*xr)/(sr*e1[j]-sl*e0[j]));
	                        }
	                    }
	                    if(xi <= xl || xi >= xr) break;
	                    yi = ret._at(xi, i-1);
	                    ei = event(xi,yi);
	                    en = and(lt(e0,0),lt(0,ei));
	                    if(any(en)) {
	                        xr = xi;
	                        e1 = ei;
	                        ev = en;
	                        sr = 1.0;
	                        if(side === -1) sl *= 0.5;
	                        else sl = 1.0;
	                        side = -1;
	                    } else {
	                        xl = xi;
	                        e0 = ei;
	                        sl = 1.0;
	                        if(side === 1) sr *= 0.5;
	                        else sr = 1.0;
	                        side = 1;
	                    }
	                }
	                y1 = ret._at(0.5*(x0+xi),i-1);
	                ret.f[i] = f(xi,yi);
	                ret.x[i] = xi;
	                ret.y[i] = yi;
	                ret.ymid[i-1] = y1;
	                ret.events = ev;
	                ret.iterations = it;
	                return ret;
	            }
	        }
	        x0 += h;
	        y0 = y1;
	        e0 = e1;
	        h = min(0.8*h*pow(tol/erinf,0.25),4*h);
	    }
	    ret.iterations = it;
	    return ret;
	}
	
	// 11. Ax = b
	numeric.LU = function(A, fast) {
	  fast = fast || false;
	
	  var abs = Math.abs;
	  var i, j, k, absAjk, Akk, Ak, Pk, Ai;
	  var max;
	  var n = A.length, n1 = n-1;
	  var P = new Array(n);
	  if(!fast) A = numeric.clone(A);
	
	  for (k = 0; k < n; ++k) {
	    Pk = k;
	    Ak = A[k];
	    max = abs(Ak[k]);
	    for (j = k + 1; j < n; ++j) {
	      absAjk = abs(A[j][k]);
	      if (max < absAjk) {
	        max = absAjk;
	        Pk = j;
	      }
	    }
	    P[k] = Pk;
	
	    if (Pk != k) {
	      A[k] = A[Pk];
	      A[Pk] = Ak;
	      Ak = A[k];
	    }
	
	    Akk = Ak[k];
	
	    for (i = k + 1; i < n; ++i) {
	      A[i][k] /= Akk;
	    }
	
	    for (i = k + 1; i < n; ++i) {
	      Ai = A[i];
	      for (j = k + 1; j < n1; ++j) {
	        Ai[j] -= Ai[k] * Ak[j];
	        ++j;
	        Ai[j] -= Ai[k] * Ak[j];
	      }
	      if(j===n1) Ai[j] -= Ai[k] * Ak[j];
	    }
	  }
	
	  return {
	    LU: A,
	    P:  P
	  };
	}
	
	numeric.LUsolve = function LUsolve(LUP, b) {
	  var i, j;
	  var LU = LUP.LU;
	  var n   = LU.length;
	  var x = numeric.clone(b);
	  var P   = LUP.P;
	  var Pi, LUi, LUii, tmp;
	
	  for (i=n-1;i!==-1;--i) x[i] = b[i];
	  for (i = 0; i < n; ++i) {
	    Pi = P[i];
	    if (P[i] !== i) {
	      tmp = x[i];
	      x[i] = x[Pi];
	      x[Pi] = tmp;
	    }
	
	    LUi = LU[i];
	    for (j = 0; j < i; ++j) {
	      x[i] -= x[j] * LUi[j];
	    }
	  }
	
	  for (i = n - 1; i >= 0; --i) {
	    LUi = LU[i];
	    for (j = i + 1; j < n; ++j) {
	      x[i] -= x[j] * LUi[j];
	    }
	
	    x[i] /= LUi[i];
	  }
	
	  return x;
	}
	
	numeric.solve = function solve(A,b,fast) { return numeric.LUsolve(numeric.LU(A,fast), b); }
	
	// 12. Linear programming
	numeric.echelonize = function echelonize(A) {
	    var s = numeric.dim(A), m = s[0], n = s[1];
	    var I = numeric.identity(m);
	    var P = Array(m);
	    var i,j,k,l,Ai,Ii,Z,a;
	    var abs = Math.abs;
	    var diveq = numeric.diveq;
	    A = numeric.clone(A);
	    for(i=0;i<m;++i) {
	        k = 0;
	        Ai = A[i];
	        Ii = I[i];
	        for(j=1;j<n;++j) if(abs(Ai[k])<abs(Ai[j])) k=j;
	        P[i] = k;
	        diveq(Ii,Ai[k]);
	        diveq(Ai,Ai[k]);
	        for(j=0;j<m;++j) if(j!==i) {
	            Z = A[j]; a = Z[k];
	            for(l=n-1;l!==-1;--l) Z[l] -= Ai[l]*a;
	            Z = I[j];
	            for(l=m-1;l!==-1;--l) Z[l] -= Ii[l]*a;
	        }
	    }
	    return {I:I, A:A, P:P};
	}
	
	numeric.__solveLP = function __solveLP(c,A,b,tol,maxit,x,flag) {
	    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
	    var m = c.length, n = b.length,y;
	    var unbounded = false, cb,i0=0;
	    var alpha = 1.0;
	    var f0,df0,AT = numeric.transpose(A), svd = numeric.svd,transpose = numeric.transpose,leq = numeric.leq, sqrt = Math.sqrt, abs = Math.abs;
	    var muleq = numeric.muleq;
	    var norm = numeric.norminf, any = numeric.any,min = Math.min;
	    var all = numeric.all, gt = numeric.gt;
	    var p = Array(m), A0 = Array(n),e=numeric.rep([n],1), H;
	    var solve = numeric.solve, z = sub(b,dot(A,x)),count;
	    var dotcc = dot(c,c);
	    var g;
	    for(count=i0;count<maxit;++count) {
	        var i,j,d;
	        for(i=n-1;i!==-1;--i) A0[i] = div(A[i],z[i]);
	        var A1 = transpose(A0);
	        for(i=m-1;i!==-1;--i) p[i] = (/*x[i]+*/sum(A1[i]));
	        alpha = 0.25*abs(dotcc/dot(c,p));
	        var a1 = 100*sqrt(dotcc/dot(p,p));
	        if(!isFinite(alpha) || alpha>a1) alpha = a1;
	        g = add(c,mul(alpha,p));
	        H = dot(A1,A0);
	        for(i=m-1;i!==-1;--i) H[i][i] += 1;
	        d = solve(H,div(g,alpha),true);
	        var t0 = div(z,dot(A,d));
	        var t = 1.0;
	        for(i=n-1;i!==-1;--i) if(t0[i]<0) t = min(t,-0.999*t0[i]);
	        y = sub(x,mul(d,t));
	        z = sub(b,dot(A,y));
	        if(!all(gt(z,0))) return { solution: x, message: "", iterations: count };
	        x = y;
	        if(alpha<tol) return { solution: y, message: "", iterations: count };
	        if(flag) {
	            var s = dot(c,g), Ag = dot(A,g);
	            unbounded = true;
	            for(i=n-1;i!==-1;--i) if(s*Ag[i]<0) { unbounded = false; break; }
	        } else {
	            if(x[m-1]>=0) unbounded = false;
	            else unbounded = true;
	        }
	        if(unbounded) return { solution: y, message: "Unbounded", iterations: count };
	    }
	    return { solution: x, message: "maximum iteration count exceeded", iterations:count };
	}
	
	numeric._solveLP = function _solveLP(c,A,b,tol,maxit) {
	    var m = c.length, n = b.length,y;
	    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
	    var c0 = numeric.rep([m],0).concat([1]);
	    var J = numeric.rep([n,1],-1);
	    var A0 = numeric.blockMatrix([[A                   ,   J  ]]);
	    var b0 = b;
	    var y = numeric.rep([m],0).concat(Math.max(0,numeric.sup(numeric.neg(b)))+1);
	    var x0 = numeric.__solveLP(c0,A0,b0,tol,maxit,y,false);
	    var x = numeric.clone(x0.solution);
	    x.length = m;
	    var foo = numeric.inf(sub(b,dot(A,x)));
	    if(foo<0) { return { solution: NaN, message: "Infeasible", iterations: x0.iterations }; }
	    var ret = numeric.__solveLP(c, A, b, tol, maxit-x0.iterations, x, true);
	    ret.iterations += x0.iterations;
	    return ret;
	};
	
	numeric.solveLP = function solveLP(c,A,b,Aeq,beq,tol,maxit) {
	    if(typeof maxit === "undefined") maxit = 1000;
	    if(typeof tol === "undefined") tol = numeric.epsilon;
	    if(typeof Aeq === "undefined") return numeric._solveLP(c,A,b,tol,maxit);
	    var m = Aeq.length, n = Aeq[0].length, o = A.length;
	    var B = numeric.echelonize(Aeq);
	    var flags = numeric.rep([n],0);
	    var P = B.P;
	    var Q = [];
	    var i;
	    for(i=P.length-1;i!==-1;--i) flags[P[i]] = 1;
	    for(i=n-1;i!==-1;--i) if(flags[i]===0) Q.push(i);
	    var g = numeric.getRange;
	    var I = numeric.linspace(0,m-1), J = numeric.linspace(0,o-1);
	    var Aeq2 = g(Aeq,I,Q), A1 = g(A,J,P), A2 = g(A,J,Q), dot = numeric.dot, sub = numeric.sub;
	    var A3 = dot(A1,B.I);
	    var A4 = sub(A2,dot(A3,Aeq2)), b4 = sub(b,dot(A3,beq));
	    var c1 = Array(P.length), c2 = Array(Q.length);
	    for(i=P.length-1;i!==-1;--i) c1[i] = c[P[i]];
	    for(i=Q.length-1;i!==-1;--i) c2[i] = c[Q[i]];
	    var c4 = sub(c2,dot(c1,dot(B.I,Aeq2)));
	    var S = numeric._solveLP(c4,A4,b4,tol,maxit);
	    var x2 = S.solution;
	    if(x2!==x2) return S;
	    var x1 = dot(B.I,sub(beq,dot(Aeq2,x2)));
	    var x = Array(c.length);
	    for(i=P.length-1;i!==-1;--i) x[P[i]] = x1[i];
	    for(i=Q.length-1;i!==-1;--i) x[Q[i]] = x2[i];
	    return { solution: x, message:S.message, iterations: S.iterations };
	}
	
	numeric.MPStoLP = function MPStoLP(MPS) {
	    if(MPS instanceof String) { MPS.split('\n'); }
	    var state = 0;
	    var states = ['Initial state','NAME','ROWS','COLUMNS','RHS','BOUNDS','ENDATA'];
	    var n = MPS.length;
	    var i,j,z,N=0,rows = {}, sign = [], rl = 0, vars = {}, nv = 0;
	    var name;
	    var c = [], A = [], b = [];
	    function err(e) { throw new Error('MPStoLP: '+e+'\nLine '+i+': '+MPS[i]+'\nCurrent state: '+states[state]+'\n'); }
	    for(i=0;i<n;++i) {
	        z = MPS[i];
	        var w0 = z.match(/\S*/g);
	        var w = [];
	        for(j=0;j<w0.length;++j) if(w0[j]!=="") w.push(w0[j]);
	        if(w.length === 0) continue;
	        for(j=0;j<states.length;++j) if(z.substr(0,states[j].length) === states[j]) break;
	        if(j<states.length) {
	            state = j;
	            if(j===1) { name = w[1]; }
	            if(j===6) return { name:name, c:c, A:numeric.transpose(A), b:b, rows:rows, vars:vars };
	            continue;
	        }
	        switch(state) {
	        case 0: case 1: err('Unexpected line');
	        case 2: 
	            switch(w[0]) {
	            case 'N': if(N===0) N = w[1]; else err('Two or more N rows'); break;
	            case 'L': rows[w[1]] = rl; sign[rl] = 1; b[rl] = 0; ++rl; break;
	            case 'G': rows[w[1]] = rl; sign[rl] = -1;b[rl] = 0; ++rl; break;
	            case 'E': rows[w[1]] = rl; sign[rl] = 0;b[rl] = 0; ++rl; break;
	            default: err('Parse error '+numeric.prettyPrint(w));
	            }
	            break;
	        case 3:
	            if(!vars.hasOwnProperty(w[0])) { vars[w[0]] = nv; c[nv] = 0; A[nv] = numeric.rep([rl],0); ++nv; }
	            var p = vars[w[0]];
	            for(j=1;j<w.length;j+=2) {
	                if(w[j] === N) { c[p] = parseFloat(w[j+1]); continue; }
	                var q = rows[w[j]];
	                A[p][q] = (sign[q]<0?-1:1)*parseFloat(w[j+1]);
	            }
	            break;
	        case 4:
	            for(j=1;j<w.length;j+=2) b[rows[w[j]]] = (sign[rows[w[j]]]<0?-1:1)*parseFloat(w[j+1]);
	            break;
	        case 5: /*FIXME*/ break;
	        case 6: err('Internal error');
	        }
	    }
	    err('Reached end of file without ENDATA');
	}
	// seedrandom.js version 2.0.
	// Author: David Bau 4/2/2011
	//
	// Defines a method Math.seedrandom() that, when called, substitutes
	// an explicitly seeded RC4-based algorithm for Math.random().  Also
	// supports automatic seeding from local or network sources of entropy.
	//
	// Usage:
	//
	//   <script src=http://davidbau.com/encode/seedrandom-min.js></script>
	//
	//   Math.seedrandom('yipee'); Sets Math.random to a function that is
	//                             initialized using the given explicit seed.
	//
	//   Math.seedrandom();        Sets Math.random to a function that is
	//                             seeded using the current time, dom state,
	//                             and other accumulated local entropy.
	//                             The generated seed string is returned.
	//
	//   Math.seedrandom('yowza', true);
	//                             Seeds using the given explicit seed mixed
	//                             together with accumulated entropy.
	//
	//   <script src="http://bit.ly/srandom-512"></script>
	//                             Seeds using physical random bits downloaded
	//                             from random.org.
	//
	//   <script src="https://jsonlib.appspot.com/urandom?callback=Math.seedrandom">
	//   </script>                 Seeds using urandom bits from call.jsonlib.com,
	//                             which is faster than random.org.
	//
	// Examples:
	//
	//   Math.seedrandom("hello");            // Use "hello" as the seed.
	//   document.write(Math.random());       // Always 0.5463663768140734
	//   document.write(Math.random());       // Always 0.43973793770592234
	//   var rng1 = Math.random;              // Remember the current prng.
	//
	//   var autoseed = Math.seedrandom();    // New prng with an automatic seed.
	//   document.write(Math.random());       // Pretty much unpredictable.
	//
	//   Math.random = rng1;                  // Continue "hello" prng sequence.
	//   document.write(Math.random());       // Always 0.554769432473455
	//
	//   Math.seedrandom(autoseed);           // Restart at the previous seed.
	//   document.write(Math.random());       // Repeat the 'unpredictable' value.
	//
	// Notes:
	//
	// Each time seedrandom('arg') is called, entropy from the passed seed
	// is accumulated in a pool to help generate future seeds for the
	// zero-argument form of Math.seedrandom, so entropy can be injected over
	// time by calling seedrandom with explicit data repeatedly.
	//
	// On speed - This javascript implementation of Math.random() is about
	// 3-10x slower than the built-in Math.random() because it is not native
	// code, but this is typically fast enough anyway.  Seeding is more expensive,
	// especially if you use auto-seeding.  Some details (timings on Chrome 4):
	//
	// Our Math.random()            - avg less than 0.002 milliseconds per call
	// seedrandom('explicit')       - avg less than 0.5 milliseconds per call
	// seedrandom('explicit', true) - avg less than 2 milliseconds per call
	// seedrandom()                 - avg about 38 milliseconds per call
	//
	// LICENSE (BSD):
	//
	// Copyright 2010 David Bau, all rights reserved.
	//
	// Redistribution and use in source and binary forms, with or without
	// modification, are permitted provided that the following conditions are met:
	// 
	//   1. Redistributions of source code must retain the above copyright
	//      notice, this list of conditions and the following disclaimer.
	//
	//   2. Redistributions in binary form must reproduce the above copyright
	//      notice, this list of conditions and the following disclaimer in the
	//      documentation and/or other materials provided with the distribution.
	// 
	//   3. Neither the name of this module nor the names of its contributors may
	//      be used to endorse or promote products derived from this software
	//      without specific prior written permission.
	// 
	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	//
	/**
	 * All code is in an anonymous closure to keep the global namespace clean.
	 *
	 * @param {number=} overflow 
	 * @param {number=} startdenom
	 */
	
	// Patched by Seb so that seedrandom.js does not pollute the Math object.
	// My tests suggest that doing Math.trouble = 1 makes Math lookups about 5%
	// slower.
	numeric.seedrandom = { pow:Math.pow, random:Math.random };
	
	(function (pool, math, width, chunks, significance, overflow, startdenom) {
	
	
	//
	// seedrandom()
	// This is the seedrandom function described above.
	//
	math['seedrandom'] = function seedrandom(seed, use_entropy) {
	  var key = [];
	  var arc4;
	
	  // Flatten the seed string or build one from local entropy if needed.
	  seed = mixkey(flatten(
	    use_entropy ? [seed, pool] :
	    arguments.length ? seed :
	    [new Date().getTime(), pool, window], 3), key);
	
	  // Use the seed to initialize an ARC4 generator.
	  arc4 = new ARC4(key);
	
	  // Mix the randomness into accumulated entropy.
	  mixkey(arc4.S, pool);
	
	  // Override Math.random
	
	  // This function returns a random double in [0, 1) that contains
	  // randomness in every bit of the mantissa of the IEEE 754 value.
	
	  math['random'] = function random() {  // Closure to return a random double:
	    var n = arc4.g(chunks);             // Start with a numerator n < 2 ^ 48
	    var d = startdenom;                 //   and denominator d = 2 ^ 48.
	    var x = 0;                          //   and no 'extra last byte'.
	    while (n < significance) {          // Fill up all significant digits by
	      n = (n + x) * width;              //   shifting numerator and
	      d *= width;                       //   denominator and generating a
	      x = arc4.g(1);                    //   new least-significant-byte.
	    }
	    while (n >= overflow) {             // To avoid rounding up, before adding
	      n /= 2;                           //   last byte, shift everything
	      d /= 2;                           //   right using integer math until
	      x >>>= 1;                         //   we have exactly the desired bits.
	    }
	    return (n + x) / d;                 // Form the number within [0, 1).
	  };
	
	  // Return the seed that was used
	  return seed;
	};
	
	//
	// ARC4
	//
	// An ARC4 implementation.  The constructor takes a key in the form of
	// an array of at most (width) integers that should be 0 <= x < (width).
	//
	// The g(count) method returns a pseudorandom integer that concatenates
	// the next (count) outputs from ARC4.  Its return value is a number x
	// that is in the range 0 <= x < (width ^ count).
	//
	/** @constructor */
	function ARC4(key) {
	  var t, u, me = this, keylen = key.length;
	  var i = 0, j = me.i = me.j = me.m = 0;
	  me.S = [];
	  me.c = [];
	
	  // The empty key [] is treated as [0].
	  if (!keylen) { key = [keylen++]; }
	
	  // Set up S using the standard key scheduling algorithm.
	  while (i < width) { me.S[i] = i++; }
	  for (i = 0; i < width; i++) {
	    t = me.S[i];
	    j = lowbits(j + t + key[i % keylen]);
	    u = me.S[j];
	    me.S[i] = u;
	    me.S[j] = t;
	  }
	
	  // The "g" method returns the next (count) outputs as one number.
	  me.g = function getnext(count) {
	    var s = me.S;
	    var i = lowbits(me.i + 1); var t = s[i];
	    var j = lowbits(me.j + t); var u = s[j];
	    s[i] = u;
	    s[j] = t;
	    var r = s[lowbits(t + u)];
	    while (--count) {
	      i = lowbits(i + 1); t = s[i];
	      j = lowbits(j + t); u = s[j];
	      s[i] = u;
	      s[j] = t;
	      r = r * width + s[lowbits(t + u)];
	    }
	    me.i = i;
	    me.j = j;
	    return r;
	  };
	  // For robust unpredictability discard an initial batch of values.
	  // See http://www.rsa.com/rsalabs/node.asp?id=2009
	  me.g(width);
	}
	
	//
	// flatten()
	// Converts an object tree to nested arrays of strings.
	//
	/** @param {Object=} result 
	  * @param {string=} prop
	  * @param {string=} typ */
	function flatten(obj, depth, result, prop, typ) {
	  result = [];
	  typ = typeof(obj);
	  if (depth && typ == 'object') {
	    for (prop in obj) {
	      if (prop.indexOf('S') < 5) {    // Avoid FF3 bug (local/sessionStorage)
	        try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
	      }
	    }
	  }
	  return (result.length ? result : obj + (typ != 'string' ? '\0' : ''));
	}
	
	//
	// mixkey()
	// Mixes a string seed into a key that is an array of integers, and
	// returns a shortened string seed that is equivalent to the result key.
	//
	/** @param {number=} smear 
	  * @param {number=} j */
	function mixkey(seed, key, smear, j) {
	  seed += '';                         // Ensure the seed is a string
	  smear = 0;
	  for (j = 0; j < seed.length; j++) {
	    key[lowbits(j)] =
	      lowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));
	  }
	  seed = '';
	  for (j in key) { seed += String.fromCharCode(key[j]); }
	  return seed;
	}
	
	//
	// lowbits()
	// A quick "n mod width" for width a power of 2.
	//
	function lowbits(n) { return n & (width - 1); }
	
	//
	// The following constants are related to IEEE 754 limits.
	//
	startdenom = math.pow(width, chunks);
	significance = math.pow(2, significance);
	overflow = significance * 2;
	
	//
	// When seedrandom.js is loaded, we immediately mix a few bits
	// from the built-in RNG into the entropy pool.  Because we do
	// not want to intefere with determinstic PRNG state later,
	// seedrandom will not call math.random on its own again after
	// initialization.
	//
	mixkey(math.random(), pool);
	
	// End anonymous scope, and pass initial values.
	}(
	  [],   // pool: entropy pool starts empty
	  numeric.seedrandom, // math: package containing random, pow, and seedrandom
	  256,  // width: each RC4 output is 0 <= x < 256
	  6,    // chunks: at least six RC4 outputs for each double
	  52    // significance: there are 52 significant digits in a double
	  ));
	/* This file is a slightly modified version of quadprog.js from Alberto Santini.
	 * It has been slightly modified by Sbastien Loisel to make sure that it handles
	 * 0-based Arrays instead of 1-based Arrays.
	 * License is in resources/LICENSE.quadprog */
	(function(exports) {
	
	function base0to1(A) {
	    if(typeof A !== "object") { return A; }
	    var ret = [], i,n=A.length;
	    for(i=0;i<n;i++) ret[i+1] = base0to1(A[i]);
	    return ret;
	}
	function base1to0(A) {
	    if(typeof A !== "object") { return A; }
	    var ret = [], i,n=A.length;
	    for(i=1;i<n;i++) ret[i-1] = base1to0(A[i]);
	    return ret;
	}
	
	function dpori(a, lda, n) {
	    var i, j, k, kp1, t;
	
	    for (k = 1; k <= n; k = k + 1) {
	        a[k][k] = 1 / a[k][k];
	        t = -a[k][k];
	        //~ dscal(k - 1, t, a[1][k], 1);
	        for (i = 1; i < k; i = i + 1) {
	            a[i][k] = t * a[i][k];
	        }
	
	        kp1 = k + 1;
	        if (n < kp1) {
	            break;
	        }
	        for (j = kp1; j <= n; j = j + 1) {
	            t = a[k][j];
	            a[k][j] = 0;
	            //~ daxpy(k, t, a[1][k], 1, a[1][j], 1);
	            for (i = 1; i <= k; i = i + 1) {
	                a[i][j] = a[i][j] + (t * a[i][k]);
	            }
	        }
	    }
	
	}
	
	function dposl(a, lda, n, b) {
	    var i, k, kb, t;
	
	    for (k = 1; k <= n; k = k + 1) {
	        //~ t = ddot(k - 1, a[1][k], 1, b[1], 1);
	        t = 0;
	        for (i = 1; i < k; i = i + 1) {
	            t = t + (a[i][k] * b[i]);
	        }
	
	        b[k] = (b[k] - t) / a[k][k];
	    }
	
	    for (kb = 1; kb <= n; kb = kb + 1) {
	        k = n + 1 - kb;
	        b[k] = b[k] / a[k][k];
	        t = -b[k];
	        //~ daxpy(k - 1, t, a[1][k], 1, b[1], 1);
	        for (i = 1; i < k; i = i + 1) {
	            b[i] = b[i] + (t * a[i][k]);
	        }
	    }
	}
	
	function dpofa(a, lda, n, info) {
	    var i, j, jm1, k, t, s;
	
	    for (j = 1; j <= n; j = j + 1) {
	        info[1] = j;
	        s = 0;
	        jm1 = j - 1;
	        if (jm1 < 1) {
	            s = a[j][j] - s;
	            if (s <= 0) {
	                break;
	            }
	            a[j][j] = Math.sqrt(s);
	        } else {
	            for (k = 1; k <= jm1; k = k + 1) {
	                //~ t = a[k][j] - ddot(k - 1, a[1][k], 1, a[1][j], 1);
	                t = a[k][j];
	                for (i = 1; i < k; i = i + 1) {
	                    t = t - (a[i][j] * a[i][k]);
	                }
	                t = t / a[k][k];
	                a[k][j] = t;
	                s = s + t * t;
	            }
	            s = a[j][j] - s;
	            if (s <= 0) {
	                break;
	            }
	            a[j][j] = Math.sqrt(s);
	        }
	        info[1] = 0;
	    }
	}
	
	function qpgen2(dmat, dvec, fddmat, n, sol, crval, amat,
	    bvec, fdamat, q, meq, iact, nact, iter, work, ierr) {
	
	    var i, j, l, l1, info, it1, iwzv, iwrv, iwrm, iwsv, iwuv, nvl, r, iwnbv,
	        temp, sum, t1, tt, gc, gs, nu,
	        t1inf, t2min,
	        vsmall, tmpa, tmpb,
	        go;
	
	    r = Math.min(n, q);
	    l = 2 * n + (r * (r + 5)) / 2 + 2 * q + 1;
	
	    vsmall = 1.0e-60;
	    do {
	        vsmall = vsmall + vsmall;
	        tmpa = 1 + 0.1 * vsmall;
	        tmpb = 1 + 0.2 * vsmall;
	    } while (tmpa <= 1 || tmpb <= 1);
	
	    for (i = 1; i <= n; i = i + 1) {
	        work[i] = dvec[i];
	    }
	    for (i = n + 1; i <= l; i = i + 1) {
	        work[i] = 0;
	    }
	    for (i = 1; i <= q; i = i + 1) {
	        iact[i] = 0;
	    }
	
	    info = [];
	
	    if (ierr[1] === 0) {
	        dpofa(dmat, fddmat, n, info);
	        if (info[1] !== 0) {
	            ierr[1] = 2;
	            return;
	        }
	        dposl(dmat, fddmat, n, dvec);
	        dpori(dmat, fddmat, n);
	    } else {
	        for (j = 1; j <= n; j = j + 1) {
	            sol[j] = 0;
	            for (i = 1; i <= j; i = i + 1) {
	                sol[j] = sol[j] + dmat[i][j] * dvec[i];
	            }
	        }
	        for (j = 1; j <= n; j = j + 1) {
	            dvec[j] = 0;
	            for (i = j; i <= n; i = i + 1) {
	                dvec[j] = dvec[j] + dmat[j][i] * sol[i];
	            }
	        }
	    }
	
	    crval[1] = 0;
	    for (j = 1; j <= n; j = j + 1) {
	        sol[j] = dvec[j];
	        crval[1] = crval[1] + work[j] * sol[j];
	        work[j] = 0;
	        for (i = j + 1; i <= n; i = i + 1) {
	            dmat[i][j] = 0;
	        }
	    }
	    crval[1] = -crval[1] / 2;
	    ierr[1] = 0;
	
	    iwzv = n;
	    iwrv = iwzv + n;
	    iwuv = iwrv + r;
	    iwrm = iwuv + r + 1;
	    iwsv = iwrm + (r * (r + 1)) / 2;
	    iwnbv = iwsv + q;
	
	    for (i = 1; i <= q; i = i + 1) {
	        sum = 0;
	        for (j = 1; j <= n; j = j + 1) {
	            sum = sum + amat[j][i] * amat[j][i];
	        }
	        work[iwnbv + i] = Math.sqrt(sum);
	    }
	    nact = 0;
	    iter[1] = 0;
	    iter[2] = 0;
	
	    function fn_goto_50() {
	        iter[1] = iter[1] + 1;
	
	        l = iwsv;
	        for (i = 1; i <= q; i = i + 1) {
	            l = l + 1;
	            sum = -bvec[i];
	            for (j = 1; j <= n; j = j + 1) {
	                sum = sum + amat[j][i] * sol[j];
	            }
	            if (Math.abs(sum) < vsmall) {
	                sum = 0;
	            }
	            if (i > meq) {
	                work[l] = sum;
	            } else {
	                work[l] = -Math.abs(sum);
	                if (sum > 0) {
	                    for (j = 1; j <= n; j = j + 1) {
	                        amat[j][i] = -amat[j][i];
	                    }
	                    bvec[i] = -bvec[i];
	                }
	            }
	        }
	
	        for (i = 1; i <= nact; i = i + 1) {
	            work[iwsv + iact[i]] = 0;
	        }
	
	        nvl = 0;
	        temp = 0;
	        for (i = 1; i <= q; i = i + 1) {
	            if (work[iwsv + i] < temp * work[iwnbv + i]) {
	                nvl = i;
	                temp = work[iwsv + i] / work[iwnbv + i];
	            }
	        }
	        if (nvl === 0) {
	            return 999;
	        }
	
	        return 0;
	    }
	
	    function fn_goto_55() {
	        for (i = 1; i <= n; i = i + 1) {
	            sum = 0;
	            for (j = 1; j <= n; j = j + 1) {
	                sum = sum + dmat[j][i] * amat[j][nvl];
	            }
	            work[i] = sum;
	        }
	
	        l1 = iwzv;
	        for (i = 1; i <= n; i = i + 1) {
	            work[l1 + i] = 0;
	        }
	        for (j = nact + 1; j <= n; j = j + 1) {
	            for (i = 1; i <= n; i = i + 1) {
	                work[l1 + i] = work[l1 + i] + dmat[i][j] * work[j];
	            }
	        }
	
	        t1inf = true;
	        for (i = nact; i >= 1; i = i - 1) {
	            sum = work[i];
	            l = iwrm + (i * (i + 3)) / 2;
	            l1 = l - i;
	            for (j = i + 1; j <= nact; j = j + 1) {
	                sum = sum - work[l] * work[iwrv + j];
	                l = l + j;
	            }
	            sum = sum / work[l1];
	            work[iwrv + i] = sum;
	            if (iact[i] < meq) {
	                // continue;
	                break;
	            }
	            if (sum < 0) {
	                // continue;
	                break;
	            }
	            t1inf = false;
	            it1 = i;
	        }
	
	        if (!t1inf) {
	            t1 = work[iwuv + it1] / work[iwrv + it1];
	            for (i = 1; i <= nact; i = i + 1) {
	                if (iact[i] < meq) {
	                    // continue;
	                    break;
	                }
	                if (work[iwrv + i] < 0) {
	                    // continue;
	                    break;
	                }
	                temp = work[iwuv + i] / work[iwrv + i];
	                if (temp < t1) {
	                    t1 = temp;
	                    it1 = i;
	                }
	            }
	        }
	
	        sum = 0;
	        for (i = iwzv + 1; i <= iwzv + n; i = i + 1) {
	            sum = sum + work[i] * work[i];
	        }
	        if (Math.abs(sum) <= vsmall) {
	            if (t1inf) {
	                ierr[1] = 1;
	                // GOTO 999
	                return 999;
	            } else {
	                for (i = 1; i <= nact; i = i + 1) {
	                    work[iwuv + i] = work[iwuv + i] - t1 * work[iwrv + i];
	                }
	                work[iwuv + nact + 1] = work[iwuv + nact + 1] + t1;
	                // GOTO 700
	                return 700;
	            }
	        } else {
	            sum = 0;
	            for (i = 1; i <= n; i = i + 1) {
	                sum = sum + work[iwzv + i] * amat[i][nvl];
	            }
	            tt = -work[iwsv + nvl] / sum;
	            t2min = true;
	            if (!t1inf) {
	                if (t1 < tt) {
	                    tt = t1;
	                    t2min = false;
	                }
	            }
	
	            for (i = 1; i <= n; i = i + 1) {
	                sol[i] = sol[i] + tt * work[iwzv + i];
	                if (Math.abs(sol[i]) < vsmall) {
	                    sol[i] = 0;
	                }
	            }
	
	            crval[1] = crval[1] + tt * sum * (tt / 2 + work[iwuv + nact + 1]);
	            for (i = 1; i <= nact; i = i + 1) {
	                work[iwuv + i] = work[iwuv + i] - tt * work[iwrv + i];
	            }
	            work[iwuv + nact + 1] = work[iwuv + nact + 1] + tt;
	
	            if (t2min) {
	                nact = nact + 1;
	                iact[nact] = nvl;
	
	                l = iwrm + ((nact - 1) * nact) / 2 + 1;
	                for (i = 1; i <= nact - 1; i = i + 1) {
	                    work[l] = work[i];
	                    l = l + 1;
	                }
	
	                if (nact === n) {
	                    work[l] = work[n];
	                } else {
	                    for (i = n; i >= nact + 1; i = i - 1) {
	                        if (work[i] === 0) {
	                            // continue;
	                            break;
	                        }
	                        gc = Math.max(Math.abs(work[i - 1]), Math.abs(work[i]));
	                        gs = Math.min(Math.abs(work[i - 1]), Math.abs(work[i]));
	                        if (work[i - 1] >= 0) {
	                            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
	                        } else {
	                            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
	                        }
	                        gc = work[i - 1] / temp;
	                        gs = work[i] / temp;
	
	                        if (gc === 1) {
	                            // continue;
	                            break;
	                        }
	                        if (gc === 0) {
	                            work[i - 1] = gs * temp;
	                            for (j = 1; j <= n; j = j + 1) {
	                                temp = dmat[j][i - 1];
	                                dmat[j][i - 1] = dmat[j][i];
	                                dmat[j][i] = temp;
	                            }
	                        } else {
	                            work[i - 1] = temp;
	                            nu = gs / (1 + gc);
	                            for (j = 1; j <= n; j = j + 1) {
	                                temp = gc * dmat[j][i - 1] + gs * dmat[j][i];
	                                dmat[j][i] = nu * (dmat[j][i - 1] + temp) - dmat[j][i];
	                                dmat[j][i - 1] = temp;
	
	                            }
	                        }
	                    }
	                    work[l] = work[nact];
	                }
	            } else {
	                sum = -bvec[nvl];
	                for (j = 1; j <= n; j = j + 1) {
	                    sum = sum + sol[j] * amat[j][nvl];
	                }
	                if (nvl > meq) {
	                    work[iwsv + nvl] = sum;
	                } else {
	                    work[iwsv + nvl] = -Math.abs(sum);
	                    if (sum > 0) {
	                        for (j = 1; j <= n; j = j + 1) {
	                            amat[j][nvl] = -amat[j][nvl];
	                        }
	                        bvec[nvl] = -bvec[nvl];
	                    }
	                }
	                // GOTO 700
	                return 700;
	            }
	        }
	
	        return 0;
	    }
	
	    function fn_goto_797() {
	        l = iwrm + (it1 * (it1 + 1)) / 2 + 1;
	        l1 = l + it1;
	        if (work[l1] === 0) {
	            // GOTO 798
	            return 798;
	        }
	        gc = Math.max(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
	        gs = Math.min(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
	        if (work[l1 - 1] >= 0) {
	            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
	        } else {
	            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
	        }
	        gc = work[l1 - 1] / temp;
	        gs = work[l1] / temp;
	
	        if (gc === 1) {
	            // GOTO 798
	            return 798;
	        }
	        if (gc === 0) {
	            for (i = it1 + 1; i <= nact; i = i + 1) {
	                temp = work[l1 - 1];
	                work[l1 - 1] = work[l1];
	                work[l1] = temp;
	                l1 = l1 + i;
	            }
	            for (i = 1; i <= n; i = i + 1) {
	                temp = dmat[i][it1];
	                dmat[i][it1] = dmat[i][it1 + 1];
	                dmat[i][it1 + 1] = temp;
	            }
	        } else {
	            nu = gs / (1 + gc);
	            for (i = it1 + 1; i <= nact; i = i + 1) {
	                temp = gc * work[l1 - 1] + gs * work[l1];
	                work[l1] = nu * (work[l1 - 1] + temp) - work[l1];
	                work[l1 - 1] = temp;
	                l1 = l1 + i;
	            }
	            for (i = 1; i <= n; i = i + 1) {
	                temp = gc * dmat[i][it1] + gs * dmat[i][it1 + 1];
	                dmat[i][it1 + 1] = nu * (dmat[i][it1] + temp) - dmat[i][it1 + 1];
	                dmat[i][it1] = temp;
	            }
	        }
	
	        return 0;
	    }
	
	    function fn_goto_798() {
	        l1 = l - it1;
	        for (i = 1; i <= it1; i = i + 1) {
	            work[l1] = work[l];
	            l = l + 1;
	            l1 = l1 + 1;
	        }
	
	        work[iwuv + it1] = work[iwuv + it1 + 1];
	        iact[it1] = iact[it1 + 1];
	        it1 = it1 + 1;
	        if (it1 < nact) {
	            // GOTO 797
	            return 797;
	        }
	
	        return 0;
	    }
	
	    function fn_goto_799() {
	        work[iwuv + nact] = work[iwuv + nact + 1];
	        work[iwuv + nact + 1] = 0;
	        iact[nact] = 0;
	        nact = nact - 1;
	        iter[2] = iter[2] + 1;
	
	        return 0;
	    }
	
	    go = 0;
	    while (true) {
	        go = fn_goto_50();
	        if (go === 999) {
	            return;
	        }
	        while (true) {
	            go = fn_goto_55();
	            if (go === 0) {
	                break;
	            }
	            if (go === 999) {
	                return;
	            }
	            if (go === 700) {
	                if (it1 === nact) {
	                    fn_goto_799();
	                } else {
	                    while (true) {
	                        fn_goto_797();
	                        go = fn_goto_798();
	                        if (go !== 797) {
	                            break;
	                        }
	                    }
	                    fn_goto_799();
	                }
	            }
	        }
	    }
	
	}
	
	function solveQP(Dmat, dvec, Amat, bvec, meq, factorized) {
	    Dmat = base0to1(Dmat);
	    dvec = base0to1(dvec);
	    Amat = base0to1(Amat);
	    var i, n, q,
	        nact, r,
	        crval = [], iact = [], sol = [], work = [], iter = [],
	        message;
	
	    meq = meq || 0;
	    factorized = factorized ? base0to1(factorized) : [undefined, 0];
	    bvec = bvec ? base0to1(bvec) : [];
	
	    // In Fortran the array index starts from 1
	    n = Dmat.length - 1;
	    q = Amat[1].length - 1;
	
	    if (!bvec) {
	        for (i = 1; i <= q; i = i + 1) {
	            bvec[i] = 0;
	        }
	    }
	    for (i = 1; i <= q; i = i + 1) {
	        iact[i] = 0;
	    }
	    nact = 0;
	    r = Math.min(n, q);
	    for (i = 1; i <= n; i = i + 1) {
	        sol[i] = 0;
	    }
	    crval[1] = 0;
	    for (i = 1; i <= (2 * n + (r * (r + 5)) / 2 + 2 * q + 1); i = i + 1) {
	        work[i] = 0;
	    }
	    for (i = 1; i <= 2; i = i + 1) {
	        iter[i] = 0;
	    }
	
	    qpgen2(Dmat, dvec, n, n, sol, crval, Amat,
	        bvec, n, q, meq, iact, nact, iter, work, factorized);
	
	    message = "";
	    if (factorized[1] === 1) {
	        message = "constraints are inconsistent, no solution!";
	    }
	    if (factorized[1] === 2) {
	        message = "matrix D in quadratic function is not positive definite!";
	    }
	
	    return {
	        solution: base1to0(sol),
	        value: base1to0(crval),
	        unconstrained_solution: base1to0(dvec),
	        iterations: base1to0(iter),
	        iact: base1to0(iact),
	        message: message
	    };
	}
	exports.solveQP = solveQP;
	}(numeric));
	/*
	Shanti Rao sent me this routine by private email. I had to modify it
	slightly to work on Arrays instead of using a Matrix object.
	It is apparently translated from http://stitchpanorama.sourceforge.net/Python/svd.py
	*/
	
	numeric.svd= function svd(A) {
	    var temp;
	//Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)
		var prec= numeric.epsilon; //Math.pow(2,-52) // assumes double prec
		var tolerance= 1.e-64/prec;
		var itmax= 50;
		var c=0;
		var i=0;
		var j=0;
		var k=0;
		var l=0;
		
		var u= numeric.clone(A);
		var m= u.length;
		
		var n= u[0].length;
		
		if (m < n) throw "Need more rows than columns"
		
		var e = new Array(n);
		var q = new Array(n);
		for (i=0; i<n; i++) e[i] = q[i] = 0.0;
		var v = numeric.rep([n,n],0);
	//	v.zero();
		
	 	function pythag(a,b)
	 	{
			a = Math.abs(a)
			b = Math.abs(b)
			if (a > b)
				return a*Math.sqrt(1.0+(b*b/a/a))
			else if (b == 0.0) 
				return a
			return b*Math.sqrt(1.0+(a*a/b/b))
		}
	
		//Householder's reduction to bidiagonal form
	
		var f= 0.0;
		var g= 0.0;
		var h= 0.0;
		var x= 0.0;
		var y= 0.0;
		var z= 0.0;
		var s= 0.0;
		
		for (i=0; i < n; i++)
		{	
			e[i]= g;
			s= 0.0;
			l= i+1;
			for (j=i; j < m; j++) 
				s += (u[j][i]*u[j][i]);
			if (s <= tolerance)
				g= 0.0;
			else
			{	
				f= u[i][i];
				g= Math.sqrt(s);
				if (f >= 0.0) g= -g;
				h= f*g-s
				u[i][i]=f-g;
				for (j=l; j < n; j++)
				{
					s= 0.0
					for (k=i; k < m; k++) 
						s += u[k][i]*u[k][j]
					f= s/h
					for (k=i; k < m; k++) 
						u[k][j]+=f*u[k][i]
				}
			}
			q[i]= g
			s= 0.0
			for (j=l; j < n; j++) 
				s= s + u[i][j]*u[i][j]
			if (s <= tolerance)
				g= 0.0
			else
			{	
				f= u[i][i+1]
				g= Math.sqrt(s)
				if (f >= 0.0) g= -g
				h= f*g - s
				u[i][i+1] = f-g;
				for (j=l; j < n; j++) e[j]= u[i][j]/h
				for (j=l; j < m; j++)
				{	
					s=0.0
					for (k=l; k < n; k++) 
						s += (u[j][k]*u[i][k])
					for (k=l; k < n; k++) 
						u[j][k]+=s*e[k]
				}	
			}
			y= Math.abs(q[i])+Math.abs(e[i])
			if (y>x) 
				x=y
		}
		
		// accumulation of right hand gtransformations
		for (i=n-1; i != -1; i+= -1)
		{	
			if (g != 0.0)
			{
			 	h= g*u[i][i+1]
				for (j=l; j < n; j++) 
					v[j][i]=u[i][j]/h
				for (j=l; j < n; j++)
				{	
					s=0.0
					for (k=l; k < n; k++) 
						s += u[i][k]*v[k][j]
					for (k=l; k < n; k++) 
						v[k][j]+=(s*v[k][i])
				}	
			}
			for (j=l; j < n; j++)
			{
				v[i][j] = 0;
				v[j][i] = 0;
			}
			v[i][i] = 1;
			g= e[i]
			l= i
		}
		
		// accumulation of left hand transformations
		for (i=n-1; i != -1; i+= -1)
		{	
			l= i+1
			g= q[i]
			for (j=l; j < n; j++) 
				u[i][j] = 0;
			if (g != 0.0)
			{
				h= u[i][i]*g
				for (j=l; j < n; j++)
				{
					s=0.0
					for (k=l; k < m; k++) s += u[k][i]*u[k][j];
					f= s/h
					for (k=i; k < m; k++) u[k][j]+=f*u[k][i];
				}
				for (j=i; j < m; j++) u[j][i] = u[j][i]/g;
			}
			else
				for (j=i; j < m; j++) u[j][i] = 0;
			u[i][i] += 1;
		}
		
		// diagonalization of the bidiagonal form
		prec= prec*x
		for (k=n-1; k != -1; k+= -1)
		{
			for (var iteration=0; iteration < itmax; iteration++)
			{	// test f splitting
				var test_convergence = false
				for (l=k; l != -1; l+= -1)
				{	
					if (Math.abs(e[l]) <= prec)
					{	test_convergence= true
						break 
					}
					if (Math.abs(q[l-1]) <= prec)
						break 
				}
				if (!test_convergence)
				{	// cancellation of e[l] if l>0
					c= 0.0
					s= 1.0
					var l1= l-1
					for (i =l; i<k+1; i++)
					{	
						f= s*e[i]
						e[i]= c*e[i]
						if (Math.abs(f) <= prec)
							break
						g= q[i]
						h= pythag(f,g)
						q[i]= h
						c= g/h
						s= -f/h
						for (j=0; j < m; j++)
						{	
							y= u[j][l1]
							z= u[j][i]
							u[j][l1] =  y*c+(z*s)
							u[j][i] = -y*s+(z*c)
						} 
					}	
				}
				// test f convergence
				z= q[k]
				if (l== k)
				{	//convergence
					if (z<0.0)
					{	//q[k] is made non-negative
						q[k]= -z
						for (j=0; j < n; j++)
							v[j][k] = -v[j][k]
					}
					break  //break out of iteration loop and move on to next k value
				}
				if (iteration >= itmax-1)
					throw 'Error: no convergence.'
				// shift from bottom 2x2 minor
				x= q[l]
				y= q[k-1]
				g= e[k-1]
				h= e[k]
				f= ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y)
				g= pythag(f,1.0)
				if (f < 0.0)
					f= ((x-z)*(x+z)+h*(y/(f-g)-h))/x
				else
					f= ((x-z)*(x+z)+h*(y/(f+g)-h))/x
				// next QR transformation
				c= 1.0
				s= 1.0
				for (i=l+1; i< k+1; i++)
				{	
					g= e[i]
					y= q[i]
					h= s*g
					g= c*g
					z= pythag(f,h)
					e[i-1]= z
					c= f/z
					s= h/z
					f= x*c+g*s
					g= -x*s+g*c
					h= y*s
					y= y*c
					for (j=0; j < n; j++)
					{	
						x= v[j][i-1]
						z= v[j][i]
						v[j][i-1] = x*c+z*s
						v[j][i] = -x*s+z*c
					}
					z= pythag(f,h)
					q[i-1]= z
					c= f/z
					s= h/z
					f= c*g+s*y
					x= -s*g+c*y
					for (j=0; j < m; j++)
					{
						y= u[j][i-1]
						z= u[j][i]
						u[j][i-1] = y*c+z*s
						u[j][i] = -y*s+z*c
					}
				}
				e[l]= 0.0
				e[k]= f
				q[k]= x
			} 
		}
			
		//vt= transpose(v)
		//return (u,q,vt)
		for (i=0;i<q.length; i++) 
		  if (q[i] < prec) q[i] = 0
		  
		//sort eigenvalues	
		for (i=0; i< n; i++)
		{	 
		//writeln(q)
		 for (j=i-1; j >= 0; j--)
		 {
		  if (q[j] < q[i])
		  {
		//  writeln(i,'-',j)
		   c = q[j]
		   q[j] = q[i]
		   q[i] = c
		   for(k=0;k<u.length;k++) { temp = u[k][i]; u[k][i] = u[k][j]; u[k][j] = temp; }
		   for(k=0;k<v.length;k++) { temp = v[k][i]; v[k][i] = v[k][j]; v[k][j] = temp; }
	//	   u.swapCols(i,j)
	//	   v.swapCols(i,j)
		   i = j	   
		  }
		 }	
		}
		
		return {U:u,S:q,V:v}
	};
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 423 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.twoPoints = twoPoints;
	exports.points = points;
	exports.arkCirc = arkCirc;
	exports.generic = generic;
	exports.pointAndLine = pointAndLine;
	exports.line = line;
	exports.lines = lines;
	exports.arcCircAndLine = arcCircAndLine;
	exports.twoLines = twoLines;
	exports.sketchObjects = sketchObjects;
	function twoPoints(objs) {
	  var points = [];
	  for (var i = 0; i < objs.length; ++i) {
	    if (objs[i]._class == 'TCAD.TWO.EndPoint') {
	      points.push(objs[i]);
	    } else if (objs[i]._class == 'TCAD.TWO.Segment') {
	      points.push(objs[i].a);
	      points.push(objs[i].b);
	    }
	  }
	  if (points.length < 2) {
	    throw "Illegal Argument. Constraint requires 2 points or 1 line.";
	  }
	  return points;
	}
	
	function points(objs) {
	  var points = [];
	  for (var i = 0; i < objs.length; ++i) {
	    objs[i].accept(function (o) {
	      if (o._class === 'TCAD.TWO.EndPoint') {
	        points.push(o);
	      }
	      return true;
	    });
	  }
	  if (points.length == 0) {
	    throw "Illegal Argument. Constraint requires at least 1 point/line/arc/circle.";
	  }
	  return points;
	}
	
	function arkCirc(objs, min) {
	  var arcs = [];
	  for (var i = 0; i < objs.length; ++i) {
	    if (objs[i]._class === 'TCAD.TWO.Arc' || objs[i]._class === 'TCAD.TWO.Circle') {
	      arcs.push(objs[i]);
	    }
	  }
	  if (arcs.length < min) {
	    throw "Illegal Argument. Constraint requires at least " + min + " arcs/circles.";
	  }
	  return arcs;
	}
	
	function generic(objs, types, min) {
	  var result = [];
	  for (var i = 0; i < objs.length; ++i) {
	    if (types.indexOf(objs[i]._class) > -1) {
	      result.push(objs[i]);
	    }
	  }
	  if (result.length < min) {
	    throw "Illegal Argument. Constraint requires at least " + min + " of " + types;
	  }
	  return result;
	}
	
	function pointAndLine(objs) {
	
	  var point = null;
	  var line = null;
	
	  for (var i = 0; i < objs.length; ++i) {
	    if (objs[i]._class == 'TCAD.TWO.EndPoint') {
	      point = objs[i];
	    } else if (objs[i]._class == 'TCAD.TWO.Segment') {
	      line = objs[i];
	    }
	  }
	  if (point == null || line == null) {
	    throw "Illegal Argument. Constraint requires point and line.";
	  }
	
	  return [point, line];
	}
	
	function line(objs) {
	  for (var i = 0; i < objs.length; ++i) {
	    if (objs[i]._class == 'TCAD.TWO.Segment') {
	      return objs[i];
	    }
	  }
	  throw "Illegal Argument. Constraint requires a line.";
	}
	
	function lines(objs) {
	  return objs.filter(function (o) {
	    return o._class == 'TCAD.TWO.Segment';
	  });
	}
	
	function arcCircAndLine(objs) {
	
	  var arc = null;
	  var line = null;
	
	  for (var i = 0; i < objs.length; ++i) {
	    if (objs[i]._class === 'TCAD.TWO.Arc' || objs[i]._class === 'TCAD.TWO.Circle') {
	      arc = objs[i];
	    } else if (objs[i]._class == 'TCAD.TWO.Segment') {
	      line = objs[i];
	    }
	  }
	  if (arc == null || line == null) {
	    throw "Illegal Argument. Constraint requires arc and line.";
	  }
	
	  return [arc, line];
	}
	
	function twoLines(objs) {
	  var lines = [];
	  for (var i = 0; i < objs.length; ++i) {
	    if (objs[i]._class == 'TCAD.TWO.Segment') {
	      lines.push(objs[i]);
	    }
	  }
	  if (lines.length < 2) {
	    throw "Illegal Argument. Constraint requires 2 lines.";
	  }
	  return lines;
	}
	
	function sketchObjects(objs, silent, matching) {
	  var fetched = [];
	  for (var i = 0; i < objs.length; ++i) {
	    for (var j = 0; j < matching.length; j++) {
	      if (objs[i]._class == matching[j]) {
	        fetched[j] = objs[i];
	        matching[j] = null;
	      }
	    }
	  }
	  if (fetched.length != matching.length) {
	    if (silent) {
	      return null;
	    } else {
	      throw "Illegal Argument. " + matching + " required";
	    }
	  }
	  return fetched;
	}

/***/ },
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.HistoryManager = undefined;
	
	var _diffMatchPatch = __webpack_require__(425);
	
	var _diffMatchPatch2 = _interopRequireDefault(_diffMatchPatch);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/** @constructor */
	function HistoryManager(viewer) {
	  this.viewer = viewer;
	  this.dmp = new _diffMatchPatch2.default();
	  this.init(this.viewer.io.serializeSketch());
	}
	
	HistoryManager.prototype.init = function (sketchData) {
	  this.lastCheckpoint = sketchData;
	  this.diffs = [];
	  this.historyPointer = -1;
	};
	
	HistoryManager.prototype.undo = function () {
	  var currentState = this.viewer.io.serializeSketch();
	  if (currentState == this.lastCheckpoint) {
	    if (this.historyPointer != -1) {
	      var diff = this.diffs[this.historyPointer];
	      this.lastCheckpoint = this.applyDiff(this.lastCheckpoint, diff);
	      this.viewer.io.loadSketch(this.lastCheckpoint);
	      this.viewer.fullHeavyUIRefresh();
	      this.historyPointer--;
	    }
	  } else {
	    var diffToCurr = this.getDiff(currentState, this.lastCheckpoint);
	    if (this.historyPointer != this.diffs.length - 1) {
	      this.diffs.splice(this.historyPointer + 1, this.diffs.length - this.historyPointer + 1);
	    }
	    this.diffs.push(diffToCurr);
	    this.viewer.io.loadSketch(this.lastCheckpoint);
	    this.viewer.fullHeavyUIRefresh();
	  }
	};
	
	HistoryManager.prototype.lightCheckpoint = function (weight) {
	  this._counter += weight;
	  if (this._counter >= 100) {
	    this.checkpoint();
	  }
	};
	
	HistoryManager.prototype.checkpoint = function () {
	  try {
	    this._checkpoint();
	  } catch (e) {
	    console.log(e);
	  }
	};
	
	HistoryManager.prototype._checkpoint = function () {
	  this._counter = 0;
	  var currentState = this.viewer.io.serializeSketch();
	  if (currentState == this.lastCheckpoint) {
	    return;
	  }
	  var diffToCurr = this.getDiff(currentState, this.lastCheckpoint);
	  if (this.historyPointer != this.diffs.length - 1) {
	    this.diffs.splice(this.historyPointer + 1, this.diffs.length - this.historyPointer + 1);
	  }
	  this.diffs.push(diffToCurr);
	  this.historyPointer = this.diffs.length - 1;
	  this.lastCheckpoint = currentState;
	};
	
	HistoryManager.prototype.redo = function () {
	  var currentState = this.viewer.io.serializeSketch();
	  if (currentState != this.lastCheckpoint) {
	    return;
	  }
	  if (this.historyPointer != this.diffs.length - 1 && this.diffs.length != 0) {
	    this.historyPointer++;
	    var diff = this.diffs[this.historyPointer];
	    this.lastCheckpoint = this.applyDiffInv(this.lastCheckpoint, diff);
	    this.viewer.io.loadSketch(this.lastCheckpoint);
	    this.viewer.fullHeavyUIRefresh();
	  }
	};
	
	HistoryManager.prototype.applyDiff = function (text1, diff) {
	  var dmp = this.dmp;
	  var results = dmp.patch_apply(diff, text1);
	  return results[0];
	};
	
	HistoryManager.prototype.applyDiffInv = function (text1, diff) {
	  this.reversePatch(diff);
	  var result = this.applyDiff(text1, diff);
	  this.reversePatch(diff);
	  return result;
	};
	
	HistoryManager.prototype.reversePatch = function (plist) {
	  for (var i = 0; i < plist.length; i++) {
	    var patch = plist[i];
	    for (var j = 0; j < patch.diffs.length; j++) {
	      var diff = patch.diffs[j];
	      diff[0] *= -1;
	    }
	  }
	};
	
	HistoryManager.prototype.getDiff = function (text1, text2) {
	  var dmp = this.dmp;
	  var diff = dmp.diff_main(text1, text2, true);
	
	  if (diff.length > 2) {
	    dmp.diff_cleanupSemantic(diff);
	  }
	
	  var patch_list = dmp.patch_make(text1, text2, diff);
	  //var patch_text = dmp.patch_toText(patch_list);
	  //console.log(patch_list);
	  return patch_list;
	};
	
	exports.HistoryManager = HistoryManager;

/***/ },
/* 425 */
/***/ function(module, exports) {

	'use strict'
	
	/**
	 * Diff Match and Patch
	 *
	 * Copyright 2006 Google Inc.
	 * http://code.google.com/p/google-diff-match-patch/
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	/**
	 * @fileoverview Computes the difference between two texts to create a patch.
	 * Applies the patch onto another text, allowing for errors.
	 * @author fraser@google.com (Neil Fraser)
	 */
	
	/**
	 * Class containing the diff, match and patch methods.
	 * @constructor
	 */
	function diff_match_patch() {
	
	  // Defaults.
	  // Redefine these in your program to override the defaults.
	
	  // Number of seconds to map a diff before giving up (0 for infinity).
	  this.Diff_Timeout = 1.0;
	  // Cost of an empty edit operation in terms of edit characters.
	  this.Diff_EditCost = 4;
	  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
	  this.Match_Threshold = 0.5;
	  // How far to search for a match (0 = exact location, 1000+ = broad match).
	  // A match this many characters away from the expected location will add
	  // 1.0 to the score (0.0 is a perfect match).
	  this.Match_Distance = 1000;
	  // When deleting a large block of text (over ~64 characters), how close do
	  // the contents have to be to match the expected contents. (0.0 = perfection,
	  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
	  // end points of a delete need to match.
	  this.Patch_DeleteThreshold = 0.5;
	  // Chunk size for context length.
	  this.Patch_Margin = 4;
	
	  // The number of bits in an int.
	  this.Match_MaxBits = 32;
	}
	
	
	//  DIFF FUNCTIONS
	
	
	/**
	 * The data structure representing a diff is an array of tuples:
	 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
	 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
	 */
	var DIFF_DELETE = -1;
	var DIFF_INSERT = 1;
	var DIFF_EQUAL = 0;
	
	/** @typedef {{0: number, 1: string}} */
	diff_match_patch.Diff;
	
	
	/**
	 * Find the differences between two texts.  Simplifies the problem by stripping
	 * any common prefix or suffix off the texts before diffing.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
	 *     then don't run a line-level diff first to identify the changed areas.
	 *     Defaults to true, which does a faster, slightly less optimal diff.
	 * @param {number} opt_deadline Optional time when the diff should be complete
	 *     by.  Used internally for recursive calls.  Users should set DiffTimeout
	 *     instead.
	 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
	 */
	diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
	    opt_deadline) {
	  // Set a deadline by which time the diff must be complete.
	  if (typeof opt_deadline == 'undefined') {
	    if (this.Diff_Timeout <= 0) {
	      opt_deadline = Number.MAX_VALUE;
	    } else {
	      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
	    }
	  }
	  var deadline = opt_deadline;
	
	  // Check for null inputs.
	  if (text1 == null || text2 == null) {
	    throw new Error('Null input. (diff_main)');
	  }
	
	  // Check for equality (speedup).
	  if (text1 == text2) {
	    if (text1) {
	      return [[DIFF_EQUAL, text1]];
	    }
	    return [];
	  }
	
	  if (typeof opt_checklines == 'undefined') {
	    opt_checklines = true;
	  }
	  var checklines = opt_checklines;
	
	  // Trim off common prefix (speedup).
	  var commonlength = this.diff_commonPrefix(text1, text2);
	  var commonprefix = text1.substring(0, commonlength);
	  text1 = text1.substring(commonlength);
	  text2 = text2.substring(commonlength);
	
	  // Trim off common suffix (speedup).
	  commonlength = this.diff_commonSuffix(text1, text2);
	  var commonsuffix = text1.substring(text1.length - commonlength);
	  text1 = text1.substring(0, text1.length - commonlength);
	  text2 = text2.substring(0, text2.length - commonlength);
	
	  // Compute the diff on the middle block.
	  var diffs = this.diff_compute_(text1, text2, checklines, deadline);
	
	  // Restore the prefix and suffix.
	  if (commonprefix) {
	    diffs.unshift([DIFF_EQUAL, commonprefix]);
	  }
	  if (commonsuffix) {
	    diffs.push([DIFF_EQUAL, commonsuffix]);
	  }
	  this.diff_cleanupMerge(diffs);
	  return diffs;
	};
	
	
	/**
	 * Find the differences between two texts.  Assumes that the texts do not
	 * have any common prefix or suffix.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {boolean} checklines Speedup flag.  If false, then don't run a
	 *     line-level diff first to identify the changed areas.
	 *     If true, then run a faster, slightly less optimal diff.
	 * @param {number} deadline Time when the diff should be complete by.
	 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
	 * @private
	 */
	diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
	    deadline) {
	  var diffs;
	
	  if (!text1) {
	    // Just add some text (speedup).
	    return [[DIFF_INSERT, text2]];
	  }
	
	  if (!text2) {
	    // Just delete some text (speedup).
	    return [[DIFF_DELETE, text1]];
	  }
	
	  var longtext = text1.length > text2.length ? text1 : text2;
	  var shorttext = text1.length > text2.length ? text2 : text1;
	  var i = longtext.indexOf(shorttext);
	  if (i != -1) {
	    // Shorter text is inside the longer text (speedup).
	    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
	             [DIFF_EQUAL, shorttext],
	             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
	    // Swap insertions for deletions if diff is reversed.
	    if (text1.length > text2.length) {
	      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
	    }
	    return diffs;
	  }
	
	  if (shorttext.length == 1) {
	    // Single character string.
	    // After the previous speedup, the character can't be an equality.
	    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
	  }
	
	  // Check to see if the problem can be split in two.
	  var hm = this.diff_halfMatch_(text1, text2);
	  if (hm) {
	    // A half-match was found, sort out the return data.
	    var text1_a = hm[0];
	    var text1_b = hm[1];
	    var text2_a = hm[2];
	    var text2_b = hm[3];
	    var mid_common = hm[4];
	    // Send both pairs off for separate processing.
	    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
	    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
	    // Merge the results.
	    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
	  }
	
	  if (checklines && text1.length > 100 && text2.length > 100) {
	    return this.diff_lineMode_(text1, text2, deadline);
	  }
	
	  return this.diff_bisect_(text1, text2, deadline);
	};
	
	
	/**
	 * Do a quick line-level diff on both strings, then rediff the parts for
	 * greater accuracy.
	 * This speedup can produce non-minimal diffs.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} deadline Time when the diff should be complete by.
	 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
	 * @private
	 */
	diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
	  // Scan the text on a line-by-line basis first.
	  var a = this.diff_linesToChars_(text1, text2);
	  text1 = a.chars1;
	  text2 = a.chars2;
	  var linearray = a.lineArray;
	
	  var diffs = this.diff_main(text1, text2, false, deadline);
	
	  // Convert the diff back to original text.
	  this.diff_charsToLines_(diffs, linearray);
	  // Eliminate freak matches (e.g. blank lines)
	  this.diff_cleanupSemantic(diffs);
	
	  // Rediff any replacement blocks, this time character-by-character.
	  // Add a dummy entry at the end.
	  diffs.push([DIFF_EQUAL, '']);
	  var pointer = 0;
	  var count_delete = 0;
	  var count_insert = 0;
	  var text_delete = '';
	  var text_insert = '';
	  while (pointer < diffs.length) {
	    switch (diffs[pointer][0]) {
	      case DIFF_INSERT:
	        count_insert++;
	        text_insert += diffs[pointer][1];
	        break;
	      case DIFF_DELETE:
	        count_delete++;
	        text_delete += diffs[pointer][1];
	        break;
	      case DIFF_EQUAL:
	        // Upon reaching an equality, check for prior redundancies.
	        if (count_delete >= 1 && count_insert >= 1) {
	          // Delete the offending records and add the merged ones.
	          diffs.splice(pointer - count_delete - count_insert,
	                       count_delete + count_insert);
	          pointer = pointer - count_delete - count_insert;
	          var a = this.diff_main(text_delete, text_insert, false, deadline);
	          for (var j = a.length - 1; j >= 0; j--) {
	            diffs.splice(pointer, 0, a[j]);
	          }
	          pointer = pointer + a.length;
	        }
	        count_insert = 0;
	        count_delete = 0;
	        text_delete = '';
	        text_insert = '';
	        break;
	    }
	    pointer++;
	  }
	  diffs.pop();  // Remove the dummy entry at the end.
	
	  return diffs;
	};
	
	
	/**
	 * Find the 'middle snake' of a diff, split the problem in two
	 * and return the recursively constructed diff.
	 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} deadline Time at which to bail if not yet complete.
	 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
	 * @private
	 */
	diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
	  // Cache the text lengths to prevent multiple calls.
	  var text1_length = text1.length;
	  var text2_length = text2.length;
	  var max_d = Math.ceil((text1_length + text2_length) / 2);
	  var v_offset = max_d;
	  var v_length = 2 * max_d;
	  var v1 = new Array(v_length);
	  var v2 = new Array(v_length);
	  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
	  // integers and undefined.
	  for (var x = 0; x < v_length; x++) {
	    v1[x] = -1;
	    v2[x] = -1;
	  }
	  v1[v_offset + 1] = 0;
	  v2[v_offset + 1] = 0;
	  var delta = text1_length - text2_length;
	  // If the total number of characters is odd, then the front path will collide
	  // with the reverse path.
	  var front = (delta % 2 != 0);
	  // Offsets for start and end of k loop.
	  // Prevents mapping of space beyond the grid.
	  var k1start = 0;
	  var k1end = 0;
	  var k2start = 0;
	  var k2end = 0;
	  for (var d = 0; d < max_d; d++) {
	    // Bail out if deadline is reached.
	    if ((new Date()).getTime() > deadline) {
	      break;
	    }
	
	    // Walk the front path one step.
	    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
	      var k1_offset = v_offset + k1;
	      var x1;
	      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
	        x1 = v1[k1_offset + 1];
	      } else {
	        x1 = v1[k1_offset - 1] + 1;
	      }
	      var y1 = x1 - k1;
	      while (x1 < text1_length && y1 < text2_length &&
	             text1.charAt(x1) == text2.charAt(y1)) {
	        x1++;
	        y1++;
	      }
	      v1[k1_offset] = x1;
	      if (x1 > text1_length) {
	        // Ran off the right of the graph.
	        k1end += 2;
	      } else if (y1 > text2_length) {
	        // Ran off the bottom of the graph.
	        k1start += 2;
	      } else if (front) {
	        var k2_offset = v_offset + delta - k1;
	        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
	          // Mirror x2 onto top-left coordinate system.
	          var x2 = text1_length - v2[k2_offset];
	          if (x1 >= x2) {
	            // Overlap detected.
	            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
	          }
	        }
	      }
	    }
	
	    // Walk the reverse path one step.
	    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
	      var k2_offset = v_offset + k2;
	      var x2;
	      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
	        x2 = v2[k2_offset + 1];
	      } else {
	        x2 = v2[k2_offset - 1] + 1;
	      }
	      var y2 = x2 - k2;
	      while (x2 < text1_length && y2 < text2_length &&
	             text1.charAt(text1_length - x2 - 1) ==
	             text2.charAt(text2_length - y2 - 1)) {
	        x2++;
	        y2++;
	      }
	      v2[k2_offset] = x2;
	      if (x2 > text1_length) {
	        // Ran off the left of the graph.
	        k2end += 2;
	      } else if (y2 > text2_length) {
	        // Ran off the top of the graph.
	        k2start += 2;
	      } else if (!front) {
	        var k1_offset = v_offset + delta - k2;
	        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
	          var x1 = v1[k1_offset];
	          var y1 = v_offset + x1 - k1_offset;
	          // Mirror x2 onto top-left coordinate system.
	          x2 = text1_length - x2;
	          if (x1 >= x2) {
	            // Overlap detected.
	            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
	          }
	        }
	      }
	    }
	  }
	  // Diff took too long and hit the deadline or
	  // number of diffs equals number of characters, no commonality at all.
	  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
	};
	
	
	/**
	 * Given the location of the 'middle snake', split the diff in two parts
	 * and recurse.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} x Index of split point in text1.
	 * @param {number} y Index of split point in text2.
	 * @param {number} deadline Time at which to bail if not yet complete.
	 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
	 * @private
	 */
	diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
	    deadline) {
	  var text1a = text1.substring(0, x);
	  var text2a = text2.substring(0, y);
	  var text1b = text1.substring(x);
	  var text2b = text2.substring(y);
	
	  // Compute both diffs serially.
	  var diffs = this.diff_main(text1a, text2a, false, deadline);
	  var diffsb = this.diff_main(text1b, text2b, false, deadline);
	
	  return diffs.concat(diffsb);
	};
	
	
	/**
	 * Split two texts into an array of strings.  Reduce the texts to a string of
	 * hashes where each Unicode character represents one line.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
	 *     An object containing the encoded text1, the encoded text2 and
	 *     the array of unique strings.
	 *     The zeroth element of the array of unique strings is intentionally blank.
	 * @private
	 */
	diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
	  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
	  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4
	
	  // '\x00' is a valid character, but various debuggers don't like it.
	  // So we'll insert a junk entry to avoid generating a null character.
	  lineArray[0] = '';
	
	  /**
	   * Split a text into an array of strings.  Reduce the texts to a string of
	   * hashes where each Unicode character represents one line.
	   * Modifies linearray and linehash through being a closure.
	   * @param {string} text String to encode.
	   * @return {string} Encoded string.
	   * @private
	   */
	  function diff_linesToCharsMunge_(text) {
	    var chars = '';
	    // Walk the text, pulling out a substring for each line.
	    // text.split('\n') would would temporarily double our memory footprint.
	    // Modifying text would create many large strings to garbage collect.
	    var lineStart = 0;
	    var lineEnd = -1;
	    // Keeping our own length variable is faster than looking it up.
	    var lineArrayLength = lineArray.length;
	    while (lineEnd < text.length - 1) {
	      lineEnd = text.indexOf('\n', lineStart);
	      if (lineEnd == -1) {
	        lineEnd = text.length - 1;
	      }
	      var line = text.substring(lineStart, lineEnd + 1);
	      lineStart = lineEnd + 1;
	
	      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
	          (lineHash[line] !== undefined)) {
	        chars += String.fromCharCode(lineHash[line]);
	      } else {
	        chars += String.fromCharCode(lineArrayLength);
	        lineHash[line] = lineArrayLength;
	        lineArray[lineArrayLength++] = line;
	      }
	    }
	    return chars;
	  }
	
	  var chars1 = diff_linesToCharsMunge_(text1);
	  var chars2 = diff_linesToCharsMunge_(text2);
	  return {chars1: chars1, chars2: chars2, lineArray: lineArray};
	};
	
	
	/**
	 * Rehydrate the text in a diff from a string of line hashes to real lines of
	 * text.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @param {!Array.<string>} lineArray Array of unique strings.
	 * @private
	 */
	diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
	  for (var x = 0; x < diffs.length; x++) {
	    var chars = diffs[x][1];
	    var text = [];
	    for (var y = 0; y < chars.length; y++) {
	      text[y] = lineArray[chars.charCodeAt(y)];
	    }
	    diffs[x][1] = text.join('');
	  }
	};
	
	
	/**
	 * Determine the common prefix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the start of each
	 *     string.
	 */
	diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
	  // Quick check for common null cases.
	  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
	    return 0;
	  }
	  // Binary search.
	  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	  var pointermin = 0;
	  var pointermax = Math.min(text1.length, text2.length);
	  var pointermid = pointermax;
	  var pointerstart = 0;
	  while (pointermin < pointermid) {
	    if (text1.substring(pointerstart, pointermid) ==
	        text2.substring(pointerstart, pointermid)) {
	      pointermin = pointermid;
	      pointerstart = pointermin;
	    } else {
	      pointermax = pointermid;
	    }
	    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	  }
	  return pointermid;
	};
	
	
	/**
	 * Determine the common suffix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the end of each string.
	 */
	diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
	  // Quick check for common null cases.
	  if (!text1 || !text2 ||
	      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
	    return 0;
	  }
	  // Binary search.
	  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	  var pointermin = 0;
	  var pointermax = Math.min(text1.length, text2.length);
	  var pointermid = pointermax;
	  var pointerend = 0;
	  while (pointermin < pointermid) {
	    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
	        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
	      pointermin = pointermid;
	      pointerend = pointermin;
	    } else {
	      pointermax = pointermid;
	    }
	    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	  }
	  return pointermid;
	};
	
	
	/**
	 * Determine if the suffix of one string is the prefix of another.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the end of the first
	 *     string and the start of the second string.
	 * @private
	 */
	diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
	  // Cache the text lengths to prevent multiple calls.
	  var text1_length = text1.length;
	  var text2_length = text2.length;
	  // Eliminate the null case.
	  if (text1_length == 0 || text2_length == 0) {
	    return 0;
	  }
	  // Truncate the longer string.
	  if (text1_length > text2_length) {
	    text1 = text1.substring(text1_length - text2_length);
	  } else if (text1_length < text2_length) {
	    text2 = text2.substring(0, text1_length);
	  }
	  var text_length = Math.min(text1_length, text2_length);
	  // Quick check for the worst case.
	  if (text1 == text2) {
	    return text_length;
	  }
	
	  // Start by looking for a single character match
	  // and increase length until no match is found.
	  // Performance analysis: http://neil.fraser.name/news/2010/11/04/
	  var best = 0;
	  var length = 1;
	  while (true) {
	    var pattern = text1.substring(text_length - length);
	    var found = text2.indexOf(pattern);
	    if (found == -1) {
	      return best;
	    }
	    length += found;
	    if (found == 0 || text1.substring(text_length - length) ==
	        text2.substring(0, length)) {
	      best = length;
	      length++;
	    }
	  }
	};
	
	
	/**
	 * Do the two texts share a substring which is at least half the length of the
	 * longer text?
	 * This speedup can produce non-minimal diffs.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {Array.<string>} Five element Array, containing the prefix of
	 *     text1, the suffix of text1, the prefix of text2, the suffix of
	 *     text2 and the common middle.  Or null if there was no match.
	 * @private
	 */
	diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
	  if (this.Diff_Timeout <= 0) {
	    // Don't risk returning a non-optimal diff if we have unlimited time.
	    return null;
	  }
	  var longtext = text1.length > text2.length ? text1 : text2;
	  var shorttext = text1.length > text2.length ? text2 : text1;
	  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
	    return null;  // Pointless.
	  }
	  var dmp = this;  // 'this' becomes 'window' in a closure.
	
	  /**
	   * Does a substring of shorttext exist within longtext such that the substring
	   * is at least half the length of longtext?
	   * Closure, but does not reference any external variables.
	   * @param {string} longtext Longer string.
	   * @param {string} shorttext Shorter string.
	   * @param {number} i Start index of quarter length substring within longtext.
	   * @return {Array.<string>} Five element Array, containing the prefix of
	   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
	   *     of shorttext and the common middle.  Or null if there was no match.
	   * @private
	   */
	  function diff_halfMatchI_(longtext, shorttext, i) {
	    // Start with a 1/4 length substring at position i as a seed.
	    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
	    var j = -1;
	    var best_common = '';
	    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
	    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
	      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
	                                               shorttext.substring(j));
	      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
	                                               shorttext.substring(0, j));
	      if (best_common.length < suffixLength + prefixLength) {
	        best_common = shorttext.substring(j - suffixLength, j) +
	            shorttext.substring(j, j + prefixLength);
	        best_longtext_a = longtext.substring(0, i - suffixLength);
	        best_longtext_b = longtext.substring(i + prefixLength);
	        best_shorttext_a = shorttext.substring(0, j - suffixLength);
	        best_shorttext_b = shorttext.substring(j + prefixLength);
	      }
	    }
	    if (best_common.length * 2 >= longtext.length) {
	      return [best_longtext_a, best_longtext_b,
	              best_shorttext_a, best_shorttext_b, best_common];
	    } else {
	      return null;
	    }
	  }
	
	  // First check if the second quarter is the seed for a half-match.
	  var hm1 = diff_halfMatchI_(longtext, shorttext,
	                             Math.ceil(longtext.length / 4));
	  // Check again based on the third quarter.
	  var hm2 = diff_halfMatchI_(longtext, shorttext,
	                             Math.ceil(longtext.length / 2));
	  var hm;
	  if (!hm1 && !hm2) {
	    return null;
	  } else if (!hm2) {
	    hm = hm1;
	  } else if (!hm1) {
	    hm = hm2;
	  } else {
	    // Both matched.  Select the longest.
	    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
	  }
	
	  // A half-match was found, sort out the return data.
	  var text1_a, text1_b, text2_a, text2_b;
	  if (text1.length > text2.length) {
	    text1_a = hm[0];
	    text1_b = hm[1];
	    text2_a = hm[2];
	    text2_b = hm[3];
	  } else {
	    text2_a = hm[0];
	    text2_b = hm[1];
	    text1_a = hm[2];
	    text1_b = hm[3];
	  }
	  var mid_common = hm[4];
	  return [text1_a, text1_b, text2_a, text2_b, mid_common];
	};
	
	
	/**
	 * Reduce the number of edits by eliminating semantically trivial equalities.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 */
	diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
	  var changes = false;
	  var equalities = [];  // Stack of indices where equalities are found.
	  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
	  /** @type {?string} */
	  var lastequality = null;
	  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
	  var pointer = 0;  // Index of current position.
	  // Number of characters that changed prior to the equality.
	  var length_insertions1 = 0;
	  var length_deletions1 = 0;
	  // Number of characters that changed after the equality.
	  var length_insertions2 = 0;
	  var length_deletions2 = 0;
	  while (pointer < diffs.length) {
	    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
	      equalities[equalitiesLength++] = pointer;
	      length_insertions1 = length_insertions2;
	      length_deletions1 = length_deletions2;
	      length_insertions2 = 0;
	      length_deletions2 = 0;
	      lastequality = diffs[pointer][1];
	    } else {  // An insertion or deletion.
	      if (diffs[pointer][0] == DIFF_INSERT) {
	        length_insertions2 += diffs[pointer][1].length;
	      } else {
	        length_deletions2 += diffs[pointer][1].length;
	      }
	      // Eliminate an equality that is smaller or equal to the edits on both
	      // sides of it.
	      if (lastequality && (lastequality.length <=
	          Math.max(length_insertions1, length_deletions1)) &&
	          (lastequality.length <= Math.max(length_insertions2,
	                                           length_deletions2))) {
	        // Duplicate record.
	        diffs.splice(equalities[equalitiesLength - 1], 0,
	                     [DIFF_DELETE, lastequality]);
	        // Change second copy to insert.
	        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
	        // Throw away the equality we just deleted.
	        equalitiesLength--;
	        // Throw away the previous equality (it needs to be reevaluated).
	        equalitiesLength--;
	        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
	        length_insertions1 = 0;  // Reset the counters.
	        length_deletions1 = 0;
	        length_insertions2 = 0;
	        length_deletions2 = 0;
	        lastequality = null;
	        changes = true;
	      }
	    }
	    pointer++;
	  }
	
	  // Normalize the diff.
	  if (changes) {
	    this.diff_cleanupMerge(diffs);
	  }
	  this.diff_cleanupSemanticLossless(diffs);
	
	  // Find any overlaps between deletions and insertions.
	  // e.g: <del>abcxxx</del><ins>xxxdef</ins>
	  //   -> <del>abc</del>xxx<ins>def</ins>
	  // e.g: <del>xxxabc</del><ins>defxxx</ins>
	  //   -> <ins>def</ins>xxx<del>abc</del>
	  // Only extract an overlap if it is as big as the edit ahead or behind it.
	  pointer = 1;
	  while (pointer < diffs.length) {
	    if (diffs[pointer - 1][0] == DIFF_DELETE &&
	        diffs[pointer][0] == DIFF_INSERT) {
	      var deletion = diffs[pointer - 1][1];
	      var insertion = diffs[pointer][1];
	      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
	      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
	      if (overlap_length1 >= overlap_length2) {
	        if (overlap_length1 >= deletion.length / 2 ||
	            overlap_length1 >= insertion.length / 2) {
	          // Overlap found.  Insert an equality and trim the surrounding edits.
	          diffs.splice(pointer, 0,
	              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);
	          diffs[pointer - 1][1] =
	              deletion.substring(0, deletion.length - overlap_length1);
	          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
	          pointer++;
	        }
	      } else {
	        if (overlap_length2 >= deletion.length / 2 ||
	            overlap_length2 >= insertion.length / 2) {
	          // Reverse overlap found.
	          // Insert an equality and swap and trim the surrounding edits.
	          diffs.splice(pointer, 0,
	              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);
	          diffs[pointer - 1][0] = DIFF_INSERT;
	          diffs[pointer - 1][1] =
	              insertion.substring(0, insertion.length - overlap_length2);
	          diffs[pointer + 1][0] = DIFF_DELETE;
	          diffs[pointer + 1][1] =
	              deletion.substring(overlap_length2);
	          pointer++;
	        }
	      }
	      pointer++;
	    }
	    pointer++;
	  }
	};
	
	
	/**
	 * Look for single edits surrounded on both sides by equalities
	 * which can be shifted sideways to align the edit to a word boundary.
	 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 */
	diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
	  /**
	   * Given two strings, compute a score representing whether the internal
	   * boundary falls on logical boundaries.
	   * Scores range from 6 (best) to 0 (worst).
	   * Closure, but does not reference any external variables.
	   * @param {string} one First string.
	   * @param {string} two Second string.
	   * @return {number} The score.
	   * @private
	   */
	  function diff_cleanupSemanticScore_(one, two) {
	    if (!one || !two) {
	      // Edges are the best.
	      return 6;
	    }
	
	    // Each port of this function behaves slightly differently due to
	    // subtle differences in each language's definition of things like
	    // 'whitespace'.  Since this function's purpose is largely cosmetic,
	    // the choice has been made to use each language's native features
	    // rather than force total conformity.
	    var char1 = one.charAt(one.length - 1);
	    var char2 = two.charAt(0);
	    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
	    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
	    var whitespace1 = nonAlphaNumeric1 &&
	        char1.match(diff_match_patch.whitespaceRegex_);
	    var whitespace2 = nonAlphaNumeric2 &&
	        char2.match(diff_match_patch.whitespaceRegex_);
	    var lineBreak1 = whitespace1 &&
	        char1.match(diff_match_patch.linebreakRegex_);
	    var lineBreak2 = whitespace2 &&
	        char2.match(diff_match_patch.linebreakRegex_);
	    var blankLine1 = lineBreak1 &&
	        one.match(diff_match_patch.blanklineEndRegex_);
	    var blankLine2 = lineBreak2 &&
	        two.match(diff_match_patch.blanklineStartRegex_);
	
	    if (blankLine1 || blankLine2) {
	      // Five points for blank lines.
	      return 5;
	    } else if (lineBreak1 || lineBreak2) {
	      // Four points for line breaks.
	      return 4;
	    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
	      // Three points for end of sentences.
	      return 3;
	    } else if (whitespace1 || whitespace2) {
	      // Two points for whitespace.
	      return 2;
	    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
	      // One point for non-alphanumeric.
	      return 1;
	    }
	    return 0;
	  }
	
	  var pointer = 1;
	  // Intentionally ignore the first and last element (don't need checking).
	  while (pointer < diffs.length - 1) {
	    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
	        diffs[pointer + 1][0] == DIFF_EQUAL) {
	      // This is a single edit surrounded by equalities.
	      var equality1 = diffs[pointer - 1][1];
	      var edit = diffs[pointer][1];
	      var equality2 = diffs[pointer + 1][1];
	
	      // First, shift the edit as far left as possible.
	      var commonOffset = this.diff_commonSuffix(equality1, edit);
	      if (commonOffset) {
	        var commonString = edit.substring(edit.length - commonOffset);
	        equality1 = equality1.substring(0, equality1.length - commonOffset);
	        edit = commonString + edit.substring(0, edit.length - commonOffset);
	        equality2 = commonString + equality2;
	      }
	
	      // Second, step character by character right, looking for the best fit.
	      var bestEquality1 = equality1;
	      var bestEdit = edit;
	      var bestEquality2 = equality2;
	      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
	          diff_cleanupSemanticScore_(edit, equality2);
	      while (edit.charAt(0) === equality2.charAt(0)) {
	        equality1 += edit.charAt(0);
	        edit = edit.substring(1) + equality2.charAt(0);
	        equality2 = equality2.substring(1);
	        var score = diff_cleanupSemanticScore_(equality1, edit) +
	            diff_cleanupSemanticScore_(edit, equality2);
	        // The >= encourages trailing rather than leading whitespace on edits.
	        if (score >= bestScore) {
	          bestScore = score;
	          bestEquality1 = equality1;
	          bestEdit = edit;
	          bestEquality2 = equality2;
	        }
	      }
	
	      if (diffs[pointer - 1][1] != bestEquality1) {
	        // We have an improvement, save it back to the diff.
	        if (bestEquality1) {
	          diffs[pointer - 1][1] = bestEquality1;
	        } else {
	          diffs.splice(pointer - 1, 1);
	          pointer--;
	        }
	        diffs[pointer][1] = bestEdit;
	        if (bestEquality2) {
	          diffs[pointer + 1][1] = bestEquality2;
	        } else {
	          diffs.splice(pointer + 1, 1);
	          pointer--;
	        }
	      }
	    }
	    pointer++;
	  }
	};
	
	// Define some regex patterns for matching boundaries.
	diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
	diff_match_patch.whitespaceRegex_ = /\s/;
	diff_match_patch.linebreakRegex_ = /[\r\n]/;
	diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
	diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;
	
	/**
	 * Reduce the number of edits by eliminating operationally trivial equalities.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 */
	diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
	  var changes = false;
	  var equalities = [];  // Stack of indices where equalities are found.
	  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
	  /** @type {?string} */
	  var lastequality = null;
	  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
	  var pointer = 0;  // Index of current position.
	  // Is there an insertion operation before the last equality.
	  var pre_ins = false;
	  // Is there a deletion operation before the last equality.
	  var pre_del = false;
	  // Is there an insertion operation after the last equality.
	  var post_ins = false;
	  // Is there a deletion operation after the last equality.
	  var post_del = false;
	  while (pointer < diffs.length) {
	    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
	      if (diffs[pointer][1].length < this.Diff_EditCost &&
	          (post_ins || post_del)) {
	        // Candidate found.
	        equalities[equalitiesLength++] = pointer;
	        pre_ins = post_ins;
	        pre_del = post_del;
	        lastequality = diffs[pointer][1];
	      } else {
	        // Not a candidate, and can never become one.
	        equalitiesLength = 0;
	        lastequality = null;
	      }
	      post_ins = post_del = false;
	    } else {  // An insertion or deletion.
	      if (diffs[pointer][0] == DIFF_DELETE) {
	        post_del = true;
	      } else {
	        post_ins = true;
	      }
	      /*
	       * Five types to be split:
	       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
	       * <ins>A</ins>X<ins>C</ins><del>D</del>
	       * <ins>A</ins><del>B</del>X<ins>C</ins>
	       * <ins>A</del>X<ins>C</ins><del>D</del>
	       * <ins>A</ins><del>B</del>X<del>C</del>
	       */
	      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
	                           ((lastequality.length < this.Diff_EditCost / 2) &&
	                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
	        // Duplicate record.
	        diffs.splice(equalities[equalitiesLength - 1], 0,
	                     [DIFF_DELETE, lastequality]);
	        // Change second copy to insert.
	        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
	        equalitiesLength--;  // Throw away the equality we just deleted;
	        lastequality = null;
	        if (pre_ins && pre_del) {
	          // No changes made which could affect previous entry, keep going.
	          post_ins = post_del = true;
	          equalitiesLength = 0;
	        } else {
	          equalitiesLength--;  // Throw away the previous equality.
	          pointer = equalitiesLength > 0 ?
	              equalities[equalitiesLength - 1] : -1;
	          post_ins = post_del = false;
	        }
	        changes = true;
	      }
	    }
	    pointer++;
	  }
	
	  if (changes) {
	    this.diff_cleanupMerge(diffs);
	  }
	};
	
	
	/**
	 * Reorder and merge like edit sections.  Merge equalities.
	 * Any edit section can move as long as it doesn't cross an equality.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 */
	diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
	  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
	  var pointer = 0;
	  var count_delete = 0;
	  var count_insert = 0;
	  var text_delete = '';
	  var text_insert = '';
	  var commonlength;
	  while (pointer < diffs.length) {
	    switch (diffs[pointer][0]) {
	      case DIFF_INSERT:
	        count_insert++;
	        text_insert += diffs[pointer][1];
	        pointer++;
	        break;
	      case DIFF_DELETE:
	        count_delete++;
	        text_delete += diffs[pointer][1];
	        pointer++;
	        break;
	      case DIFF_EQUAL:
	        // Upon reaching an equality, check for prior redundancies.
	        if (count_delete + count_insert > 1) {
	          if (count_delete !== 0 && count_insert !== 0) {
	            // Factor out any common prefixies.
	            commonlength = this.diff_commonPrefix(text_insert, text_delete);
	            if (commonlength !== 0) {
	              if ((pointer - count_delete - count_insert) > 0 &&
	                  diffs[pointer - count_delete - count_insert - 1][0] ==
	                  DIFF_EQUAL) {
	                diffs[pointer - count_delete - count_insert - 1][1] +=
	                    text_insert.substring(0, commonlength);
	              } else {
	                diffs.splice(0, 0, [DIFF_EQUAL,
	                                    text_insert.substring(0, commonlength)]);
	                pointer++;
	              }
	              text_insert = text_insert.substring(commonlength);
	              text_delete = text_delete.substring(commonlength);
	            }
	            // Factor out any common suffixies.
	            commonlength = this.diff_commonSuffix(text_insert, text_delete);
	            if (commonlength !== 0) {
	              diffs[pointer][1] = text_insert.substring(text_insert.length -
	                  commonlength) + diffs[pointer][1];
	              text_insert = text_insert.substring(0, text_insert.length -
	                  commonlength);
	              text_delete = text_delete.substring(0, text_delete.length -
	                  commonlength);
	            }
	          }
	          // Delete the offending records and add the merged ones.
	          if (count_delete === 0) {
	            diffs.splice(pointer - count_insert,
	                count_delete + count_insert, [DIFF_INSERT, text_insert]);
	          } else if (count_insert === 0) {
	            diffs.splice(pointer - count_delete,
	                count_delete + count_insert, [DIFF_DELETE, text_delete]);
	          } else {
	            diffs.splice(pointer - count_delete - count_insert,
	                count_delete + count_insert, [DIFF_DELETE, text_delete],
	                [DIFF_INSERT, text_insert]);
	          }
	          pointer = pointer - count_delete - count_insert +
	                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
	        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
	          // Merge this equality with the previous one.
	          diffs[pointer - 1][1] += diffs[pointer][1];
	          diffs.splice(pointer, 1);
	        } else {
	          pointer++;
	        }
	        count_insert = 0;
	        count_delete = 0;
	        text_delete = '';
	        text_insert = '';
	        break;
	    }
	  }
	  if (diffs[diffs.length - 1][1] === '') {
	    diffs.pop();  // Remove the dummy entry at the end.
	  }
	
	  // Second pass: look for single edits surrounded on both sides by equalities
	  // which can be shifted sideways to eliminate an equality.
	  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
	  var changes = false;
	  pointer = 1;
	  // Intentionally ignore the first and last element (don't need checking).
	  while (pointer < diffs.length - 1) {
	    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
	        diffs[pointer + 1][0] == DIFF_EQUAL) {
	      // This is a single edit surrounded by equalities.
	      if (diffs[pointer][1].substring(diffs[pointer][1].length -
	          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
	        // Shift the edit over the previous equality.
	        diffs[pointer][1] = diffs[pointer - 1][1] +
	            diffs[pointer][1].substring(0, diffs[pointer][1].length -
	                                        diffs[pointer - 1][1].length);
	        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
	        diffs.splice(pointer - 1, 1);
	        changes = true;
	      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
	          diffs[pointer + 1][1]) {
	        // Shift the edit over the next equality.
	        diffs[pointer - 1][1] += diffs[pointer + 1][1];
	        diffs[pointer][1] =
	            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
	            diffs[pointer + 1][1];
	        diffs.splice(pointer + 1, 1);
	        changes = true;
	      }
	    }
	    pointer++;
	  }
	  // If shifts were made, the diff needs reordering and another shift sweep.
	  if (changes) {
	    this.diff_cleanupMerge(diffs);
	  }
	};
	
	
	/**
	 * loc is a location in text1, compute and return the equivalent location in
	 * text2.
	 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @param {number} loc Location within text1.
	 * @return {number} Location within text2.
	 */
	diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
	  var chars1 = 0;
	  var chars2 = 0;
	  var last_chars1 = 0;
	  var last_chars2 = 0;
	  var x;
	  for (x = 0; x < diffs.length; x++) {
	    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
	      chars1 += diffs[x][1].length;
	    }
	    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
	      chars2 += diffs[x][1].length;
	    }
	    if (chars1 > loc) {  // Overshot the location.
	      break;
	    }
	    last_chars1 = chars1;
	    last_chars2 = chars2;
	  }
	  // Was the location was deleted?
	  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
	    return last_chars2;
	  }
	  // Add the remaining character length.
	  return last_chars2 + (loc - last_chars1);
	};
	
	
	/**
	 * Convert a diff array into a pretty HTML report.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @return {string} HTML representation.
	 */
	diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
	  var html = [];
	  var pattern_amp = /&/g;
	  var pattern_lt = /</g;
	  var pattern_gt = />/g;
	  var pattern_para = /\n/g;
	  for (var x = 0; x < diffs.length; x++) {
	    var op = diffs[x][0];    // Operation (insert, delete, equal)
	    var data = diffs[x][1];  // Text of change.
	    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')
	        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
	    switch (op) {
	      case DIFF_INSERT:
	        html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
	        break;
	      case DIFF_DELETE:
	        html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
	        break;
	      case DIFF_EQUAL:
	        html[x] = '<span>' + text + '</span>';
	        break;
	    }
	  }
	  return html.join('');
	};
	
	
	/**
	 * Compute and return the source text (all equalities and deletions).
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @return {string} Source text.
	 */
	diff_match_patch.prototype.diff_text1 = function(diffs) {
	  var text = [];
	  for (var x = 0; x < diffs.length; x++) {
	    if (diffs[x][0] !== DIFF_INSERT) {
	      text[x] = diffs[x][1];
	    }
	  }
	  return text.join('');
	};
	
	
	/**
	 * Compute and return the destination text (all equalities and insertions).
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @return {string} Destination text.
	 */
	diff_match_patch.prototype.diff_text2 = function(diffs) {
	  var text = [];
	  for (var x = 0; x < diffs.length; x++) {
	    if (diffs[x][0] !== DIFF_DELETE) {
	      text[x] = diffs[x][1];
	    }
	  }
	  return text.join('');
	};
	
	
	/**
	 * Compute the Levenshtein distance; the number of inserted, deleted or
	 * substituted characters.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @return {number} Number of changes.
	 */
	diff_match_patch.prototype.diff_levenshtein = function(diffs) {
	  var levenshtein = 0;
	  var insertions = 0;
	  var deletions = 0;
	  for (var x = 0; x < diffs.length; x++) {
	    var op = diffs[x][0];
	    var data = diffs[x][1];
	    switch (op) {
	      case DIFF_INSERT:
	        insertions += data.length;
	        break;
	      case DIFF_DELETE:
	        deletions += data.length;
	        break;
	      case DIFF_EQUAL:
	        // A deletion and an insertion is one substitution.
	        levenshtein += Math.max(insertions, deletions);
	        insertions = 0;
	        deletions = 0;
	        break;
	    }
	  }
	  levenshtein += Math.max(insertions, deletions);
	  return levenshtein;
	};
	
	
	/**
	 * Crush the diff into an encoded string which describes the operations
	 * required to transform text1 into text2.
	 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
	 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
	 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
	 * @return {string} Delta text.
	 */
	diff_match_patch.prototype.diff_toDelta = function(diffs) {
	  var text = [];
	  for (var x = 0; x < diffs.length; x++) {
	    switch (diffs[x][0]) {
	      case DIFF_INSERT:
	        text[x] = '+' + encodeURI(diffs[x][1]);
	        break;
	      case DIFF_DELETE:
	        text[x] = '-' + diffs[x][1].length;
	        break;
	      case DIFF_EQUAL:
	        text[x] = '=' + diffs[x][1].length;
	        break;
	    }
	  }
	  return text.join('\t').replace(/%20/g, ' ');
	};
	
	
	/**
	 * Given the original text1, and an encoded string which describes the
	 * operations required to transform text1 into text2, compute the full diff.
	 * @param {string} text1 Source string for the diff.
	 * @param {string} delta Delta text.
	 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
	 * @throws {!Error} If invalid input.
	 */
	diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
	  var diffs = [];
	  var diffsLength = 0;  // Keeping our own length var is faster in JS.
	  var pointer = 0;  // Cursor in text1
	  var tokens = delta.split(/\t/g);
	  for (var x = 0; x < tokens.length; x++) {
	    // Each token begins with a one character parameter which specifies the
	    // operation of this token (delete, insert, equality).
	    var param = tokens[x].substring(1);
	    switch (tokens[x].charAt(0)) {
	      case '+':
	        try {
	          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
	        } catch (ex) {
	          // Malformed URI sequence.
	          throw new Error('Illegal escape in diff_fromDelta: ' + param);
	        }
	        break;
	      case '-':
	        // Fall through.
	      case '=':
	        var n = parseInt(param, 10);
	        if (isNaN(n) || n < 0) {
	          throw new Error('Invalid number in diff_fromDelta: ' + param);
	        }
	        var text = text1.substring(pointer, pointer += n);
	        if (tokens[x].charAt(0) == '=') {
	          diffs[diffsLength++] = [DIFF_EQUAL, text];
	        } else {
	          diffs[diffsLength++] = [DIFF_DELETE, text];
	        }
	        break;
	      default:
	        // Blank tokens are ok (from a trailing \t).
	        // Anything else is an error.
	        if (tokens[x]) {
	          throw new Error('Invalid diff operation in diff_fromDelta: ' +
	                          tokens[x]);
	        }
	    }
	  }
	  if (pointer != text1.length) {
	    throw new Error('Delta length (' + pointer +
	        ') does not equal source text length (' + text1.length + ').');
	  }
	  return diffs;
	};
	
	
	//  MATCH FUNCTIONS
	
	
	/**
	 * Locate the best instance of 'pattern' in 'text' near 'loc'.
	 * @param {string} text The text to search.
	 * @param {string} pattern The pattern to search for.
	 * @param {number} loc The location to search around.
	 * @return {number} Best match index or -1.
	 */
	diff_match_patch.prototype.match_main = function(text, pattern, loc) {
	  // Check for null inputs.
	  if (text == null || pattern == null || loc == null) {
	    throw new Error('Null input. (match_main)');
	  }
	
	  loc = Math.max(0, Math.min(loc, text.length));
	  if (text == pattern) {
	    // Shortcut (potentially not guaranteed by the algorithm)
	    return 0;
	  } else if (!text.length) {
	    // Nothing to match.
	    return -1;
	  } else if (text.substring(loc, loc + pattern.length) == pattern) {
	    // Perfect match at the perfect spot!  (Includes case of null pattern)
	    return loc;
	  } else {
	    // Do a fuzzy compare.
	    return this.match_bitap_(text, pattern, loc);
	  }
	};
	
	
	/**
	 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
	 * Bitap algorithm.
	 * @param {string} text The text to search.
	 * @param {string} pattern The pattern to search for.
	 * @param {number} loc The location to search around.
	 * @return {number} Best match index or -1.
	 * @private
	 */
	diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
	  if (pattern.length > this.Match_MaxBits) {
	    throw new Error('Pattern too long for this browser.');
	  }
	
	  // Initialise the alphabet.
	  var s = this.match_alphabet_(pattern);
	
	  var dmp = this;  // 'this' becomes 'window' in a closure.
	
	  /**
	   * Compute and return the score for a match with e errors and x location.
	   * Accesses loc and pattern through being a closure.
	   * @param {number} e Number of errors in match.
	   * @param {number} x Location of match.
	   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
	   * @private
	   */
	  function match_bitapScore_(e, x) {
	    var accuracy = e / pattern.length;
	    var proximity = Math.abs(loc - x);
	    if (!dmp.Match_Distance) {
	      // Dodge divide by zero error.
	      return proximity ? 1.0 : accuracy;
	    }
	    return accuracy + (proximity / dmp.Match_Distance);
	  }
	
	  // Highest score beyond which we give up.
	  var score_threshold = this.Match_Threshold;
	  // Is there a nearby exact match? (speedup)
	  var best_loc = text.indexOf(pattern, loc);
	  if (best_loc != -1) {
	    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
	    // What about in the other direction? (speedup)
	    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
	    if (best_loc != -1) {
	      score_threshold =
	          Math.min(match_bitapScore_(0, best_loc), score_threshold);
	    }
	  }
	
	  // Initialise the bit arrays.
	  var matchmask = 1 << (pattern.length - 1);
	  best_loc = -1;
	
	  var bin_min, bin_mid;
	  var bin_max = pattern.length + text.length;
	  var last_rd;
	  for (var d = 0; d < pattern.length; d++) {
	    // Scan for the best match; each iteration allows for one more error.
	    // Run a binary search to determine how far from 'loc' we can stray at this
	    // error level.
	    bin_min = 0;
	    bin_mid = bin_max;
	    while (bin_min < bin_mid) {
	      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
	        bin_min = bin_mid;
	      } else {
	        bin_max = bin_mid;
	      }
	      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
	    }
	    // Use the result from this iteration as the maximum for the next.
	    bin_max = bin_mid;
	    var start = Math.max(1, loc - bin_mid + 1);
	    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;
	
	    var rd = Array(finish + 2);
	    rd[finish + 1] = (1 << d) - 1;
	    for (var j = finish; j >= start; j--) {
	      // The alphabet (s) is a sparse hash, so the following line generates
	      // warnings.
	      var charMatch = s[text.charAt(j - 1)];
	      if (d === 0) {  // First pass: exact match.
	        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
	      } else {  // Subsequent passes: fuzzy match.
	        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |
	                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
	                last_rd[j + 1];
	      }
	      if (rd[j] & matchmask) {
	        var score = match_bitapScore_(d, j - 1);
	        // This match will almost certainly be better than any existing match.
	        // But check anyway.
	        if (score <= score_threshold) {
	          // Told you so.
	          score_threshold = score;
	          best_loc = j - 1;
	          if (best_loc > loc) {
	            // When passing loc, don't exceed our current distance from loc.
	            start = Math.max(1, 2 * loc - best_loc);
	          } else {
	            // Already passed loc, downhill from here on in.
	            break;
	          }
	        }
	      }
	    }
	    // No hope for a (better) match at greater error levels.
	    if (match_bitapScore_(d + 1, loc) > score_threshold) {
	      break;
	    }
	    last_rd = rd;
	  }
	  return best_loc;
	};
	
	
	/**
	 * Initialise the alphabet for the Bitap algorithm.
	 * @param {string} pattern The text to encode.
	 * @return {!Object} Hash of character locations.
	 * @private
	 */
	diff_match_patch.prototype.match_alphabet_ = function(pattern) {
	  var s = {};
	  for (var i = 0; i < pattern.length; i++) {
	    s[pattern.charAt(i)] = 0;
	  }
	  for (var i = 0; i < pattern.length; i++) {
	    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
	  }
	  return s;
	};
	
	
	//  PATCH FUNCTIONS
	
	
	/**
	 * Increase the context until it is unique,
	 * but don't let the pattern expand beyond Match_MaxBits.
	 * @param {!diff_match_patch.patch_obj} patch The patch to grow.
	 * @param {string} text Source text.
	 * @private
	 */
	diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
	  if (text.length == 0) {
	    return;
	  }
	  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
	  var padding = 0;
	
	  // Look for the first and last matches of pattern in text.  If two different
	  // matches are found, increase the pattern length.
	  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
	         pattern.length < this.Match_MaxBits - this.Patch_Margin -
	         this.Patch_Margin) {
	    padding += this.Patch_Margin;
	    pattern = text.substring(patch.start2 - padding,
	                             patch.start2 + patch.length1 + padding);
	  }
	  // Add one chunk for good luck.
	  padding += this.Patch_Margin;
	
	  // Add the prefix.
	  var prefix = text.substring(patch.start2 - padding, patch.start2);
	  if (prefix) {
	    patch.diffs.unshift([DIFF_EQUAL, prefix]);
	  }
	  // Add the suffix.
	  var suffix = text.substring(patch.start2 + patch.length1,
	                              patch.start2 + patch.length1 + padding);
	  if (suffix) {
	    patch.diffs.push([DIFF_EQUAL, suffix]);
	  }
	
	  // Roll back the start points.
	  patch.start1 -= prefix.length;
	  patch.start2 -= prefix.length;
	  // Extend the lengths.
	  patch.length1 += prefix.length + suffix.length;
	  patch.length2 += prefix.length + suffix.length;
	};
	
	
	/**
	 * Compute a list of patches to turn text1 into text2.
	 * Use diffs if provided, otherwise compute it ourselves.
	 * There are four ways to call this function, depending on what data is
	 * available to the caller:
	 * Method 1:
	 * a = text1, b = text2
	 * Method 2:
	 * a = diffs
	 * Method 3 (optimal):
	 * a = text1, b = diffs
	 * Method 4 (deprecated, use method 3):
	 * a = text1, b = text2, c = diffs
	 *
	 * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
	 * Array of diff tuples for text1 to text2 (method 2).
	 * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or
	 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
	 * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples
	 * for text1 to text2 (method 4) or undefined (methods 1,2,3).
	 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
	 */
	diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
	  var text1, diffs;
	  if (typeof a == 'string' && typeof opt_b == 'string' &&
	      typeof opt_c == 'undefined') {
	    // Method 1: text1, text2
	    // Compute diffs from text1 and text2.
	    text1 = /** @type {string} */(a);
	    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);
	    if (diffs.length > 2) {
	      this.diff_cleanupSemantic(diffs);
	      this.diff_cleanupEfficiency(diffs);
	    }
	  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
	      typeof opt_c == 'undefined') {
	    // Method 2: diffs
	    // Compute text1 from diffs.
	    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
	    text1 = this.diff_text1(diffs);
	  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
	      typeof opt_c == 'undefined') {
	    // Method 3: text1, diffs
	    text1 = /** @type {string} */(a);
	    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);
	  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
	      opt_c && typeof opt_c == 'object') {
	    // Method 4: text1, text2, diffs
	    // text2 is not used.
	    text1 = /** @type {string} */(a);
	    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);
	  } else {
	    throw new Error('Unknown call format to patch_make.');
	  }
	
	  if (diffs.length === 0) {
	    return [];  // Get rid of the null case.
	  }
	  var patches = [];
	  var patch = new diff_match_patch.patch_obj();
	  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
	  var char_count1 = 0;  // Number of characters into the text1 string.
	  var char_count2 = 0;  // Number of characters into the text2 string.
	  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
	  // text2 (postpatch_text).  We recreate the patches one by one to determine
	  // context info.
	  var prepatch_text = text1;
	  var postpatch_text = text1;
	  for (var x = 0; x < diffs.length; x++) {
	    var diff_type = diffs[x][0];
	    var diff_text = diffs[x][1];
	
	    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
	      // A new patch starts here.
	      patch.start1 = char_count1;
	      patch.start2 = char_count2;
	    }
	
	    switch (diff_type) {
	      case DIFF_INSERT:
	        patch.diffs[patchDiffLength++] = diffs[x];
	        patch.length2 += diff_text.length;
	        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
	                         postpatch_text.substring(char_count2);
	        break;
	      case DIFF_DELETE:
	        patch.length1 += diff_text.length;
	        patch.diffs[patchDiffLength++] = diffs[x];
	        postpatch_text = postpatch_text.substring(0, char_count2) +
	                         postpatch_text.substring(char_count2 +
	                             diff_text.length);
	        break;
	      case DIFF_EQUAL:
	        if (diff_text.length <= 2 * this.Patch_Margin &&
	            patchDiffLength && diffs.length != x + 1) {
	          // Small equality inside a patch.
	          patch.diffs[patchDiffLength++] = diffs[x];
	          patch.length1 += diff_text.length;
	          patch.length2 += diff_text.length;
	        } else if (diff_text.length >= 2 * this.Patch_Margin) {
	          // Time for a new patch.
	          if (patchDiffLength) {
	            this.patch_addContext_(patch, prepatch_text);
	            patches.push(patch);
	            patch = new diff_match_patch.patch_obj();
	            patchDiffLength = 0;
	            // Unlike Unidiff, our patch lists have a rolling context.
	            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
	            // Update prepatch text & pos to reflect the application of the
	            // just completed patch.
	            prepatch_text = postpatch_text;
	            char_count1 = char_count2;
	          }
	        }
	        break;
	    }
	
	    // Update the current character count.
	    if (diff_type !== DIFF_INSERT) {
	      char_count1 += diff_text.length;
	    }
	    if (diff_type !== DIFF_DELETE) {
	      char_count2 += diff_text.length;
	    }
	  }
	  // Pick up the leftover patch if not empty.
	  if (patchDiffLength) {
	    this.patch_addContext_(patch, prepatch_text);
	    patches.push(patch);
	  }
	
	  return patches;
	};
	
	
	/**
	 * Given an array of patches, return another array that is identical.
	 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
	 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
	 */
	diff_match_patch.prototype.patch_deepCopy = function(patches) {
	  // Making deep copies is hard in JavaScript.
	  var patchesCopy = [];
	  for (var x = 0; x < patches.length; x++) {
	    var patch = patches[x];
	    var patchCopy = new diff_match_patch.patch_obj();
	    patchCopy.diffs = [];
	    for (var y = 0; y < patch.diffs.length; y++) {
	      patchCopy.diffs[y] = patch.diffs[y].slice();
	    }
	    patchCopy.start1 = patch.start1;
	    patchCopy.start2 = patch.start2;
	    patchCopy.length1 = patch.length1;
	    patchCopy.length2 = patch.length2;
	    patchesCopy[x] = patchCopy;
	  }
	  return patchesCopy;
	};
	
	
	/**
	 * Merge a set of patches onto the text.  Return a patched text, as well
	 * as a list of true/false values indicating which patches were applied.
	 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
	 * @param {string} text Old text.
	 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
	 *      new text and an array of boolean values.
	 */
	diff_match_patch.prototype.patch_apply = function(patches, text) {
	  if (patches.length == 0) {
	    return [text, []];
	  }
	
	  // Deep copy the patches so that no changes are made to originals.
	  patches = this.patch_deepCopy(patches);
	
	  var nullPadding = this.patch_addPadding(patches);
	  text = nullPadding + text + nullPadding;
	
	  this.patch_splitMax(patches);
	  // delta keeps track of the offset between the expected and actual location
	  // of the previous patch.  If there are patches expected at positions 10 and
	  // 20, but the first patch was found at 12, delta is 2 and the second patch
	  // has an effective expected position of 22.
	  var delta = 0;
	  var results = [];
	  for (var x = 0; x < patches.length; x++) {
	    var expected_loc = patches[x].start2 + delta;
	    var text1 = this.diff_text1(patches[x].diffs);
	    var start_loc;
	    var end_loc = -1;
	    if (text1.length > this.Match_MaxBits) {
	      // patch_splitMax will only provide an oversized pattern in the case of
	      // a monster delete.
	      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
	                                  expected_loc);
	      if (start_loc != -1) {
	        end_loc = this.match_main(text,
	            text1.substring(text1.length - this.Match_MaxBits),
	            expected_loc + text1.length - this.Match_MaxBits);
	        if (end_loc == -1 || start_loc >= end_loc) {
	          // Can't find valid trailing context.  Drop this patch.
	          start_loc = -1;
	        }
	      }
	    } else {
	      start_loc = this.match_main(text, text1, expected_loc);
	    }
	    if (start_loc == -1) {
	      // No match found.  :(
	      results[x] = false;
	      // Subtract the delta for this failed patch from subsequent patches.
	      delta -= patches[x].length2 - patches[x].length1;
	    } else {
	      // Found a match.  :)
	      results[x] = true;
	      delta = start_loc - expected_loc;
	      var text2;
	      if (end_loc == -1) {
	        text2 = text.substring(start_loc, start_loc + text1.length);
	      } else {
	        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
	      }
	      if (text1 == text2) {
	        // Perfect match, just shove the replacement text in.
	        text = text.substring(0, start_loc) +
	               this.diff_text2(patches[x].diffs) +
	               text.substring(start_loc + text1.length);
	      } else {
	        // Imperfect match.  Run a diff to get a framework of equivalent
	        // indices.
	        var diffs = this.diff_main(text1, text2, false);
	        if (text1.length > this.Match_MaxBits &&
	            this.diff_levenshtein(diffs) / text1.length >
	            this.Patch_DeleteThreshold) {
	          // The end points match, but the content is unacceptably bad.
	          results[x] = false;
	        } else {
	          this.diff_cleanupSemanticLossless(diffs);
	          var index1 = 0;
	          var index2;
	          for (var y = 0; y < patches[x].diffs.length; y++) {
	            var mod = patches[x].diffs[y];
	            if (mod[0] !== DIFF_EQUAL) {
	              index2 = this.diff_xIndex(diffs, index1);
	            }
	            if (mod[0] === DIFF_INSERT) {  // Insertion
	              text = text.substring(0, start_loc + index2) + mod[1] +
	                     text.substring(start_loc + index2);
	            } else if (mod[0] === DIFF_DELETE) {  // Deletion
	              text = text.substring(0, start_loc + index2) +
	                     text.substring(start_loc + this.diff_xIndex(diffs,
	                         index1 + mod[1].length));
	            }
	            if (mod[0] !== DIFF_DELETE) {
	              index1 += mod[1].length;
	            }
	          }
	        }
	      }
	    }
	  }
	  // Strip the padding off.
	  text = text.substring(nullPadding.length, text.length - nullPadding.length);
	  return [text, results];
	};
	
	
	/**
	 * Add some padding on text start and end so that edges can match something.
	 * Intended to be called only from within patch_apply.
	 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
	 * @return {string} The padding string added to each side.
	 */
	diff_match_patch.prototype.patch_addPadding = function(patches) {
	  var paddingLength = this.Patch_Margin;
	  var nullPadding = '';
	  for (var x = 1; x <= paddingLength; x++) {
	    nullPadding += String.fromCharCode(x);
	  }
	
	  // Bump all the patches forward.
	  for (var x = 0; x < patches.length; x++) {
	    patches[x].start1 += paddingLength;
	    patches[x].start2 += paddingLength;
	  }
	
	  // Add some padding on start of first diff.
	  var patch = patches[0];
	  var diffs = patch.diffs;
	  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
	    // Add nullPadding equality.
	    diffs.unshift([DIFF_EQUAL, nullPadding]);
	    patch.start1 -= paddingLength;  // Should be 0.
	    patch.start2 -= paddingLength;  // Should be 0.
	    patch.length1 += paddingLength;
	    patch.length2 += paddingLength;
	  } else if (paddingLength > diffs[0][1].length) {
	    // Grow first equality.
	    var extraLength = paddingLength - diffs[0][1].length;
	    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
	    patch.start1 -= extraLength;
	    patch.start2 -= extraLength;
	    patch.length1 += extraLength;
	    patch.length2 += extraLength;
	  }
	
	  // Add some padding on end of last diff.
	  patch = patches[patches.length - 1];
	  diffs = patch.diffs;
	  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
	    // Add nullPadding equality.
	    diffs.push([DIFF_EQUAL, nullPadding]);
	    patch.length1 += paddingLength;
	    patch.length2 += paddingLength;
	  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
	    // Grow last equality.
	    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
	    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
	    patch.length1 += extraLength;
	    patch.length2 += extraLength;
	  }
	
	  return nullPadding;
	};
	
	
	/**
	 * Look through the patches and break up any which are longer than the maximum
	 * limit of the match algorithm.
	 * Intended to be called only from within patch_apply.
	 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
	 */
	diff_match_patch.prototype.patch_splitMax = function(patches) {
	  var patch_size = this.Match_MaxBits;
	  for (var x = 0; x < patches.length; x++) {
	    if (patches[x].length1 <= patch_size) {
	      continue;
	    }
	    var bigpatch = patches[x];
	    // Remove the big old patch.
	    patches.splice(x--, 1);
	    var start1 = bigpatch.start1;
	    var start2 = bigpatch.start2;
	    var precontext = '';
	    while (bigpatch.diffs.length !== 0) {
	      // Create one of several smaller patches.
	      var patch = new diff_match_patch.patch_obj();
	      var empty = true;
	      patch.start1 = start1 - precontext.length;
	      patch.start2 = start2 - precontext.length;
	      if (precontext !== '') {
	        patch.length1 = patch.length2 = precontext.length;
	        patch.diffs.push([DIFF_EQUAL, precontext]);
	      }
	      while (bigpatch.diffs.length !== 0 &&
	             patch.length1 < patch_size - this.Patch_Margin) {
	        var diff_type = bigpatch.diffs[0][0];
	        var diff_text = bigpatch.diffs[0][1];
	        if (diff_type === DIFF_INSERT) {
	          // Insertions are harmless.
	          patch.length2 += diff_text.length;
	          start2 += diff_text.length;
	          patch.diffs.push(bigpatch.diffs.shift());
	          empty = false;
	        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
	                   patch.diffs[0][0] == DIFF_EQUAL &&
	                   diff_text.length > 2 * patch_size) {
	          // This is a large deletion.  Let it pass in one chunk.
	          patch.length1 += diff_text.length;
	          start1 += diff_text.length;
	          empty = false;
	          patch.diffs.push([diff_type, diff_text]);
	          bigpatch.diffs.shift();
	        } else {
	          // Deletion or equality.  Only take as much as we can stomach.
	          diff_text = diff_text.substring(0,
	              patch_size - patch.length1 - this.Patch_Margin);
	          patch.length1 += diff_text.length;
	          start1 += diff_text.length;
	          if (diff_type === DIFF_EQUAL) {
	            patch.length2 += diff_text.length;
	            start2 += diff_text.length;
	          } else {
	            empty = false;
	          }
	          patch.diffs.push([diff_type, diff_text]);
	          if (diff_text == bigpatch.diffs[0][1]) {
	            bigpatch.diffs.shift();
	          } else {
	            bigpatch.diffs[0][1] =
	                bigpatch.diffs[0][1].substring(diff_text.length);
	          }
	        }
	      }
	      // Compute the head context for the next patch.
	      precontext = this.diff_text2(patch.diffs);
	      precontext =
	          precontext.substring(precontext.length - this.Patch_Margin);
	      // Append the end context for this patch.
	      var postcontext = this.diff_text1(bigpatch.diffs)
	                            .substring(0, this.Patch_Margin);
	      if (postcontext !== '') {
	        patch.length1 += postcontext.length;
	        patch.length2 += postcontext.length;
	        if (patch.diffs.length !== 0 &&
	            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
	          patch.diffs[patch.diffs.length - 1][1] += postcontext;
	        } else {
	          patch.diffs.push([DIFF_EQUAL, postcontext]);
	        }
	      }
	      if (!empty) {
	        patches.splice(++x, 0, patch);
	      }
	    }
	  }
	};
	
	
	/**
	 * Take a list of patches and return a textual representation.
	 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
	 * @return {string} Text representation of patches.
	 */
	diff_match_patch.prototype.patch_toText = function(patches) {
	  var text = [];
	  for (var x = 0; x < patches.length; x++) {
	    text[x] = patches[x];
	  }
	  return text.join('');
	};
	
	
	/**
	 * Parse a textual representation of patches and return a list of Patch objects.
	 * @param {string} textline Text representation of patches.
	 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
	 * @throws {!Error} If invalid input.
	 */
	diff_match_patch.prototype.patch_fromText = function(textline) {
	  var patches = [];
	  if (!textline) {
	    return patches;
	  }
	  var text = textline.split('\n');
	  var textPointer = 0;
	  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
	  while (textPointer < text.length) {
	    var m = text[textPointer].match(patchHeader);
	    if (!m) {
	      throw new Error('Invalid patch string: ' + text[textPointer]);
	    }
	    var patch = new diff_match_patch.patch_obj();
	    patches.push(patch);
	    patch.start1 = parseInt(m[1], 10);
	    if (m[2] === '') {
	      patch.start1--;
	      patch.length1 = 1;
	    } else if (m[2] == '0') {
	      patch.length1 = 0;
	    } else {
	      patch.start1--;
	      patch.length1 = parseInt(m[2], 10);
	    }
	
	    patch.start2 = parseInt(m[3], 10);
	    if (m[4] === '') {
	      patch.start2--;
	      patch.length2 = 1;
	    } else if (m[4] == '0') {
	      patch.length2 = 0;
	    } else {
	      patch.start2--;
	      patch.length2 = parseInt(m[4], 10);
	    }
	    textPointer++;
	
	    while (textPointer < text.length) {
	      var sign = text[textPointer].charAt(0);
	      try {
	        var line = decodeURI(text[textPointer].substring(1));
	      } catch (ex) {
	        // Malformed URI sequence.
	        throw new Error('Illegal escape in patch_fromText: ' + line);
	      }
	      if (sign == '-') {
	        // Deletion.
	        patch.diffs.push([DIFF_DELETE, line]);
	      } else if (sign == '+') {
	        // Insertion.
	        patch.diffs.push([DIFF_INSERT, line]);
	      } else if (sign == ' ') {
	        // Minor equality.
	        patch.diffs.push([DIFF_EQUAL, line]);
	      } else if (sign == '@') {
	        // Start of next patch.
	        break;
	      } else if (sign === '') {
	        // Blank line?  Whatever.
	      } else {
	        // WTF?
	        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
	      }
	      textPointer++;
	    }
	  }
	  return patches;
	};
	
	
	/**
	 * Class representing one patch operation.
	 * @constructor
	 */
	diff_match_patch.patch_obj = function() {
	  /** @type {!Array.<!diff_match_patch.Diff>} */
	  this.diffs = [];
	  /** @type {?number} */
	  this.start1 = null;
	  /** @type {?number} */
	  this.start2 = null;
	  /** @type {number} */
	  this.length1 = 0;
	  /** @type {number} */
	  this.length2 = 0;
	};
	
	
	/**
	 * Emmulate GNU diff's format.
	 * Header: @@ -382,8 +481,9 @@
	 * Indicies are printed as 1-based, not 0-based.
	 * @return {string} The GNU diff string.
	 */
	diff_match_patch.patch_obj.prototype.toString = function() {
	  var coords1, coords2;
	  if (this.length1 === 0) {
	    coords1 = this.start1 + ',0';
	  } else if (this.length1 == 1) {
	    coords1 = this.start1 + 1;
	  } else {
	    coords1 = (this.start1 + 1) + ',' + this.length1;
	  }
	  if (this.length2 === 0) {
	    coords2 = this.start2 + ',0';
	  } else if (this.length2 == 1) {
	    coords2 = this.start2 + 1;
	  } else {
	    coords2 = (this.start2 + 1) + ',' + this.length2;
	  }
	  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
	  var op;
	  // Escape the body of the patch with %xx notation.
	  for (var x = 0; x < this.diffs.length; x++) {
	    switch (this.diffs[x][0]) {
	      case DIFF_INSERT:
	        op = '+';
	        break;
	      case DIFF_DELETE:
	        op = '-';
	        break;
	      case DIFF_EQUAL:
	        op = ' ';
	        break;
	    }
	    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
	  }
	  return text.join('').replace(/%20/g, ' ');
	};
	
	
	// The following export code was added by @ForbesLindesay
	module.exports = diff_match_patch;
	module.exports['diff_match_patch'] = diff_match_patch;
	module.exports['DIFF_DELETE'] = DIFF_DELETE;
	module.exports['DIFF_INSERT'] = DIFF_INSERT;
	module.exports['DIFF_EQUAL'] = DIFF_EQUAL;


/***/ },
/* 426 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ToolManager = exports.ToolManager = function () {
	  function ToolManager(viewer, defaultTool) {
	    var _this = this;
	
	    _classCallCheck(this, ToolManager);
	
	    this.defaultTool = defaultTool;
	    this.tool = defaultTool;
	    this.viewer = viewer;
	    var canvas = viewer.canvas;
	    canvas.addEventListener('mousemove', function (e) {
	      e.preventDefault();
	      //e.stopPropagation(); // allow propagation for move in sake of dynamic layout 
	      _this.tool.mousemove(e);
	    }, false);
	    canvas.addEventListener('mousedown', function (e) {
	      e.preventDefault();
	      e.stopPropagation();
	      _this.tool.mousedown(e);
	    }, false);
	    canvas.addEventListener('mouseup', function (e) {
	      e.preventDefault();
	      e.stopPropagation();
	      _this.tool.mouseup(e);
	    }, false);
	    canvas.addEventListener('mousewheel', function (e) {
	      e.preventDefault();
	      e.stopPropagation();
	      var tool = _this.tool;
	      if (tool.mousewheel === undefined) {
	        tool = _this.defaultTool;
	      }
	      if (tool.mousewheel !== undefined) {
	        tool.mousewheel(e);
	      }
	    }, false);
	    canvas.addEventListener('dblclick', function (e) {
	      e.preventDefault();
	      e.stopPropagation();
	      _this.tool.dblclick(e);
	    }, false);
	
	    window.addEventListener("keydown", function (e) {
	      _this.tool.keydown(e);
	      if (e.keyCode == 27) {
	        _this.releaseControl();
	      } else if (e.keyCode == 46 || e.keyCode == 8) {
	        var selection = viewer.selected.slice();
	        viewer.deselectAll();
	        for (var i = 0; i < selection.length; i++) {
	          viewer.remove(selection[i]);
	        }
	        viewer.refresh();
	      }
	    }, false);
	    window.addEventListener("keypress", function (e) {
	      _this.tool.keydown(e);
	    }, false);
	    window.addEventListener("keyup", function (e) {
	      _this.tool.keydown(e);
	    }, false);
	  }
	
	  _createClass(ToolManager, [{
	    key: 'takeControl',
	    value: function takeControl(tool) {
	      this.tool.cleanup();
	      this.switchTool(tool);
	      this.tool.restart();
	    }
	  }, {
	    key: 'switchTool',
	    value: function switchTool(tool) {
	      this.tool = tool;
	      this.viewer.bus.notify("tool-change");
	    }
	  }, {
	    key: 'releaseControl',
	    value: function releaseControl() {
	      this.takeControl(this.defaultTool);
	    }
	  }]);

	  return ToolManager;
	}();

/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.PanTool = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _tool = __webpack_require__(428);
	
	var _editToolsMap = __webpack_require__(433);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var PanTool = exports.PanTool = function (_Tool) {
	  _inherits(PanTool, _Tool);
	
	  function PanTool(viewer) {
	    _classCallCheck(this, PanTool);
	
	    var _this = _possibleConstructorReturn(this, (PanTool.__proto__ || Object.getPrototypeOf(PanTool)).call(this, 'pan', viewer));
	
	    _this.dragging = false;
	    _this.x = 0.0;
	    _this.y = 0.0;
	    return _this;
	  }
	
	  _createClass(PanTool, [{
	    key: 'mousemove',
	    value: function mousemove(e) {
	      if (!this.dragging) {
	        return;
	      }
	      var dx = e.pageX - this.x;
	      var dy = e.pageY - this.y;
	      dy *= -1;
	
	      this.viewer.translate.x += dx * this.viewer.retinaPxielRatio;
	      this.viewer.translate.y += dy * this.viewer.retinaPxielRatio;
	
	      this.x = e.pageX;
	      this.y = e.pageY;
	      this.deselectOnUp = false;
	      this.viewer.refresh();
	    }
	  }, {
	    key: 'mousedown',
	    value: function mousedown(e) {
	      if (e.button == 0) {
	        var picked = this.viewer.pick(e);
	        var i;
	        if (picked.length > 0) {
	          var toSelect;
	          if (e.shiftKey) {
	            toSelect = picked[0];
	            var ids = this.viewer.selected.map(function (s) {
	              return s.id;
	            });
	            for (i = 0; i < picked.length; i++) {
	              if (ids.indexOf(picked[i].id) != -1) {
	                this.viewer.deselect(picked[i]);
	              } else {
	                toSelect = picked[i];
	              }
	            }
	            this.viewer.select([toSelect], false);
	            this.deselectOnUp = false;
	          } else {
	            toSelect = picked[0];
	            if (this.viewer.selected.length === 1) {
	              for (i = 0; i < picked.length - 1; i++) {
	                if (picked[i].id == this.viewer.selected[0].id) {
	                  toSelect = picked[i + 1];
	                  break;
	                }
	              }
	            }
	            this.viewer.select([toSelect], true);
	            if (!toSelect.isAuxOrLinkedTo()) {
	              var tool = (0, _editToolsMap.GetShapeEditTool)(this.viewer, toSelect, e.altKey);
	              tool.mousedown(e);
	              this.viewer.toolManager.switchTool(tool);
	            }
	          }
	          this.viewer.refresh();
	          return;
	        }
	      }
	
	      this.dragging = true;
	      this.deselectOnUp = true;
	      this.x = e.pageX;
	      this.y = e.pageY;
	    }
	  }, {
	    key: 'mouseup',
	    value: function mouseup(e) {
	      this.dragging = false;
	      if (this.deselectOnUp) {
	        this.viewer.deselectAll();
	        this.viewer.refresh();
	      }
	      this.deselectOnUp = false;
	    }
	  }, {
	    key: 'mousewheel',
	    value: function mousewheel(e) {
	
	      var delta = 0;
	
	      if (e.wheelDelta) {
	        // WebKit / Opera / Explorer 9
	        delta = e.wheelDelta;
	      } else if (e.detail) {
	        // Firefox
	        delta = -e.detail;
	      }
	
	      var before = this.viewer.screenToModel(e);
	
	      var step = 0.05;
	      delta = delta < 0 ? 1 - step : 1 + step;
	      this.viewer.scale *= delta;
	
	      var after = this.viewer.screenToModel(e);
	
	      var dx = after.x - before.x;
	      var dy = after.y - before.y;
	
	      this.viewer.translate.x += dx * this.viewer.scale;
	      this.viewer.translate.y += dy * this.viewer.scale;
	
	      this.viewer.refresh();
	    }
	  }]);

	  return PanTool;
	}(_tool.Tool);

/***/ },
/* 428 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Tool = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _point = __webpack_require__(429);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Tool = exports.Tool = function () {
	  function Tool(name, viewer) {
	    _classCallCheck(this, Tool);
	
	    this.name = name;
	    this.viewer = viewer;
	  }
	
	  _createClass(Tool, [{
	    key: 'restart',
	    value: function restart() {}
	  }, {
	    key: 'cleanup',
	    value: function cleanup() {}
	  }, {
	    key: 'mousemove',
	    value: function mousemove(e) {}
	  }, {
	    key: 'mousedown',
	    value: function mousedown(e) {}
	  }, {
	    key: 'mouseup',
	    value: function mouseup(e) {}
	  }, {
	    key: 'dblclick',
	    value: function dblclick(e) {}
	  }, {
	    key: 'keydown',
	    value: function keydown(e) {}
	  }, {
	    key: 'keypress',
	    value: function keypress(e) {}
	  }, {
	    key: 'keyup',
	    value: function keyup(e) {}
	  }, {
	    key: 'sendMessage',
	    value: function sendMessage(text) {
	      this.viewer.bus.notify('tool-message', text);
	    }
	  }, {
	    key: 'sendHint',
	    value: function sendHint(hint) {
	      this.viewer.bus.notify('tool-hint', hint);
	    }
	  }, {
	    key: 'sendSpecifyPointHint',
	    value: function sendSpecifyPointHint() {
	      this.sendHint('specify point');
	    }
	  }, {
	    key: 'pointPicked',
	    value: function pointPicked(x, y) {
	      this.sendMessage('picked: ' + this.viewer.roundToPrecision(x) + " : " + this.viewer.roundToPrecision(y));
	      this.viewer.referencePoint.x = x;
	      this.viewer.referencePoint.y = y;
	    }
	  }, {
	    key: 'snapIfNeed',
	    value: function snapIfNeed(p) {
	      if (this.viewer.snapped != null) {
	        var snapWith = this.viewer.snapped;
	        this.viewer.cleanSnap();
	        p.setFromPoint(snapWith);
	        this.viewer.parametricManager.linkObjects([p, snapWith]);
	        this.viewer.parametricManager.refresh();
	      }
	    }
	  }, {
	    key: 'endpoint',
	    value: function endpoint(e) {
	      var ep = new _point.EndPoint(0, 0);
	      if (this.viewer.snapped != null) {
	        this.snapIfNeed(ep);
	      } else {
	        ep.setFromPoint(this.viewer.screenToModel(e));
	      }
	      return ep;
	    }
	  }], [{
	    key: 'dumbMode',
	    value: function dumbMode(e) {
	      return e.ctrlKey || e.metaKey;
	    }
	  }]);
	
	  return Tool;
	}();
	
	Tool.ParseNumber = function (str) {
	  var val = void 0;
	  try {
	    val = eval(str);
	  } catch (e) {
	    return e.toString();
	  }
	  var valNumber = parseFloat(val);
	  if (isNaN(valNumber)) return "wrong input for number: " + str;
	  return valNumber;
	};
	
	Tool.ParseNumberWithRef = function (str, ref) {
	  var rel = str.startsWith('@');
	  if (rel) {
	    str = str.substring(1);
	  }
	  var val = Tool.ParseNumber(str);
	  if (typeof val === 'string') return val;
	  if (rel) {
	    val += ref;
	  }
	  return val;
	};
	
	var VECTOR_PATTERN = /^(@)?(.+)(,|<)(.+)$/;
	
	Tool.ParseVector = function (referencePoint, command) {
	  command = command.replace(/\s+/g, '');
	
	  var match = command.match(VECTOR_PATTERN);
	  if (match) {
	    var ref = match[1] !== undefined;
	    var x = Tool.ParseNumber(match[2]);
	    if (typeof x === 'string') return x;
	    var polar = match[3] == '<';
	    var y = Tool.ParseNumber(match[4]);
	    if (typeof y === 'string') return y;
	    if (polar) {
	      var angle = y / 180 * Math.PI;
	      var radius = x;
	      x = radius * Math.cos(angle);
	      y = radius * Math.sin(angle);
	    }
	    if (ref) {
	      x += referencePoint.x;
	      y += referencePoint.y;
	    }
	    return { x: x, y: y };
	  }
	
	  return "wrong input, point is expected: x,y | @x,y | r<polar | @r<polar ";
	};
	
	Tool.ParseNumberSequence = function (command, refs, length) {
	  command = command.replace(/\s+/g, '');
	  var parts = command.split(',');
	  var result = [];
	  for (var i = 0; i < parts.length; i++) {
	    var part = parts[i];
	    var val = refs && refs[i] ? Tool.ParseNumberWithRef(part, refs[i]) : Tool.ParseNumberWithRef(part);
	    result.push(val);
	  }
	  if (length !== undefined && result.length != length) {
	    return "wrong input, sequence of length " + length + " is expected: x1,x2...";
	  }
	  return result;
	};

/***/ },
/* 429 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Param = exports.EndPoint = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _sketchObject = __webpack_require__(430);
	
	var _drawUtils = __webpack_require__(432);
	
	var _idGenerator = __webpack_require__(412);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var EndPoint = exports.EndPoint = function (_SketchObject) {
	  _inherits(EndPoint, _SketchObject);
	
	  function EndPoint(x, y) {
	    _classCallCheck(this, EndPoint);
	
	    var _this = _possibleConstructorReturn(this, (EndPoint.__proto__ || Object.getPrototypeOf(EndPoint)).call(this));
	
	    _this.x = x;
	    _this.y = y;
	    _this.parent = null;
	    _this._x = new Param(_this, 'x');
	    _this._y = new Param(_this, 'y');
	    return _this;
	  }
	
	  _createClass(EndPoint, [{
	    key: 'collectParams',
	    value: function collectParams(params) {
	      params.push(this._x);
	      params.push(this._y);
	    }
	  }, {
	    key: 'normalDistance',
	    value: function normalDistance(aim) {
	      return aim.minus(new _vector2.default(this.x, this.y)).length();
	    }
	  }, {
	    key: 'getReferencePoint',
	    value: function getReferencePoint() {
	      return this;
	    }
	  }, {
	    key: 'translateImpl',
	    value: function translateImpl(dx, dy) {
	      this.x += dx;
	      this.y += dy;
	    }
	  }, {
	    key: 'drawImpl',
	    value: function drawImpl(ctx, scale) {
	      (0, _drawUtils.DrawPoint)(ctx, this.x, this.y, 3, scale);
	    }
	  }, {
	    key: 'setXY',
	    value: function setXY(x, y) {
	      this.x = x;
	      this.y = y;
	    }
	  }, {
	    key: 'setFromPoint',
	    value: function setFromPoint(p) {
	      this.setXY(p.x, p.y);
	    }
	  }, {
	    key: 'setFromArray',
	    value: function setFromArray(arr) {
	      this.setXY(arr[0], arr[1]);
	    }
	  }, {
	    key: 'toVector',
	    value: function toVector() {
	      return new _vector2.default(this.x, this.y);
	    }
	  }, {
	    key: 'copy',
	    value: function copy() {
	      return new EndPoint(this.x, this.y);
	    }
	  }]);
	
	  return EndPoint;
	}(_sketchObject.SketchObject);
	
	EndPoint.prototype._class = 'TCAD.TWO.EndPoint';
	
	var Param = exports.Param = function () {
	  function Param(obj, prop) {
	    _classCallCheck(this, Param);
	
	    this.id = _idGenerator.Generator.genID();
	    this.obj = obj;
	    this.prop = prop;
	  }
	
	  _createClass(Param, [{
	    key: 'set',
	    value: function set(value) {
	      this.obj[this.prop] = value;
	    }
	  }, {
	    key: 'get',
	    value: function get() {
	      return this.obj[this.prop];
	    }
	  }]);

	  return Param;
	}();

/***/ },
/* 430 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SketchObject = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _idGenerator = __webpack_require__(412);
	
	var _shape = __webpack_require__(431);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var SketchObject = exports.SketchObject = function (_Shape) {
	  _inherits(SketchObject, _Shape);
	
	  function SketchObject() {
	    _classCallCheck(this, SketchObject);
	
	    var _this = _possibleConstructorReturn(this, (SketchObject.__proto__ || Object.getPrototypeOf(SketchObject)).call(this));
	
	    _this.id = _idGenerator.Generator.genID();
	    _this.aux = false;
	    _this.marked = null;
	    _this.children = [];
	    _this.linked = [];
	    _this.layer = null;
	    return _this;
	  }
	
	  _createClass(SketchObject, [{
	    key: 'normalDistance',
	    value: function normalDistance(aim, scale) {
	      return -1;
	    }
	  }, {
	    key: 'addChild',
	    value: function addChild(child) {
	      this.children.push(child);
	      child.parent = this;
	    }
	  }, {
	    key: 'accept',
	    value: function accept(visitor) {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var child = _step.value;
	
	          if (!child.accept(visitor)) {
	            return false;
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      return visitor(this);
	    }
	  }, {
	    key: 'stabilize',
	    value: function stabilize(viewer) {}
	  }, {
	    key: 'recoverIfNecessary',
	    value: function recoverIfNecessary() {
	      return false;
	    }
	  }, {
	    key: 'isAuxOrLinkedTo',
	    value: function isAuxOrLinkedTo() {
	      if (!!this.aux) {
	        return true;
	      }
	      for (var i = 0; i < this.linked.length; ++i) {
	        if (!!this.linked[i].aux) {
	          return true;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: '_translate',
	    value: function _translate(dx, dy, translated) {
	      translated[this.id] = 'x';
	      for (var i = 0; i < this.linked.length; ++i) {
	        if (translated[this.linked[i].id] != 'x') {
	          this.linked[i]._translate(dx, dy, translated);
	        }
	      }
	      this.translateImpl(dx, dy);
	    }
	  }, {
	    key: 'translate',
	    value: function translate(dx, dy) {
	      //  this.translateImpl(dx, dy);
	      if (this.isAuxOrLinkedTo()) {
	        return;
	      }
	      this._translate(dx, dy, {});
	    }
	  }, {
	    key: 'translateImpl',
	    value: function translateImpl(dx, dy) {
	      this.accept(function (obj) {
	        if (obj._class === 'TCAD.TWO.EndPoint') {
	          obj.translate(dx, dy);
	        }
	        return true;
	      });
	    }
	  }, {
	    key: 'draw',
	    value: function draw(ctx, scale, viewer) {
	      if (!this.visible) return;
	      if (this.marked != null) {
	        ctx.save();
	        viewer.setStyle(this.marked, ctx);
	      }
	      this.drawImpl(ctx, scale, viewer);
	      if (this.marked != null) ctx.restore();
	    }
	  }, {
	    key: 'copy',
	    value: function copy() {
	      throw 'method not implemented';
	    }
	  }]);

	  return SketchObject;
	}(_shape.Shape);

/***/ },
/* 431 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Shape = exports.Shape = function () {
	  function Shape() {
	    _classCallCheck(this, Shape);
	
	    this.visible = true;
	    this.style = null;
	    this.role = null;
	  }
	
	  _createClass(Shape, [{
	    key: "accept",
	    value: function accept(visitor) {
	      return visitor(this);
	    }
	  }, {
	    key: "draw",
	    value: function draw(ctx, scale) {}
	  }]);

	  return Shape;
	}();

/***/ },
/* 432 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DrawPoint = DrawPoint;
	exports.SetStyle = SetStyle;
	function DrawPoint(ctx, x, y, rad, scale) {
	  ctx.beginPath();
	  ctx.arc(x, y, rad / scale, 0, 2 * Math.PI, false);
	  ctx.fill();
	}
	
	function SetStyle(style, ctx, scale) {
	  ctx.lineWidth = style.lineWidth / scale;
	  ctx.strokeStyle = style.strokeStyle;
	  ctx.fillStyle = style.fillStyle;
	}

/***/ },
/* 433 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.GetShapeEditTool = GetShapeEditTool;
	
	var _ellipse = __webpack_require__(434);
	
	var _ellipticalArc = __webpack_require__(435);
	
	var _circle = __webpack_require__(436);
	
	var _circle2 = __webpack_require__(437);
	
	var _drag = __webpack_require__(438);
	
	var _ellipse2 = __webpack_require__(439);
	
	function GetShapeEditTool(viewer, obj, alternative) {
	  if (obj instanceof _circle.Circle && !alternative) {
	    var tool = new _circle2.EditCircleTool(viewer);
	    tool.circle = obj;
	    return tool;
	  } else if (obj instanceof _ellipse.Ellipse && !alternative) {
	    // even for an ell-arc we should act as it would be an ellipse to 
	    // avoid stabilize constraints added and demoing B point on move
	    // so second arg must be FALSE!
	    var _tool = new _ellipse2.EllipseTool(viewer, false);
	    _tool.ellipse = obj;
	    _tool.state = _ellipse2.STATE_RADIUS;
	    return _tool;
	  } else {
	    return new _drag.DragTool(obj, viewer);
	  }
	}

/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Ellipse = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _ref = __webpack_require__(416);
	
	var _sketchObject = __webpack_require__(430);
	
	var _parametric = __webpack_require__(415);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Ellipse = exports.Ellipse = function (_SketchObject) {
	  _inherits(Ellipse, _SketchObject);
	
	  function Ellipse(ep1, ep2) {
	    _classCallCheck(this, Ellipse);
	
	    var _this = _possibleConstructorReturn(this, (Ellipse.__proto__ || Object.getPrototypeOf(Ellipse)).call(this));
	
	    _this.ep1 = ep1;
	    _this.ep2 = ep2;
	    _this.addChild(_this.ep1);
	    _this.addChild(_this.ep2);
	    _this.r = new _ref.Ref(0);
	    _this.r.set(_this.radiusX * 0.5);
	    _this.r.obj = _this;
	    return _this;
	  }
	
	  _createClass(Ellipse, [{
	    key: 'recoverIfNecessary',
	    value: function recoverIfNecessary() {
	      var recovered = false;
	      if (math.distanceAB(this.ep1, this.ep2) <= math.TOLERANCE) {
	        this.ep1.translate(-RECOVER_LENGTH, -RECOVER_LENGTH);
	        this.ep2.translate(RECOVER_LENGTH, RECOVER_LENGTH);
	        recovered = true;
	      }
	      if (this.radiusY <= 0.1) {
	        this.r.set(RECOVER_LENGTH);
	        recovered = true;
	      }
	      return recovered;
	    }
	  }, {
	    key: 'collectParams',
	    value: function collectParams(params) {
	      this.ep1.collectParams(params);
	      this.ep2.collectParams(params);
	      params.push(this.r);
	    }
	  }, {
	    key: 'drawImpl',
	    value: function drawImpl(ctx, scale) {
	      ctx.beginPath();
	      var radiusX = Math.max(this.radiusX, 1e-8);
	      var radiusY = Math.max(this.radiusY, 1e-8);
	      ctx.ellipse(this.centerX, this.centerY, radiusX, radiusY, this.rotation, 0, 2 * Math.PI);
	      ctx.stroke();
	    }
	  }, {
	    key: 'toEllipseCoordinateSystem',
	    value: function toEllipseCoordinateSystem(point) {
	      var x = point.x - this.centerX;
	      var y = point.y - this.centerY;
	      var angle = Math.atan2(y, x) - this.rotation;
	      var radius = math.distance(0, 0, x, y);
	      x = radius * Math.cos(angle);
	      y = radius * Math.sin(angle);
	      return { x: x, y: y, angle: angle, radius: radius };
	    }
	  }, {
	    key: 'radiusAtAngle',
	    value: function radiusAtAngle(angle) {
	      return Math.sqrt(1 / (sq(Math.cos(angle) / this.radiusX) + sq(Math.sin(angle) / this.radiusY)));
	    }
	  }, {
	    key: 'normalDistance',
	    value: function normalDistance(aim) {
	      var polarPoint = this.toEllipseCoordinateSystem(aim);
	      var L = this.radiusAtAngle(polarPoint.angle);
	      return Math.abs(polarPoint.radius - L);
	    }
	  }, {
	    key: 'rotation',
	    get: function get() {
	      return Math.atan2(this.ep2.y - this.ep1.y, this.ep2.x - this.ep1.x);
	    }
	  }, {
	    key: 'radiusX',
	    get: function get() {
	      return math.distance(this.ep1.x, this.ep1.y, this.ep2.x, this.ep2.y) * 0.5;
	    }
	  }, {
	    key: 'radiusY',
	    get: function get() {
	      return this.r.get();
	    }
	  }, {
	    key: 'centerX',
	    get: function get() {
	      return this.ep1.x + (this.ep2.x - this.ep1.x) * 0.5;
	    }
	  }, {
	    key: 'centerY',
	    get: function get() {
	      return this.ep1.y + (this.ep2.y - this.ep1.y) * 0.5;
	    }
	  }], [{
	    key: 'findMinorRadius',
	    value: function findMinorRadius(majorRadius, pntRadius, pntAngle) {
	      return Math.abs(Math.sin(pntAngle) / Math.sqrt(1 / sq(pntRadius) - sq(Math.cos(pntAngle) / majorRadius)));
	    }
	  }]);
	
	  return Ellipse;
	}(_sketchObject.SketchObject);
	
	Ellipse.prototype._class = 'TCAD.TWO.Ellipse';
	
	var sq = function sq(a) {
	  return a * a;
	};
	var RECOVER_LENGTH = 100;

/***/ },
/* 435 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.EllipticalArc = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _ellipse = __webpack_require__(434);
	
	var _parametric = __webpack_require__(415);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	var _utils = __webpack_require__(330);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var EllipticalArc = exports.EllipticalArc = function (_Ellipse) {
	  _inherits(EllipticalArc, _Ellipse);
	
	  function EllipticalArc(ep1, ep2, a, b) {
	    _classCallCheck(this, EllipticalArc);
	
	    var _this = _possibleConstructorReturn(this, (EllipticalArc.__proto__ || Object.getPrototypeOf(EllipticalArc)).call(this, ep1, ep2));
	
	    _this.a = a;
	    _this.b = b;
	    _this.addChild(a);
	    _this.addChild(b);
	
	    //we'd like to have angles points have higher selection order 
	    (0, _utils.swap)(_this.children, 0, _this.children.length - 2);
	    (0, _utils.swap)(_this.children, 1, _this.children.length - 1);
	    return _this;
	  }
	
	  _createClass(EllipticalArc, [{
	    key: 'stabilize',
	    value: function stabilize(viewer) {
	      viewer.parametricManager._add(new _parametric.Constraints.PointOnEllipseInternal(this.b, this));
	      viewer.parametricManager._add(new _parametric.Constraints.PointOnEllipseInternal(this.a, this));
	    }
	  }, {
	    key: 'drawImpl',
	    value: function drawImpl(ctx, scale) {
	      ctx.beginPath();
	      var radiusX = Math.max(this.radiusX, 1e-8);
	      var radiusY = Math.max(this.radiusY, 1e-8);
	      var aAngle = this.drawAngle(this.a);
	      var bAngle = void 0;
	      if (math.areEqual(this.a.x, this.b.x, math.TOLERANCE) && math.areEqual(this.a.y, this.b.y, math.TOLERANCE)) {
	        bAngle = aAngle + 2 * Math.PI;
	      } else {
	        bAngle = this.drawAngle(this.b);
	      }
	      ctx.ellipse(this.centerX, this.centerY, radiusX, radiusY, this.rotation, aAngle, bAngle);
	      ctx.stroke();
	    }
	  }, {
	    key: 'drawAngle',
	    value: function drawAngle(point) {
	      var deformScale = this.radiusY / this.radiusX;
	      var x = point.x - this.centerX;
	      var y = point.y - this.centerY;
	      var rotation = -this.rotation;
	      var xx = x * Math.cos(rotation) - y * Math.sin(rotation);
	      var yy = x * Math.sin(rotation) + y * Math.cos(rotation);
	      xx *= deformScale;
	      return Math.atan2(yy, xx);
	    }
	  }]);
	
	  return EllipticalArc;
	}(_ellipse.Ellipse);
	
	EllipticalArc.prototype._class = 'TCAD.TWO.EllipticalArc';

/***/ },
/* 436 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Circle = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _utils = __webpack_require__(330);
	
	var utils = _interopRequireWildcard(_utils);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	var _circle = __webpack_require__(437);
	
	var _point = __webpack_require__(429);
	
	var _ref = __webpack_require__(416);
	
	var _sketchObject = __webpack_require__(430);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Circle = exports.Circle = function (_SketchObject) {
	  _inherits(Circle, _SketchObject);
	
	  function Circle(c) {
	    _classCallCheck(this, Circle);
	
	    var _this = _possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this));
	
	    _this.c = c;
	    c.parent = _this;
	    _this.children.push(c);
	    _this.r = new _ref.Ref(0);
	    _this.r.obj = _this;
	    return _this;
	  }
	
	  _createClass(Circle, [{
	    key: 'collectParams',
	    value: function collectParams(params) {
	      this.c.collectParams(params);
	      params.push(this.r);
	    }
	  }, {
	    key: 'getReferencePoint',
	    value: function getReferencePoint() {
	      return this.c;
	    }
	  }, {
	    key: 'translateImpl',
	    value: function translateImpl(dx, dy) {
	      this.c.translate(dx, dy);
	    }
	  }, {
	    key: 'drawImpl',
	    value: function drawImpl(ctx, scale) {
	      ctx.beginPath();
	      ctx.arc(this.c.x, this.c.y, this.r.get(), 0, 2 * Math.PI);
	      ctx.stroke();
	    }
	  }, {
	    key: 'normalDistance',
	    value: function normalDistance(aim) {
	      return Math.abs(math.distance(aim.x, aim.y, this.c.x, this.c.y) - this.r.get());
	    }
	  }]);
	
	  return Circle;
	}(_sketchObject.SketchObject);
	
	Circle.prototype._class = 'TCAD.TWO.Circle';

/***/ },
/* 437 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.EditCircleTool = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _tool = __webpack_require__(428);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	var _point = __webpack_require__(429);
	
	var _circle = __webpack_require__(436);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var EditCircleTool = exports.EditCircleTool = function (_Tool) {
	  _inherits(EditCircleTool, _Tool);
	
	  function EditCircleTool(viewer) {
	    _classCallCheck(this, EditCircleTool);
	
	    var _this = _possibleConstructorReturn(this, (EditCircleTool.__proto__ || Object.getPrototypeOf(EditCircleTool)).call(this, 'circle', viewer));
	
	    _this.circle = null;
	    return _this;
	  }
	
	  _createClass(EditCircleTool, [{
	    key: 'restart',
	    value: function restart() {
	      this.sendMessage('specify center');
	    }
	  }, {
	    key: 'cleanup',
	    value: function cleanup(e) {
	      this.viewer.cleanSnap();
	    }
	  }, {
	    key: 'mousemove',
	    value: function mousemove(e) {
	      var p = this.viewer.screenToModel(e);
	      if (this.circle != null) {
	        var r = math.distance(p.x, p.y, this.circle.c.x, this.circle.c.y);
	        this.circle.r.set(r);
	        if (!_tool.Tool.dumbMode(e)) {
	          this.solveRequest(true);
	        }
	      } else {
	        this.viewer.snap(p.x, p.y, []);
	      }
	      this.viewer.refresh();
	    }
	  }, {
	    key: 'solveRequest',
	    value: function solveRequest(rough) {
	      this.solver = this.viewer.parametricManager.prepare([this.circle.r]);
	      this.solver.solve(rough, 1);
	      this.solver.sync();
	    }
	  }, {
	    key: 'mouseup',
	    value: function mouseup(e) {
	      if (this.circle == null) {
	        this.stepCreateCircle(this.viewer.screenToModel(e), true);
	      } else {
	        this.stepFinish();
	      }
	    }
	  }, {
	    key: 'stepCreateCircle',
	    value: function stepCreateCircle(center, tryToSnap) {
	      this.viewer.historyManager.checkpoint();
	      var needSnap = tryToSnap && this.viewer.snapped != null;
	      var p = needSnap ? this.viewer.snapped : center;
	      this.circle = new _circle.Circle(new _point.EndPoint(p.x, p.y));
	      if (needSnap) this.viewer.parametricManager.linkObjects([this.circle.c, p]);
	      this.pointPicked(this.circle.c.x, this.circle.c.y);
	      this.sendHint('specify radius');
	      this.viewer.activeLayer.add(this.circle);
	      this.viewer.refresh();
	    }
	  }, {
	    key: 'stepFinish',
	    value: function stepFinish() {
	      this.solveRequest(false);
	      this.sendMessage("radius: " + this.viewer.roundToPrecision(this.circle.r.get()));
	      this.viewer.refresh();
	      this.viewer.toolManager.releaseControl();
	    }
	  }, {
	    key: 'processCommand',
	    value: function processCommand(command) {
	      if (this.circle == null) {
	        var result = _tool.Tool.ParseVector(this.viewer.referencePoint, command);
	        if (typeof result === 'string') return result;
	        this.stepCreateCircle(result, false);
	      } else {
	        var _result = _tool.Tool.ParseNumber(command);
	        if (typeof _result === 'string') return _result;
	        this.circle.r.set(_result);
	        this.stepFinish();
	      }
	    }
	  }]);

	  return EditCircleTool;
	}(_tool.Tool);

/***/ },
/* 438 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DragTool = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _tool = __webpack_require__(428);
	
	var _optim = __webpack_require__(421);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var DragTool = exports.DragTool = function (_Tool) {
	  _inherits(DragTool, _Tool);
	
	  function DragTool(obj, viewer) {
	    _classCallCheck(this, DragTool);
	
	    var _this = _possibleConstructorReturn(this, (DragTool.__proto__ || Object.getPrototypeOf(DragTool)).call(this, 'drag', viewer));
	
	    _this.obj = obj;
	    _this._point = { x: 0, y: 0 };
	    _this.origin = { x: 0, y: 0 };
	    _this.solver = null;
	    return _this;
	  }
	
	  _createClass(DragTool, [{
	    key: 'mousemove',
	    value: function mousemove(e) {
	      var x = this._point.x;
	      var y = this._point.y;
	      this.viewer.screenToModel2(e.offsetX, e.offsetY, this._point);
	      var dx = this._point.x - x;
	      var dy = this._point.y - y;
	      for (var i = 0; i < this.lockedShifts.length; i += 2) {
	        this.lockedValues[i] = this._point.x - this.lockedShifts[i];
	        this.lockedValues[i + 1] = this._point.y - this.lockedShifts[i + 1];
	      }
	      this.solver.updateLock(this.lockedValues);
	      if (!_tool.Tool.dumbMode(e)) {
	        this.solveRequest(true);
	      } else {
	        this.obj.translate(dx, dy);
	      }
	
	      this.viewer.refresh();
	    }
	  }, {
	    key: 'mousedown',
	    value: function mousedown(e) {
	      this.origin.x = e.offsetX;
	      this.origin.y = e.offsetY;
	      this.viewer.screenToModel2(e.offsetX, e.offsetY, this._point);
	      this.prepareSolver([]);
	    }
	  }, {
	    key: 'mouseup',
	    value: function mouseup(e) {
	      this.solveRequest(false);
	      this.viewer.refresh();
	      this.viewer.toolManager.releaseControl();
	      var traveled = math.distance(this.origin.x, this.origin.y, e.offsetX, e.offsetY);
	      if (traveled >= 10) {
	        this.viewer.historyManager.lightCheckpoint(10);
	      }
	      //this.animateSolution();
	    }
	  }, {
	    key: 'mousewheel',
	    value: function mousewheel(e) {}
	  }, {
	    key: 'solveRequest',
	    value: function solveRequest(rough) {
	      this.solver.solve(rough, 1);
	      this.solver.sync();
	
	      var paramsToUpdate = [];
	      this.viewer.accept(function (obj) {
	        if (obj.aux !== true) {
	          if (obj.recoverIfNecessary()) {
	            obj.collectParams(paramsToUpdate);
	          }
	        }
	        return true;
	      });
	
	      if (paramsToUpdate.length != 0) {
	        for (var i = 0; i < paramsToUpdate.length; i++) {
	          this.solver.updateParameter(paramsToUpdate[i]);
	        }
	        this.solver.solve(rough, 1);
	        this.solver.sync();
	      }
	    }
	  }, {
	    key: 'getParamsToLock',
	    value: function getParamsToLock() {
	      var params = [];
	      this.obj.accept(function (obj) {
	        if (obj._class === 'TCAD.TWO.EndPoint' && !obj.isAuxOrLinkedTo()) {
	          params.push(obj._x);
	          params.push(obj._y);
	        }
	        return true;
	      });
	      return params;
	    }
	  }, {
	    key: 'prepareSolver',
	    value: function prepareSolver(extraConstraints) {
	      var locked = this.getParamsToLock();
	      this.lockedShifts = [];
	      this.lockedValues = [];
	      for (var i = 0; i < locked.length; i += 2) {
	        this.lockedShifts[i] = this._point.x - locked[i].get();
	        this.lockedShifts[i + 1] = this._point.y - locked[i + 1].get();
	      }
	      this.solver = this.viewer.parametricManager.prepare(locked, extraConstraints);
	      //this.enableRecording();
	    }
	  }, {
	    key: 'enableRecording',
	    value: function enableRecording() {
	      var solver = this.solver;
	      DragTool.snapshots = [];
	      _optim.optim.DEBUG_HANDLER = function () {
	        DragTool.snapshots.push([]);
	        for (var i = 0; i < solver.solvers.length; i++) {
	          var sys = solver.solvers[i].system;
	          DragTool.snapshots[i].push(sys.params.map(function (p) {
	            return p.get();
	          }));
	        }
	      };
	    }
	  }, {
	    key: 'animateSolution',
	    value: function animateSolution() {
	      if (DragTool.snapshots.length === 0) return;
	      var stepNum = 0;
	      var scope = this;
	      var then = Date.now();
	      var speed = 500;
	
	      function step() {
	        var now = Date.now();
	        var elapsed = now - then;
	
	        if (elapsed > speed) {
	          for (var i = 0; i < scope.solver.solvers.length; i++) {
	            var sys = scope.solver.solvers[i].system;
	            if (stepNum >= DragTool.snapshots[i].length) continue;
	            var values = DragTool.snapshots[i][stepNum];
	            for (var k = 0; k < values.length; k++) {
	              sys.params[k]._backingParam.set(values[k]);
	            }
	          }
	          stepNum++;
	
	          then = now;
	          scope.viewer.repaint();
	        }
	
	        if (DragTool.snapshots.length != 0 && stepNum < DragTool.snapshots[0].length) {
	          window.requestAnimationFrame(step);
	        }
	      }
	
	      window.requestAnimationFrame(step);
	    }
	  }]);
	
	  return DragTool;
	}(_tool.Tool);
	
	DragTool.snapshots = [];

/***/ },
/* 439 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.EllipseTool = exports.STATE_RADIUS = exports.STATE_POINT2 = exports.STATE_POINT1 = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _tool = __webpack_require__(428);
	
	var _point = __webpack_require__(429);
	
	var _ellipse = __webpack_require__(434);
	
	var _ellipticalArc = __webpack_require__(435);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var STATE_POINT1 = exports.STATE_POINT1 = 0;
	var STATE_POINT2 = exports.STATE_POINT2 = 1;
	var STATE_RADIUS = exports.STATE_RADIUS = 2;
	
	var EllipseTool = exports.EllipseTool = function (_Tool) {
	  _inherits(EllipseTool, _Tool);
	
	  function EllipseTool(viewer, arc) {
	    _classCallCheck(this, EllipseTool);
	
	    var _this = _possibleConstructorReturn(this, (EllipseTool.__proto__ || Object.getPrototypeOf(EllipseTool)).call(this, arc ? 'ellipse' : 'elliptical arc', viewer));
	
	    _this.arc = arc;
	    _this.ellipse = null;
	    _this.state = STATE_POINT1;
	    return _this;
	  }
	
	  _createClass(EllipseTool, [{
	    key: 'restart',
	    value: function restart() {
	      this.ellipse = null;
	      this.state = STATE_POINT1;
	      this.sendHint('specify first major axis point');
	    }
	  }, {
	    key: 'cleanup',
	    value: function cleanup(e) {
	      this.viewer.cleanSnap();
	    }
	  }, {
	    key: 'point',
	    value: function point(e) {
	      return this.viewer.snapped ? this.viewer.snapped : this.viewer.screenToModel(e);
	    }
	  }, {
	    key: 'newEllipse',
	    value: function newEllipse(p) {
	      var ep = function ep() {
	        return new _point.EndPoint(p.x, p.y);
	      };
	      return this.arc ? new _ellipticalArc.EllipticalArc(ep(), ep(), ep(), ep()) : new _ellipse.Ellipse(ep(), ep());
	    }
	  }, {
	    key: 'demoBPoint',
	    value: function demoBPoint() {
	      var arc = this.ellipse;
	      var ang = Math.atan2(arc.a.y - arc.centerY, arc.a.x - arc.centerX) + (2 * Math.PI - 0.3);
	      ang %= 2 * Math.PI;
	      var r = arc.radiusAtAngle(ang - arc.rotation);
	      arc.b.x = arc.centerX + r * Math.cos(ang);
	      arc.b.y = arc.centerY + r * Math.sin(ang);
	    }
	  }, {
	    key: 'mouseup',
	    value: function mouseup(e) {
	      switch (this.state) {
	        case STATE_POINT1:
	          {
	            var p = this.point(e);
	            this.ellipse = this.newEllipse(p);
	            this.snapIfNeed(this.ellipse.ep1);
	            this.viewer.activeLayer.add(this.ellipse);
	            this.viewer.refresh();
	            this.state = STATE_POINT2;
	            this.sendHint('specify second major axis point');
	            break;
	          }
	        case STATE_POINT2:
	          {
	            var _p = this.point(e);
	            this.ellipse.ep2.setFromPoint(_p);
	            this.snapIfNeed(this.ellipse.ep2);
	            this.viewer.refresh();
	            this.state = STATE_RADIUS;
	            this.sendHint('specify minor axis radius');
	            break;
	          }
	        case STATE_RADIUS:
	          if (this.arc) {
	            this.ellipse.stabilize(this.viewer);
	          }
	          this.viewer.toolManager.releaseControl();
	      }
	    }
	  }, {
	    key: 'mousemove',
	    value: function mousemove(e) {
	      var p = this.viewer.screenToModel(e);
	      switch (this.state) {
	        case STATE_POINT1:
	          this.viewer.snap(p.x, p.y, []);
	          break;
	        case STATE_POINT2:
	          this.ellipse.ep2.setFromPoint(this.viewer.screenToModel(e));
	          this.ellipse.r.value = this.ellipse.radiusX * 0.5;
	          this.viewer.snap(p.x, p.y, this.ellipse.children);
	          if (this.arc) {
	            this.ellipse.a.setFromPoint(this.ellipse.ep2);
	            this.demoBPoint();
	          }
	          break;
	        case STATE_RADIUS:
	          var polarPoint = this.ellipse.toEllipseCoordinateSystem(p);
	          var minorRadius = _ellipse.Ellipse.findMinorRadius(this.ellipse.radiusX, polarPoint.radius, polarPoint.angle);
	          if (isNaN(minorRadius)) {
	            var projAxis = new _vector2.default(-(this.ellipse.ep2.y - this.ellipse.ep1.y), this.ellipse.ep2.x - this.ellipse.ep1.x);
	            projAxis._normalize();
	            var v = new _vector2.default(this.ellipse.ep2.x - p.x, this.ellipse.ep2.y - p.y);
	            minorRadius = Math.abs(projAxis.dot(v));
	          }
	          this.ellipse.r.set(minorRadius);
	          if (!_tool.Tool.dumbMode(e)) {
	            this.solveRequest(true);
	          }
	          if (this.arc) {
	            this.demoBPoint();
	          }
	          break;
	      }
	      this.viewer.refresh();
	    }
	  }, {
	    key: 'solveRequest',
	    value: function solveRequest(rough) {
	      this.solver = this.viewer.parametricManager.prepare([this.ellipse.r]);
	      this.solver.solve(rough, 1);
	      this.solver.sync();
	    }
	  }]);

	  return EllipseTool;
	}(_tool.Tool);

/***/ },
/* 440 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Segment = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _sketchObject = __webpack_require__(430);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _parametric = __webpack_require__(415);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Segment = exports.Segment = function (_SketchObject) {
	  _inherits(Segment, _SketchObject);
	
	  function Segment(a, b) {
	    _classCallCheck(this, Segment);
	
	    var _this = _possibleConstructorReturn(this, (Segment.__proto__ || Object.getPrototypeOf(Segment)).call(this));
	
	    _this.a = a;
	    _this.b = b;
	    a.parent = _this;
	    b.parent = _this;
	    _this.children.push(a, b);
	    return _this;
	  }
	
	  _createClass(Segment, [{
	    key: 'recoverIfNecessary',
	    value: function recoverIfNecessary() {
	      if (math.distanceAB(this.a, this.b) > math.TOLERANCE) {
	        return false;
	      } else {
	        var recoverLength = 100;
	        this.a.translate(-recoverLength, -recoverLength);
	        this.b.translate(recoverLength, recoverLength);
	        return true;
	      }
	    }
	  }, {
	    key: 'collectParams',
	    value: function collectParams(params) {
	      this.a.collectParams(params);
	      this.b.collectParams(params);
	    }
	  }, {
	    key: 'normalDistance',
	    value: function normalDistance(aim) {
	      return Segment.calcNormalDistance(aim, this.a, this.b);
	    }
	  }, {
	    key: 'getReferencePoint',
	    value: function getReferencePoint() {
	      return this.a;
	    }
	  }, {
	    key: 'translateImpl',
	    value: function translateImpl(dx, dy) {
	      this.a.translate(dx, dy);
	      this.b.translate(dx, dy);
	    }
	  }, {
	    key: 'drawImpl',
	    value: function drawImpl(ctx, scale) {
	      ctx.beginPath();
	      ctx.moveTo(this.a.x, this.a.y);
	      ctx.lineTo(this.b.x, this.b.y);
	      //  ctx.save();
	      //  ctx.setTransform(1, 0, 0, 1, 0, 0);
	      ctx.stroke();
	      //  ctx.restore();
	    }
	  }, {
	    key: 'copy',
	    value: function copy() {
	      return new Segment(this.a.copy(), this.b.copy());
	    }
	  }], [{
	    key: 'calcNormalDistance',
	    value: function calcNormalDistance(aim, segmentA, segmentB) {
	      var ab = new _vector2.default(segmentB.x - segmentA.x, segmentB.y - segmentA.y);
	      var e = ab.normalize();
	      var a = new _vector2.default(aim.x - segmentA.x, aim.y - segmentA.y);
	      var b = e.multiply(a.dot(e));
	      var n = a.minus(b);
	
	      //Check if vector b lays on the vector ab
	      if (b.length() > ab.length()) {
	        return -1;
	      }
	
	      if (b.dot(ab) < 0) {
	        return -1;
	      }
	
	      return n.length();
	    }
	  }]);
	
	  return Segment;
	}(_sketchObject.SketchObject);
	
	Segment.prototype._class = 'TCAD.TWO.Segment';

/***/ },
/* 441 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Point = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _drawUtils = __webpack_require__(432);
	
	var draw_utils = _interopRequireWildcard(_drawUtils);
	
	var _shape = __webpack_require__(431);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Point = exports.Point = function (_Shape) {
	  _inherits(Point, _Shape);
	
	  function Point(x, y, rad) {
	    _classCallCheck(this, Point);
	
	    var _this = _possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).call(this));
	
	    _this.x = x;
	    _this.y = y;
	    _this.rad = rad;
	    _this.style = null;
	    return _this;
	  }
	
	  _createClass(Point, [{
	    key: 'draw',
	    value: function draw(ctx, scale) {
	      draw_utils.DrawPoint(ctx, this.x, this.y, this.rad, scale);
	    }
	  }]);

	  return Point;
	}(_shape.Shape);

/***/ },
/* 442 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ReferencePoint = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _shape = __webpack_require__(431);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ReferencePoint = exports.ReferencePoint = function (_Shape) {
	  _inherits(ReferencePoint, _Shape);
	
	  function ReferencePoint() {
	    _classCallCheck(this, ReferencePoint);
	
	    var _this = _possibleConstructorReturn(this, (ReferencePoint.__proto__ || Object.getPrototypeOf(ReferencePoint)).call(this));
	
	    _this.x = 0;
	    _this.y = 0;
	    return _this;
	  }
	
	  _createClass(ReferencePoint, [{
	    key: 'draw',
	    value: function draw(ctx, scale) {
	      if (!this.visible) return;
	      ctx.strokeStyle = 'salmon';
	      ctx.fillStyle = 'salmon';
	      ctx.lineWidth = 1 / scale;
	
	      ctx.beginPath();
	      ctx.arc(this.x, this.y, 1 / scale, 0, 2 * Math.PI, false);
	      ctx.fill();
	
	      ctx.beginPath();
	      ctx.arc(this.x, this.y, 7 / scale, 0, 2 * Math.PI, false);
	      ctx.stroke();
	    }
	  }]);

	  return ReferencePoint;
	}(_shape.Shape);

/***/ },
/* 443 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.BasisOrigin = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _shape = __webpack_require__(431);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var BasisOrigin = exports.BasisOrigin = function (_Shape) {
	  _inherits(BasisOrigin, _Shape);
	
	  function BasisOrigin(basis, viewer) {
	    _classCallCheck(this, BasisOrigin);
	
	    var _this = _possibleConstructorReturn(this, (BasisOrigin.__proto__ || Object.getPrototypeOf(BasisOrigin)).call(this));
	
	    _this.viewer = viewer;
	    _this.inverseX = false;
	    _this.inverseY = false;
	    _this.lineWidth = 100;
	    _this.xColor = '#FF0000';
	    _this.yColor = '#00FF00';
	    return _this;
	  }
	
	  _createClass(BasisOrigin, [{
	    key: 'draw',
	    value: function draw(ctx, scale) {
	      ctx.save();
	      if (this.inverseX) {
	        this.xScale = -1;
	        this.xShift = this.lineWidth + 10;
	      } else {
	        this.xScale = 1;
	        this.xShift = 10;
	      }
	      if (this.inverseY) {
	        this.yScale = -1;
	        this.yShift = this.viewer.canvas.height - this.lineWidth - 10;
	      } else {
	        this.yScale = 1;
	        this.yShift = this.viewer.canvas.height - 10;
	      }
	
	      ctx.setTransform(this.xScale, 0, 0, this.yScale, this.xShift, this.yShift);
	      ctx.beginPath();
	
	      ctx.lineWidth = 1;
	      ctx.strokeStyle = this.yColor;
	
	      var headA = 1;
	      var headB = 10;
	
	      ctx.moveTo(0.5, 0);
	      ctx.lineTo(0.5, -this.lineWidth);
	
	      ctx.moveTo(0, -this.lineWidth);
	      ctx.lineTo(headA, 0 - this.lineWidth + headB);
	
	      ctx.moveTo(0, -this.lineWidth);
	      ctx.lineTo(-headA, -this.lineWidth + headB);
	      ctx.closePath();
	      ctx.stroke();
	
	      ctx.beginPath();
	      ctx.strokeStyle = this.xColor;
	      ctx.moveTo(0, 0.5);
	      ctx.lineTo(this.lineWidth, 0.5);
	
	      ctx.moveTo(this.lineWidth, 0);
	      ctx.lineTo(this.lineWidth - headB, headA);
	
	      ctx.moveTo(this.lineWidth, 0);
	      ctx.lineTo(this.lineWidth - headB, -headA);
	      ctx.closePath();
	      ctx.stroke();
	
	      ctx.restore();
	    }
	  }]);

	  return BasisOrigin;
	}(_shape.Shape);

/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Arc = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _utils = __webpack_require__(330);
	
	var utils = _interopRequireWildcard(_utils);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _ref = __webpack_require__(416);
	
	var _parametric = __webpack_require__(415);
	
	var _sketchObject = __webpack_require__(430);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Arc = exports.Arc = function (_SketchObject) {
	  _inherits(Arc, _SketchObject);
	
	  function Arc(a, b, c) {
	    _classCallCheck(this, Arc);
	
	    var _this = _possibleConstructorReturn(this, (Arc.__proto__ || Object.getPrototypeOf(Arc)).call(this));
	
	    _this.a = a;
	    _this.b = b;
	    _this.c = c;
	    a.parent = _this;
	    b.parent = _this;
	    c.parent = _this;
	    _this.children.push(a, b, c);
	    _this.r = new _ref.Ref(0);
	    _this.r.value = _this.distanceA();
	    _this.r.obj = _this;
	    return _this;
	  }
	
	  _createClass(Arc, [{
	    key: 'collectParams',
	    value: function collectParams(params) {
	      this.a.collectParams(params);
	      this.b.collectParams(params);
	      this.c.collectParams(params);
	      params.push(this.r);
	    }
	  }, {
	    key: 'getReferencePoint',
	    value: function getReferencePoint() {
	      return this.c;
	    }
	  }, {
	    key: 'translateImpl',
	    value: function translateImpl(dx, dy) {
	      this.a.translate(dx, dy);
	      this.b.translate(dx, dy);
	      this.c.translate(dx, dy);
	    }
	  }, {
	    key: 'radiusForDrawing',
	    value: function radiusForDrawing() {
	      return this.distanceA();
	    }
	  }, {
	    key: 'distanceA',
	    value: function distanceA() {
	      return math.distance(this.a.x, this.a.y, this.c.x, this.c.y);
	    }
	  }, {
	    key: 'distanceB',
	    value: function distanceB() {
	      return math.distance(this.b.x, this.b.y, this.c.x, this.c.y);
	    }
	  }, {
	    key: 'getStartAngle',
	    value: function getStartAngle() {
	      return Math.atan2(this.a.y - this.c.y, this.a.x - this.c.x);
	    }
	  }, {
	    key: 'getEndAngle',
	    value: function getEndAngle() {
	      return Math.atan2(this.b.y - this.c.y, this.b.x - this.c.x);
	    }
	  }, {
	    key: 'drawImpl',
	    value: function drawImpl(ctx, scale) {
	      ctx.beginPath();
	      var r = this.radiusForDrawing();
	      var startAngle = this.getStartAngle();
	      var endAngle;
	      if (math.areEqual(this.a.x, this.b.x, math.TOLERANCE) && math.areEqual(this.a.y, this.b.y, math.TOLERANCE)) {
	        endAngle = startAngle + 2 * Math.PI;
	      } else {
	        endAngle = this.getEndAngle();
	      }
	      ctx.arc(this.c.x, this.c.y, r, startAngle, endAngle);
	      var distanceB = this.distanceB();
	      if (Math.abs(r - distanceB) * scale > 1) {
	        var adj = r / distanceB;
	        ctx.save();
	        ctx.setLineDash([7 / scale]);
	        ctx.lineTo(this.b.x, this.b.y);
	        ctx.moveTo(this.b.x + (this.b.x - this.c.x) / adj, this.b.y + (this.b.y - this.c.y) / adj);
	        ctx.stroke();
	        ctx.restore();
	      } else {
	        ctx.stroke();
	      }
	    }
	  }, {
	    key: 'isPointInsideSector',
	    value: function isPointInsideSector(x, y) {
	      var ca = new _vector2.default(this.a.x - this.c.x, this.a.y - this.c.y);
	      var cb = new _vector2.default(this.b.x - this.c.x, this.b.y - this.c.y);
	      var ct = new _vector2.default(x - this.c.x, y - this.c.y);
	
	      ca._normalize();
	      cb._normalize();
	      ct._normalize();
	      var cosAB = ca.dot(cb);
	      var cosAT = ca.dot(ct);
	
	      var isInside = cosAT >= cosAB;
	      var abInverse = ca.cross(cb).z < 0;
	      var atInverse = ca.cross(ct).z < 0;
	
	      var result;
	      if (abInverse) {
	        result = !atInverse || !isInside;
	      } else {
	        result = !atInverse && isInside;
	      }
	      return result;
	    }
	  }, {
	    key: 'normalDistance',
	    value: function normalDistance(aim) {
	
	      var isInsideSector = this.isPointInsideSector(aim.x, aim.y);
	      if (isInsideSector) {
	        return Math.abs(math.distance(aim.x, aim.y, this.c.x, this.c.y) - this.radiusForDrawing());
	      } else {
	        return Math.min(math.distance(aim.x, aim.y, this.a.x, this.a.y), math.distance(aim.x, aim.y, this.b.x, this.b.y));
	      }
	    }
	  }, {
	    key: 'stabilize',
	    value: function stabilize(viewer) {
	      this.r.set(this.distanceA());
	      viewer.parametricManager._add(new _parametric.Constraints.P2PDistanceV(this.b, this.c, this.r));
	      viewer.parametricManager._add(new _parametric.Constraints.P2PDistanceV(this.a, this.c, this.r));
	    }
	  }, {
	    key: 'copy',
	    value: function copy() {
	      return new Arc(this.a.copy(), this.b.copy(), this.c.copy());
	    }
	  }]);
	
	  return Arc;
	}(_sketchObject.SketchObject);
	
	Arc.prototype._class = 'TCAD.TWO.Arc';

/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.BezierCurve = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _ref = __webpack_require__(416);
	
	var _sketchObject = __webpack_require__(430);
	
	var _segment = __webpack_require__(440);
	
	var _bezierCubic = __webpack_require__(312);
	
	var _convexHull = __webpack_require__(446);
	
	var _drawUtils = __webpack_require__(432);
	
	var draw_utils = _interopRequireWildcard(_drawUtils);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var BezierCurve = exports.BezierCurve = function (_SketchObject) {
	  _inherits(BezierCurve, _SketchObject);
	
	  function BezierCurve(a, b, cp1, cp2) {
	    _classCallCheck(this, BezierCurve);
	
	    var _this = _possibleConstructorReturn(this, (BezierCurve.__proto__ || Object.getPrototypeOf(BezierCurve)).call(this));
	
	    _this.a = a;
	    _this.b = b;
	    _this.cp1 = cp1;
	    _this.cp2 = cp2;
	
	    _this.addChild(new _segment.Segment(a, cp1));
	    _this.addChild(new _segment.Segment(b, cp2));
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = _this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var c = _step.value;
	
	        c.role = 'construction';
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	
	    return _this;
	  }
	
	  _createClass(BezierCurve, [{
	    key: 'collectParams',
	    value: function collectParams(params) {
	      this.a.collectParams(params);
	      this.b.collectParams(params);
	      this.cp1.collectParams(params);
	      this.cp2.collectParams(params);
	    }
	  }, {
	    key: 'normalDistance',
	    value: function normalDistance(aim, scale) {
	      this.hull = (0, _convexHull.ConvexHull2D)([this.a, this.b, this.cp1, this.cp2]);
	      this.hull = math.polygonOffset(this.hull, 1 + 0.3 / scale);
	      if (math.isPointInsidePolygon(aim, this.hull)) {
	        this.lut = (0, _bezierCubic.LUT)(this.a, this.b, this.cp1, this.cp2, scale);
	        return this.closestNormalDistance(aim, this.lut);
	      }
	      return -1;
	    }
	  }, {
	    key: 'closestNormalDistance',
	    value: function closestNormalDistance(aim, segments) {
	      var hero = -1;
	      for (var p = segments.length - 1, q = 0; q < segments.length; p = q++) {
	        var dist = Math.min(_segment.Segment.calcNormalDistance(aim, segments[p], segments[q]));
	        if (dist != -1) {
	          hero = hero == -1 ? dist : Math.min(dist, hero);
	        }
	      }
	      return hero;
	    }
	  }, {
	    key: 'drawImpl',
	    value: function drawImpl(ctx, scale, viewer) {
	      ctx.beginPath();
	      ctx.moveTo(this.a.x, this.a.y);
	      ctx.bezierCurveTo(this.cp1.x, this.cp1.y, this.cp2.x, this.cp2.y, this.b.x, this.b.y);
	      ctx.stroke();
	
	      //debug lut and hull
	      //this.drawLUTAndHull();
	    }
	  }, {
	    key: 'drawLUTAndHull',
	    value: function drawLUTAndHull() {
	      if (this.lut) {
	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;
	
	        try {
	          for (var _iterator2 = this.lut[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var p = _step2.value;
	
	            draw_utils.DrawPoint(ctx, p.x, p.y, 3, scale);
	          }
	        } catch (err) {
	          _didIteratorError2 = true;
	          _iteratorError2 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	              _iterator2.return();
	            }
	          } finally {
	            if (_didIteratorError2) {
	              throw _iteratorError2;
	            }
	          }
	        }
	
	        ctx.moveTo(this.hull[0].x, this.hull[0].y);
	        var _iteratorNormalCompletion3 = true;
	        var _didIteratorError3 = false;
	        var _iteratorError3 = undefined;
	
	        try {
	          for (var _iterator3 = this.hull[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	            var _p = _step3.value;
	
	            ctx.lineTo(_p.x, _p.y);
	          }
	        } catch (err) {
	          _didIteratorError3 = true;
	          _iteratorError3 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion3 && _iterator3.return) {
	              _iterator3.return();
	            }
	          } finally {
	            if (_didIteratorError3) {
	              throw _iteratorError3;
	            }
	          }
	        }
	
	        ctx.stroke();
	      }
	    }
	  }]);
	
	  return BezierCurve;
	}(_sketchObject.SketchObject);
	
	BezierCurve.prototype._class = 'TCAD.TWO.BezierCurve';
	
	var RECOVER_LENGTH = 100;

/***/ },
/* 446 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ConvexHull2D = ConvexHull2D;
	function ConvexHull2D(points) {
	  points.sort(function (a, b) {
	    return a.x != b.x ? a.x - b.x : a.y - b.y;
	  });
	
	  var n = points.length;
	  var hull = [];
	
	  for (var i = 0; i < 2 * n; i++) {
	    var j = i < n ? i : 2 * n - 1 - i;
	    while (hull.length >= 2 && removeMiddle(hull[hull.length - 2], hull[hull.length - 1], points[j])) {
	      hull.pop();
	    }
	    hull.push(points[j]);
	  }
	  hull.pop();
	  return hull;
	}
	
	function removeMiddle(a, b, c) {
	  var cross = (a.x - b.x) * (c.y - b.y) - (a.y - b.y) * (c.x - b.x);
	  var dot = (a.x - b.x) * (c.x - b.x) + (a.y - b.y) * (c.y - b.y);
	  return cross < 0 || cross == 0 && dot <= 0;
	}

/***/ },
/* 447 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DiameterDimension = exports.VDimension = exports.HDimension = exports.Dimension = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _utils = __webpack_require__(330);
	
	var utils = _interopRequireWildcard(_utils);
	
	var _math = __webpack_require__(304);
	
	var math = _interopRequireWildcard(_math);
	
	var _vector = __webpack_require__(303);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _sketchObject = __webpack_require__(430);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var LinearDimension = function (_SketchObject) {
	  _inherits(LinearDimension, _SketchObject);
	
	  function LinearDimension(a, b) {
	    _classCallCheck(this, LinearDimension);
	
	    var _this = _possibleConstructorReturn(this, (LinearDimension.__proto__ || Object.getPrototypeOf(LinearDimension)).call(this));
	
	    _this.a = a;
	    _this.b = b;
	    _this.flip = false;
	    return _this;
	  }
	
	  _createClass(LinearDimension, [{
	    key: 'collectParams',
	    value: function collectParams(params) {}
	  }, {
	    key: 'getReferencePoint',
	    value: function getReferencePoint() {
	      return this.a;
	    }
	  }, {
	    key: 'translateImpl',
	    value: function translateImpl(dx, dy) {}
	  }, {
	    key: 'getA',
	    value: function getA() {
	      return this.a;
	    }
	  }, {
	    key: 'getB',
	    value: function getB() {
	      return this.b;
	    }
	  }, {
	    key: 'drawImpl',
	    value: function drawImpl(ctx, scale, viewer) {
	
	      var off = 30 * viewer.dimScale;
	      var textOff = getTextOff(viewer.dimScale);
	
	      var a, b, startA, startB;
	      if (this.flip) {
	        a = this.getB();
	        b = this.getA();
	        startA = this.b;
	        startB = this.a;
	      } else {
	        a = this.getA();
	        b = this.getB();
	        startA = this.a;
	        startB = this.b;
	      }
	
	      var d = math.distanceAB(a, b);
	
	      var _vx = -(b.y - a.y);
	      var _vy = b.x - a.x;
	
	      //normalize
	      var _vxn = _vx / d;
	      var _vyn = _vy / d;
	
	      _vx = _vxn * off;
	      _vy = _vyn * off;
	
	      ctx.beginPath();
	
	      var _ax = a.x + _vx;
	      var _ay = a.y + _vy;
	      var _bx = b.x + _vx;
	      var _by = b.y + _vy;
	
	      ctx.moveTo(_ax, _ay);
	      ctx.lineTo(_bx, _by);
	
	      function drawRef(start, x, y) {
	        var vec = new _vector2.default(x - start.x, y - start.y);
	        vec._normalize();
	        vec._multiply(7 * viewer.dimScale);
	
	        ctx.moveTo(start.x, start.y);
	        ctx.lineTo(x, y);
	        ctx.lineTo(x + vec.x, y + vec.y);
	      }
	
	      drawRef(startA, _ax, _ay);
	      drawRef(startB, _bx, _by);
	
	      ctx.closePath();
	      ctx.stroke();
	
	      function drawArrow(x, y) {
	        var s1 = 50;
	        var s2 = 20;
	        ctx.lineCap = 'round';
	        ctx.beginPath();
	        ctx.moveTo(x, y);
	        ctx.lineTo(x - s1, y - s2);
	        ctx.closePath();
	        ctx.stroke();
	      }
	
	      //  drawArrow(_ax, _ay);
	      //  drawArrow(_bx, _by);
	
	      ctx.font = 12 * viewer.dimScale + "px Arial";
	      var txt = d.toFixed(2);
	      var h = d / 2 - ctx.measureText(txt).width / 2;
	
	      if (h > 0) {
	        var tx = _ax + _vxn * textOff - -_vyn * h;
	        var ty = _ay + _vyn * textOff - _vxn * h;
	        ctx.save();
	        ctx.translate(tx, ty);
	        ctx.rotate(-Math.atan2(_vxn, _vyn));
	        ctx.scale(1, -1);
	        ctx.fillText(txt, 0, 0);
	        ctx.restore();
	      }
	    }
	  }, {
	    key: 'normalDistance',
	    value: function normalDistance(aim) {
	      return -1;
	    }
	  }]);
	
	  return LinearDimension;
	}(_sketchObject.SketchObject);
	
	var Dimension = exports.Dimension = function (_LinearDimension) {
	  _inherits(Dimension, _LinearDimension);
	
	  function Dimension(a, b) {
	    _classCallCheck(this, Dimension);
	
	    return _possibleConstructorReturn(this, (Dimension.__proto__ || Object.getPrototypeOf(Dimension)).call(this, a, b));
	  }
	
	  return Dimension;
	}(LinearDimension);
	
	Dimension.prototype._class = 'TCAD.TWO.Dimension';
	
	var HDimension = exports.HDimension = function (_LinearDimension2) {
	  _inherits(HDimension, _LinearDimension2);
	
	  function HDimension(a, b) {
	    _classCallCheck(this, HDimension);
	
	    return _possibleConstructorReturn(this, (HDimension.__proto__ || Object.getPrototypeOf(HDimension)).call(this, a, b));
	  }
	
	  _createClass(HDimension, [{
	    key: 'getA',
	    value: function getA() {
	      return this.a;
	    }
	  }, {
	    key: 'getB',
	    value: function getB() {
	      return { x: this.b.x, y: this.a.y };
	    }
	  }]);
	
	  return HDimension;
	}(LinearDimension);
	
	HDimension.prototype._class = 'TCAD.TWO.HDimension';
	
	var VDimension = exports.VDimension = function (_LinearDimension3) {
	  _inherits(VDimension, _LinearDimension3);
	
	  function VDimension(a, b) {
	    _classCallCheck(this, VDimension);
	
	    return _possibleConstructorReturn(this, (VDimension.__proto__ || Object.getPrototypeOf(VDimension)).call(this, a, b));
	  }
	
	  _createClass(VDimension, [{
	    key: 'getA',
	    value: function getA() {
	      return this.a;
	    }
	  }, {
	    key: 'getB',
	    value: function getB() {
	      return { x: this.a.x, y: this.b.y };
	    }
	  }]);
	
	  return VDimension;
	}(LinearDimension);
	
	VDimension.prototype._class = 'TCAD.TWO.VDimension';
	
	var DiameterDimension = exports.DiameterDimension = function (_SketchObject2) {
	  _inherits(DiameterDimension, _SketchObject2);
	
	  function DiameterDimension(obj) {
	    _classCallCheck(this, DiameterDimension);
	
	    var _this5 = _possibleConstructorReturn(this, (DiameterDimension.__proto__ || Object.getPrototypeOf(DiameterDimension)).call(this));
	
	    _this5.obj = obj;
	    _this5.angle = Math.PI / 4;
	    return _this5;
	  }
	
	  _createClass(DiameterDimension, [{
	    key: 'collectParams',
	    value: function collectParams(params) {}
	  }, {
	    key: 'getReferencePoint',
	    value: function getReferencePoint() {}
	  }, {
	    key: 'translateImpl',
	    value: function translateImpl(dx, dy) {}
	  }, {
	    key: 'drawImpl',
	    value: function drawImpl(ctx, scale, viewer) {
	      if (this.obj == null) return;
	      if (this.obj._class === 'TCAD.TWO.Circle') {
	        this.drawForCircle(ctx, scale, viewer);
	      } else if (this.obj._class === 'TCAD.TWO.Arc') {
	        this.drawForArc(ctx, scale, viewer);
	      }
	    }
	  }, {
	    key: 'drawForCircle',
	    value: function drawForCircle(ctx, scale, viewer) {
	      var c = new _vector2.default().setV(this.obj.c);
	      var r = this.obj.r.get();
	      var angled = new _vector2.default(r * Math.cos(this.angle), r * Math.sin(this.angle), 0);
	      var a = c.minus(angled);
	      var b = c.plus(angled);
	      var textOff = getTextOff(viewer.dimScale);
	
	      var d = 2 * r;
	
	      ctx.beginPath();
	      ctx.moveTo(a.x, a.y);
	      ctx.lineTo(b.x, b.y);
	      ctx.closePath();
	      ctx.stroke();
	
	      var fontSize = 12 * viewer.dimScale;
	      ctx.font = fontSize + "px Arial";
	      var txt = String.fromCharCode(216) + ' ' + d.toFixed(2);
	      var textWidth = ctx.measureText(txt).width;
	      var h = d / 2 - textWidth / 2;
	
	      var _vx = -(b.y - a.y);
	      var _vy = b.x - a.x;
	
	      //normalize
	      var _vxn = _vx / d;
	      var _vyn = _vy / d;
	
	      function drawText(tx, ty) {
	        ctx.save();
	        ctx.translate(tx, ty);
	        ctx.rotate(-Math.atan2(_vxn, _vyn));
	        ctx.scale(1, -1);
	        ctx.fillText(txt, 0, 0);
	        ctx.restore();
	      }
	
	      var tx, ty;
	      if (h - fontSize * .3 > 0) {
	        // take into account font size to not have circle overlap symbols
	        tx = a.x + _vxn * textOff - -_vyn * h;
	        ty = a.y + _vyn * textOff - _vxn * h;
	        drawText(tx, ty);
	      } else {
	        var off = 2 * viewer.dimScale;
	        angled._normalize();
	        var extraLine = angled.multiply(textWidth + off * 2);
	        ctx.beginPath();
	        ctx.moveTo(b.x, b.y);
	        ctx.lineTo(b.x + extraLine.x, b.y + extraLine.y);
	        ctx.closePath();
	        ctx.stroke();
	        angled._multiply(off);
	
	        tx = b.x + _vxn * textOff + angled.x;
	        ty = b.y + _vyn * textOff + angled.y;
	        drawText(tx, ty);
	      }
	    }
	  }, {
	    key: 'drawForArc',
	    value: function drawForArc(ctx, scale, viewer) {
	
	      var r = this.obj.distanceA();
	
	      var hxn = Math.cos(this.angle);
	      var hyn = Math.sin(this.angle);
	
	      var vxn = -hyn;
	      var vyn = hxn;
	
	      //fix angle if needed
	      if (!this.obj.isPointInsideSector(this.obj.c.x + hxn, this.obj.c.y + hyn)) {
	        var cosA = hxn * (this.obj.a.x - this.obj.c.x) + hyn * (this.obj.a.y - this.obj.c.y);
	        var cosB = hxn * (this.obj.b.x - this.obj.c.x) + hyn * (this.obj.b.y - this.obj.c.y);
	        if (cosA - hxn > cosB - hxn) {
	          this.angle = this.obj.getStartAngle();
	        } else {
	          this.angle = this.obj.getEndAngle();
	        }
	      }
	
	      var vertOff = getTextOff(viewer.dimScale);
	      var horOff = 5 * viewer.dimScale;
	
	      var fontSize = 12 * viewer.dimScale;
	      ctx.font = fontSize + "px Arial";
	      var txt = 'R ' + r.toFixed(2);
	      var textWidth = ctx.measureText(txt).width;
	
	      var startX = this.obj.c.x + hxn * r;
	      var startY = this.obj.c.y + hyn * r;
	      var lineLength = textWidth + horOff * 2;
	
	      ctx.beginPath();
	      ctx.moveTo(startX, startY);
	      ctx.lineTo(startX + hxn * lineLength, startY + hyn * lineLength);
	      ctx.closePath();
	      ctx.stroke();
	
	      var tx = startX + vxn * vertOff + hxn * horOff;
	      var ty = startY + vyn * vertOff + hyn * horOff;
	      ctx.save();
	      ctx.translate(tx, ty);
	      ctx.rotate(-Math.atan2(vxn, vyn));
	      ctx.scale(1, -1);
	      ctx.fillText(txt, 0, 0);
	      ctx.restore();
	    }
	  }, {
	    key: 'normalDistance',
	    value: function normalDistance(aim) {
	      return -1;
	    }
	  }]);
	
	  return DiameterDimension;
	}(_sketchObject.SketchObject);
	
	DiameterDimension.prototype._class = 'TCAD.TWO.DiameterDimension';
	
	function getTextOff(scale) {
	  return 3 * scale;
	}

/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DEBUG = undefined;
	exports.AddDebugSupport = AddDebugSupport;
	
	var _actionHelpers = __webpack_require__(407);
	
	var _brepSceneObject = __webpack_require__(379);
	
	var _sceneObject = __webpack_require__(326);
	
	var _dpr = __webpack_require__(325);
	
	var _dpr2 = _interopRequireDefault(_dpr);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var DEBUG = exports.DEBUG = true;
	
	function AddDebugSupport(app) {
	  if (!DEBUG) return;
	  app.actionManager.registerActions(DebugActions);
	  app.ui.registerMenuActions(DebugMenuConfig);
	  app.controlBar.add('menu.debug', true);
	  addGlobalDebugActions(app);
	}
	
	function addGlobalDebugActions(app) {
	  var debugGroup = new THREE.Object3D();
	  var debugVolumeGroup = new THREE.Object3D();
	  app.viewer.workGroup.add(debugGroup);
	  app.viewer.workGroup.add(debugVolumeGroup);
	  window.__DEBUG__ = {
	    AddLine: function AddLine(a, b) {
	      debugGroup.add(createLine(a, b));
	      app.viewer.render();
	    },
	    AddSegment: function AddSegment(a, b, color) {
	      __DEBUG__.AddPolyLine([a, b], color);
	    },
	    AddPolyLine: function AddPolyLine(points, color) {
	      for (var i = 1; i < points.length; ++i) {
	        debugGroup.add(createLine(points[i - 1], points[i], color));
	      }
	      debugGroup.add(createPoint(points[0], 0x000088));
	      debugGroup.add(createPoint(points[points.length - 1], 0x880000));
	      app.viewer.render();
	    },
	    AddPoint: function AddPoint(coordinates, or, vector, andColorAtTheEnd) {
	      debugGroup.add(createPoint(coordinates, or, vector, andColorAtTheEnd));
	      app.viewer.render();
	    },
	    AddVertex: function AddVertex(v) {
	      window.__DEBUG__.AddPoint(v.point);
	    },
	    AddPolygon: function AddPolygon(vertices, color) {
	      for (var i = 0; i < vertices.length; i++) {
	        __DEBUG__.AddSegment(vertices[i].point, vertices[(i + 1) % vertices.length].point, color);
	      }
	    },
	    AddPlane: function AddPlane(plane) {
	      var geo = new THREE.PlaneBufferGeometry(2000, 2000, 8, 8);
	      var coplanarPoint = plane.normal.multiply(plane.w);
	      var focalPoint = coplanarPoint.plus(plane.normal);
	      geo.lookAt(focalPoint.three());
	      geo.translate(coplanarPoint.x, coplanarPoint.y, coplanarPoint.z);
	      var mat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide,
	        transparent: true,
	        opacity: 0.3 });
	      var planeObj = new THREE.Mesh(geo, mat);
	      debugGroup.add(planeObj);
	      app.viewer.render();
	    },
	    AddHalfEdge: function AddHalfEdge(he, color) {
	      var points = [he.vertexA.point];
	      if (he.edge && he.edge.curve) {
	        he.edge.curve.approximate(10, he.vertexA.point, he.vertexB.point, points);
	      }
	      points.push(he.vertexB.point);
	      window.__DEBUG__.AddPolyLine(points, color);
	    },
	    AddFace: function AddFace(face, color) {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = face.edges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var e = _step.value;
	          __DEBUG__.AddHalfEdge(e, color);
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    },
	    AddVolume: function AddVolume(shell, color) {
	      color = color || 0xffffff;
	      var geometry = new THREE.Geometry();
	      (0, _brepSceneObject.triangulateToThree)(shell, geometry);
	      var mesh = new THREE.Mesh(geometry, (0, _sceneObject.createSolidMaterial)({
	        color: color,
	        transparent: true,
	        opacity: 0.5
	      }));
	      debugVolumeGroup.add(mesh);
	      window.__DEBUG__.AddWireframe(shell, color);
	      app.viewer.render();
	    },
	    AddWireframe: function AddWireframe(shell, color) {
	      color = color || 0xffffff;
	      var visited = new Set();
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        for (var _iterator2 = shell.edges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var e = _step2.value;
	
	          var lg = new THREE.Geometry();
	          lg.vertices.push(e.halfEdge1.vertexA.point.three());
	          lg.vertices.push(e.halfEdge2.vertexA.point.three());
	          var line = new THREE.Line(lg, new THREE.LineBasicMaterial({ color: color, linewidth: 3 / _dpr2.default }));
	          debugVolumeGroup.add(line);
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	
	      app.viewer.render();
	    },
	    HideSolids: function HideSolids() {
	      app.findAllSolidsOnScene().forEach(function (s) {
	        return s.cadGroup.traverse(function (o) {
	          return o.visible = false;
	        });
	      });
	      app.viewer.render();
	    },
	    Clear: function Clear() {
	      clearGroup(debugGroup);
	      app.viewer.render();
	    },
	    ClearVolumes: function ClearVolumes() {
	      clearGroup(debugVolumeGroup);
	      app.viewer.render();
	    }
	  };
	}
	
	function clearGroup(g) {
	  while (g.children.length) {
	    var o = g.children[0];
	    o.material.dispose();
	    o.geometry.dispose();
	    g.remove(o);
	  }
	}
	
	function createLine(a, b, color) {
	  color = color || 0xFA8072;
	  var debugLineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 10 });
	  var lg = new THREE.Geometry();
	  lg.vertices.push(a.three());
	  lg.vertices.push(b.three());
	  return new THREE.Line(lg, debugLineMaterial);
	}
	
	function createPoint(x, y, z, color) {
	  if (z === undefined) {
	    color = y;
	    y = x.y;
	    z = x.z;
	    x = x.x;
	  }
	  color = color || 0x00ff00;
	  var geometry = new THREE.SphereGeometry(5, 16, 16);
	  var material = new THREE.MeshBasicMaterial({ color: color });
	  var sphere = new THREE.Mesh(geometry, material);
	  sphere.position.x = x;
	  sphere.position.y = y;
	  sphere.position.z = z;
	  return sphere;
	}
	
	var DebugMenuConfig = {
	  debug: {
	    label: 'debug',
	    cssIcons: ['bug'],
	    info: 'set of debug actions',
	    actions: ['DebugPrintAllSolids', 'DebugPrintFace', 'DebugFaceId', 'DebugFaceSketch']
	  }
	};
	
	var DebugActions = {
	  'DebugPrintAllSolids': {
	    cssIcons: ['cutlery'],
	    label: 'print all solids',
	    info: 'print all solids from the proejct as JSON',
	    invoke: function invoke(app) {
	      app.findAllSolids().map(function (o) {
	        console.log("Solid ID: " + o.tCadId);
	        console.log(JSON.stringify(o.csg));
	      });
	    }
	  },
	
	  'DebugPrintFace': {
	    cssIcons: ['cutlery'],
	    label: 'print face',
	    info: 'print a face out as JSON',
	    listens: ['selection'],
	    update: (0, _actionHelpers.checkForSelectedFaces)(1),
	    invoke: function invoke(app) {
	      var s = app.viewer.selectionMgr.selection[0];
	      console.log(JSON.stringify({
	        polygons: s.csgGroup.polygons,
	        basis: s._basis
	      }));
	    }
	  },
	
	  'DebugFaceId': {
	    cssIcons: ['cutlery'],
	    label: 'print face id',
	    info: 'print a face id',
	    listens: ['selection'],
	    update: (0, _actionHelpers.checkForSelectedFaces)(1),
	    invoke: function invoke(app) {
	      console.log(app.viewer.selectionMgr.selection[0].id);
	    }
	  },
	
	  'DebugFaceSketch': {
	    cssIcons: ['cutlery'],
	    label: 'print face sketch',
	    info: 'print face sketch stripping constraints and boundary',
	    listens: ['selection'],
	    update: (0, _actionHelpers.checkForSelectedFaces)(1),
	    invoke: function invoke(app) {
	      var faceId = app.viewer.selectionMgr.selection[0].id;
	      var sketch = JSON.parse(localStorage.getItem(app.faceStorageKey(faceId)));
	      var layers = sketch.layers.filter(function (l) {
	        return l.name != '__bounds__';
	      });
	      var data = [];
	      var _iteratorNormalCompletion3 = true;
	      var _didIteratorError3 = false;
	      var _iteratorError3 = undefined;
	
	      try {
	        for (var _iterator3 = layers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	          var l = _step3.value;
	          var _iteratorNormalCompletion4 = true;
	          var _didIteratorError4 = false;
	          var _iteratorError4 = undefined;
	
	          try {
	            for (var _iterator4 = l.data[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	              var d = _step4.value;
	
	              data.push(d);
	            }
	          } catch (err) {
	            _didIteratorError4 = true;
	            _iteratorError4 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                _iterator4.return();
	              }
	            } finally {
	              if (_didIteratorError4) {
	                throw _iteratorError4;
	              }
	            }
	          }
	        }
	      } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion3 && _iterator3.return) {
	            _iterator3.return();
	          }
	        } finally {
	          if (_didIteratorError3) {
	            throw _iteratorError3;
	          }
	        }
	      }
	
	      var squashed = {
	        layers: [{
	          name: 'sketch',
	          data: data
	        }]
	      };
	      console.log(JSON.stringify(squashed));
	    }
	  }
	};

/***/ },
/* 449 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.init = init;
	function init() {
	  localStorage.setItem("TCAD.projects.sample", '{"history":[{"type":"PLANE","solids":[],"params":{"basis":[[1,0,0],[0,0,1],[0,1,0]],"depth":"0"},"protoParams":["XZ","0"]},{"type":"EXTRUDE","solids":[0],"face":"0:0","params":{"target":[0,-50,0],"expansionFactor":"1"},"protoParams":["50","1","0","0"]},{"type":"EXTRUDE","solids":[1],"face":"1:1","params":{"target":[0,-50,0],"expansionFactor":"1"},"protoParams":["50","1","0","0"]},{"type":"CUT","solids":[2],"face":"2:0","params":{"target":[0,252,0],"expansionFactor":"1"},"protoParams":["252","1","0","0"]},{"type":"CUT","solids":[3],"face":"1:1$","params":{"target":[0,50,0],"expansionFactor":"1"},"protoParams":["50","1","0","0"]}]}');
	  localStorage.setItem("TCAD.projects.sample.sketch.0:0", '{"layers":[{"name":"_dim","style":{"lineWidth":1,"strokeStyle":"#bcffc1","fillStyle":"#00FF00"},"data":[]},{"name":"__bounds__","style":{"lineWidth":2,"strokeStyle":"#fff5c3","fillStyle":"#000000"},"data":[{"id":6,"_class":"TCAD.TWO.Segment","aux":true,"edge":0,"points":[[0,[1,-400],[2,400]],[3,[4,-400],[5,-400]]]},{"id":13,"_class":"TCAD.TWO.Segment","aux":true,"edge":2,"points":[[7,[8,-400],[9,-400]],[10,[11,400],[12,-400]]]},{"id":20,"_class":"TCAD.TWO.Segment","aux":true,"edge":4,"points":[[14,[15,400],[16,-400]],[17,[18,400],[19,400]]]},{"id":27,"_class":"TCAD.TWO.Segment","aux":true,"edge":6,"points":[[21,[22,400],[23,400]],[24,[25,-400],[26,400]]]}]},{"name":"sketch","style":{"lineWidth":2,"strokeStyle":"#ffffff","fillStyle":"#000000"},"data":[{"id":34,"_class":"TCAD.TWO.Segment","points":[[28,[29,-80.41502600578134],[30,240.48794311524324]],[31,[32,252.10163324769275],[33,71.15131239804411]]]},{"id":41,"_class":"TCAD.TWO.Segment","points":[[35,[36,255.946878629896],[37,-145.76094357167156]],[38,[39,-91.17342089039929],[40,-338.36716169336114]]]},{"id":48,"_class":"TCAD.TWO.Segment","points":[[42,[43,-172.00749593627577],[44,-240.71428346724593]],[45,[46,-88.51020843368133],[47,-140.46311545122035]]]},{"id":55,"_class":"TCAD.TWO.Segment","points":[[49,[50,-102.18982576106004],[51,18.31440664196805]],[52,[53,-182.7982464866314],[54,86.82364838151852]]]},{"id":72,"_class":"TCAD.TWO.Arc","points":[[63,[64,255.946878629896],[65,-145.76094357167156]],[66,[67,252.10163324769275],[68,71.15131239804411]],[69,[70,196.33682709088268],[71,-38.32745196977044]]]},{"id":83,"_class":"TCAD.TWO.Arc","points":[[74,[75,-80.41502600578134],[76,240.48794311524324]],[77,[78,-182.7982464866314],[79,86.82364838151852]],[80,[81,-122.59914075444685],[82,157.65429488839598]]]},{"id":94,"_class":"TCAD.TWO.Arc","points":[[85,[86,-88.51020843368133],[87,-140.46311545122035]],[88,[89,-102.18982576106004],[90,18.31440664196805]],[91,[92,-175.53398017227],[93,-67.98267439986091]]]},{"id":105,"_class":"TCAD.TWO.Arc","points":[[96,[97,-172.00749593627577],[98,-240.71428346724593]],[99,[100,-91.17342089039929],[101,-338.36716169336114]],[102,[103,-122.4591797419898],[104,-281.9821285194346]]]}]},{"name":"_construction_","style":{"lineWidth":1,"strokeStyle":"#aaaaaa","fillStyle":"#000000"},"data":[]}],"constraints":[["Tangent",[72,41]],["Tangent",[72,34]],["coi",[63,35]],["coi",[66,31]],["Tangent",[83,34]],["Tangent",[83,55]],["coi",[74,28]],["coi",[77,52]],["Tangent",[94,48]],["Tangent",[94,55]],["coi",[85,45]],["coi",[88,49]],["Tangent",[105,48]],["Tangent",[105,41]],["coi",[96,42]],["coi",[99,38]]],"boundary":{"lines":[{"a":{"x":-400,"y":400},"b":{"x":-400,"y":-400}},{"a":{"x":-400,"y":-400},"b":{"x":400,"y":-400}},{"a":{"x":400,"y":-400},"b":{"x":400,"y":400}},{"a":{"x":400,"y":400},"b":{"x":-400,"y":400}}],"arcs":[],"circles":[]}}');
	  localStorage.setItem("TCAD.projects.sample.sketch.1:0", '{"boundary":{"lines":[{"a":{"x":80.41502600578134,"y":240.48794311524324},"b":{"x":-252.10163324769275,"y":71.15131239804411}},{"a":{"x":-255.946878629896,"y":-145.76094357167156},"b":{"x":91.17342089039929,"y":-338.36716169336114}},{"a":{"x":172.00749593627577,"y":-240.71428346724593},"b":{"x":88.51020843368133,"y":-140.46311545122035}},{"a":{"x":102.18982576106004,"y":18.31440664196805},"b":{"x":182.7982464866314,"y":86.82364838151852}}],"arcs":[{"a":{"x":-252.10163324769275,"y":71.15131239804411},"b":{"x":-255.946878629896,"y":-145.76094357167156},"c":{"x":-196.33682672526209,"y":-38.32745176660378}},{"a":{"x":91.17342089039929,"y":-338.36716169336114},"b":{"x":172.00749593627577,"y":-240.71428346724593},"c":{"x":122.45917974196499,"y":-281.98212851943595}},{"a":{"x":102.18982576106004,"y":18.31440664196805},"b":{"x":88.51020843368133,"y":-140.46311545122035},"c":{"x":175.5339801724776,"y":-67.98267439979745}},{"a":{"x":182.7982464866314,"y":86.82364838151852},"b":{"x":80.41502600578134,"y":240.48794311524324},"c":{"x":122.59914075460381,"y":157.65429488902345}}],"circles":[]}}');
	  localStorage.setItem("TCAD.projects.sample.sketch.1:1", '{"layers":[{"name":"_dim","style":{"lineWidth":1,"strokeStyle":"#bcffc1","fillStyle":"#00FF00"},"data":[]},{"name":"__bounds__","style":{"lineWidth":2,"strokeStyle":"#fff5c3","fillStyle":"#000000"},"data":[{"id":6,"_class":"TCAD.TWO.Segment","aux":true,"edge":0,"points":[[0,[1,-91.17342089039929],[2,-338.36716169336114]],[3,[4,255.946878629896],[5,-145.76094357167156]]]},{"id":13,"_class":"TCAD.TWO.Segment","aux":true,"edge":2,"points":[[7,[8,252.10163324769275],[9,71.15131239804411]],[10,[11,-80.41502600578134],[12,240.48794311524324]]]},{"id":20,"_class":"TCAD.TWO.Segment","aux":true,"edge":4,"points":[[14,[15,-182.7982464866314],[16,86.82364838151852]],[17,[18,-102.18982576106004],[19,18.31440664196805]]]},{"id":27,"_class":"TCAD.TWO.Segment","aux":true,"edge":6,"points":[[21,[22,-88.51020843368133],[23,-140.46311545122035]],[24,[25,-172.00749593627577],[26,-240.71428346724593]]]},{"id":37,"_class":"TCAD.TWO.Arc","aux":true,"edge":8,"points":[[28,[29,255.946878629896],[30,-145.76094357167156]],[31,[32,252.10163324769275],[33,71.15131239804411]],[34,[35,196.33682672526209],[36,-38.32745176660376]]]},{"id":48,"_class":"TCAD.TWO.Arc","aux":true,"edge":10,"points":[[39,[40,-80.41502600578134],[41,240.48794311524324]],[42,[43,-182.7982464866314],[44,86.82364838151852]],[45,[46,-122.59914075460384],[47,157.65429488902345]]]},{"id":59,"_class":"TCAD.TWO.Arc","aux":true,"edge":12,"points":[[50,[51,-88.51020843368133],[52,-140.46311545122035]],[53,[54,-102.18982576106004],[55,18.31440664196805]],[56,[57,-175.5339801724776],[58,-67.98267439979745]]]},{"id":70,"_class":"TCAD.TWO.Arc","aux":true,"edge":14,"points":[[61,[62,-172.00749593627577],[63,-240.71428346724593]],[64,[65,-91.17342089039929],[66,-338.36716169336114]],[67,[68,-122.45917974196257],[69,-281.982128519434]]]}]},{"name":"sketch","style":{"lineWidth":2,"strokeStyle":"#ffffff","fillStyle":"#000000"},"data":[{"id":75,"_class":"TCAD.TWO.Circle","c":[72,[73,-122.59914075460384],[74,157.65429488902345]],"r":92.9565103454672},{"id":77,"_class":"TCAD.TWO.EndPoint","location":[77,[78,30.202166630027865],[79,-54.24889318543422]]},{"id":83,"_class":"TCAD.TWO.Circle","c":[80,[81,-122.45917974196257],[82,-281.982128519434]],"r":64.48310377876552}]},{"name":"_construction_","style":{"lineWidth":1,"strokeStyle":"#aaaaaa","fillStyle":"#000000"},"data":[]}],"constraints":[["RR",[48,75]],["coi",[72,45]],["coi",[80,67]],["RR",[83,70]]]}');
	  localStorage.setItem("TCAD.projects.sample.sketch.1:1$", '{"layers":[{"name":"_dim","style":{"lineWidth":1,"strokeStyle":"#bcffc1","fillStyle":"#00FF00"},"data":[]},{"name":"__bounds__","style":{"lineWidth":2,"strokeStyle":"#fff5c3","fillStyle":"#000000"},"data":[{"id":909,"_class":"TCAD.TWO.Segment","aux":true,"edge":0,"points":[[903,[904,-124.85084567322261],[905,-346.42086381904903]],[906,[907,-121.65017719515622],[908,-346.2848202888915]]]},{"id":916,"_class":"TCAD.TWO.Segment","aux":true,"edge":2,"points":[[910,[911,-121.65017719515622],[912,-346.2848202888915]],[913,[914,-126.76777558258588],[915,-346.1961840440328]]]},{"id":923,"_class":"TCAD.TWO.Segment","aux":true,"edge":4,"points":[[917,[918,-126.76777558258588],[919,-346.1961840440328]],[920,[921,-124.85084567322261],[922,-346.42086381904903]]]},{"id":930,"_class":"TCAD.TWO.Segment","aux":true,"edge":6,"points":[[924,[925,-116.53642857559844],[926,-346.06746181540075]],[927,[928,-114.6081175386342],[929,-345.98549948705966]]]},{"id":937,"_class":"TCAD.TWO.Segment","aux":true,"edge":8,"points":[[931,[932,-114.6081175386342],[933,-345.98549948705966]],[934,[935,-111.4694612123672],[936,-345.34392095429644]]]},{"id":944,"_class":"TCAD.TWO.Segment","aux":true,"edge":10,"points":[[938,[939,-111.4694612123672],[940,-345.34392095429644]],[941,[942,-116.53642857559844],[943,-346.06746181540075]]]},{"id":951,"_class":"TCAD.TWO.Segment","aux":true,"edge":12,"points":[[945,[946,-136.89021476237798],[947,-344.7017757862507]],[948,[949,-135.03311997329527],[950,-345.22741846263864]]]},{"id":958,"_class":"TCAD.TWO.Segment","aux":true,"edge":14,"points":[[952,[953,-135.03311997329527],[954,-345.22741846263864]],[955,[956,-131.85134223207632],[957,-345.6003486900595]]]},{"id":965,"_class":"TCAD.TWO.Segment","aux":true,"edge":16,"points":[[959,[960,-131.85134223207632],[961,-345.6003486900595]],[962,[963,-136.89021476237798],[964,-344.7017757862507]]]},{"id":972,"_class":"TCAD.TWO.Segment","aux":true,"edge":18,"points":[[966,[967,-106.45479019397476],[968,-344.31886279569994]],[969,[970,-104.5638397013956],[971,-343.9323301153285]]]},{"id":979,"_class":"TCAD.TWO.Segment","aux":true,"edge":20,"points":[[973,[974,-104.5638397013956],[975,-343.9323301153285]],[976,[977,-102.65803400883827],[978,-343.1402615618105]]]},{"id":986,"_class":"TCAD.TWO.Segment","aux":true,"edge":22,"points":[[980,[981,-102.65803400883827],[982,-343.1402615618105]],[983,[984,-106.45479019397476],[985,-344.31886279569994]]]},{"id":993,"_class":"TCAD.TWO.Segment","aux":true,"edge":24,"points":[[987,[988,-146.64788251166573],[989,-341.6220110088687]],[990,[991,-144.89756439084644],[992,-342.43532998379334]]]},{"id":1000,"_class":"TCAD.TWO.Segment","aux":true,"edge":26,"points":[[994,[995,-144.89756439084644],[996,-342.43532998379334]],[997,[998,-141.81510277637994],[999,-343.30780745905]]]},{"id":1007,"_class":"TCAD.TWO.Segment","aux":true,"edge":28,"points":[[1001,[1002,-141.81510277637994],[1003,-343.30780745905]],[1004,[1005,-146.64788251166573],[1006,-341.6220110088687]]]},{"id":1014,"_class":"TCAD.TWO.Segment","aux":true,"edge":30,"points":[[1008,[1009,-91.17342089039929],[1010,-338.36716169336114]],[1011,[1012,255.946878629896],[1013,-145.76094357167156]]]},{"id":1021,"_class":"TCAD.TWO.Segment","aux":true,"edge":32,"points":[[1015,[1016,252.10163324769275],[1017,71.15131239804411]],[1018,[1019,-80.41502600578134],[1020,240.48794311524324]]]},{"id":1028,"_class":"TCAD.TWO.Segment","aux":true,"edge":34,"points":[[1022,[1023,-80.41502600578134],[1024,240.48794311524324]],[1025,[1026,-81.03180870826053],[1027,240.74252296578175]]]},{"id":1035,"_class":"TCAD.TWO.Segment","aux":true,"edge":36,"points":[[1029,[1030,-81.03180870826053],[1031,240.74252296578175]],[1032,[1033,-68.90130878449338],[1034,233.53219455234265]]]},{"id":1042,"_class":"TCAD.TWO.Segment","aux":true,"edge":38,"points":[[1036,[1037,-68.90130878449338],[1038,233.53219455234265]],[1039,[1040,-57.55454096229795],[1041,224.06297544710796]]]},{"id":1049,"_class":"TCAD.TWO.Segment","aux":true,"edge":40,"points":[[1043,[1044,-183.60296592346776],[1045,87.66174623159009]],[1046,[1047,-182.7982464866314],[1048,86.82364838151852]]]},{"id":1056,"_class":"TCAD.TWO.Segment","aux":true,"edge":42,"points":[[1050,[1051,-182.7982464866314],[1052,86.82364838151852]],[1053,[1054,-102.18982576106004],[1055,18.31440664196805]]]},{"id":1063,"_class":"TCAD.TWO.Segment","aux":true,"edge":44,"points":[[1057,[1058,-88.51020843368133],[1059,-140.46311545122035]],[1060,[1061,-172.00749593627577],[1062,-240.71428346724593]]]},{"id":1070,"_class":"TCAD.TWO.Segment","aux":true,"edge":46,"points":[[1064,[1065,-172.00749593627577],[1066,-240.71428346724593]],[1067,[1068,-173.85553817260416],[1069,-243.3310613415531]]]},{"id":1077,"_class":"TCAD.TWO.Segment","aux":true,"edge":48,"points":[[1071,[1072,-173.85553817260416],[1073,-243.3310613415531]],[1074,[1075,-169.45270100330094],[1076,-237.82695178551998]]]},{"id":1084,"_class":"TCAD.TWO.Segment","aux":true,"edge":50,"points":[[1078,[1079,-169.45270100330094],[1080,-237.82695178551998]],[1081,[1082,-161.86089236160166],[1083,-230.93728827497424]]]},{"id":1091,"_class":"TCAD.TWO.Segment","aux":true,"edge":52,"points":[[1085,[1086,-93.05073865718533],[1087,-339.1473904301305]],[1088,[1089,-91.17342089039929],[1090,-338.36716169336114]]]},{"id":1098,"_class":"TCAD.TWO.Segment","aux":true,"edge":54,"points":[[1092,[1093,-155.79413550803565],[1094,-337.03473653312227]],[1095,[1096,-154.194836623249],[1097,-338.11517364666224]]]},{"id":1105,"_class":"TCAD.TWO.Segment","aux":true,"edge":56,"points":[[1099,[1100,-154.194836623249],[1101,-338.11517364666224]],[1102,[1103,-151.28960612438567],[1104,-339.465144867979]]]},{"id":1112,"_class":"TCAD.TWO.Segment","aux":true,"edge":58,"points":[[1106,[1107,-151.28960612438567],[1108,-339.465144867979]],[1109,[1110,-155.79413550803565],[1111,-337.03473653312227]]]},{"id":1119,"_class":"TCAD.TWO.Segment","aux":true,"edge":60,"points":[[1113,[1114,-164.09778508175484],[1115,-331.0559043105029]],[1116,[1117,-162.68993070681643],[1118,-332.3761494916342]]]},{"id":1126,"_class":"TCAD.TWO.Segment","aux":true,"edge":62,"points":[[1120,[1121,-162.68993070681643],[1122,-332.3761494916342]],[1123,[1124,-160.03536646411845],[1125,-334.1694914087516]]]},{"id":1133,"_class":"TCAD.TWO.Segment","aux":true,"edge":64,"points":[[1127,[1128,-160.03536646411845],[1129,-334.1694914087516]],[1130,[1131,-164.09778508175484],[1132,-331.0559043105029]]]},{"id":1140,"_class":"TCAD.TWO.Segment","aux":true,"edge":66,"points":[[1134,[1135,-171.34894094227198],[1136,-323.8366405200772]],[1137,[1138,-170.1681172325551],[1139,-325.3633220998529]]]},{"id":1147,"_class":"TCAD.TWO.Segment","aux":true,"edge":68,"points":[[1141,[1142,-170.1681172325551],[1143,-325.3633220998529]],[1144,[1145,-167.83131832762314],[1146,-327.5547046380108]]]},{"id":1154,"_class":"TCAD.TWO.Segment","aux":true,"edge":70,"points":[[1148,[1149,-167.83131832762314],[1150,-327.5547046380108]],[1151,[1152,-171.34894094227198],[1153,-323.8366405200772]]]},{"id":1161,"_class":"TCAD.TWO.Segment","aux":true,"edge":72,"points":[[1155,[1156,-177.36431654830434],[1157,-315.5594255713455]],[1158,[1159,-176.44037103403136],[1160,-317.2539538143128]]]},{"id":1168,"_class":"TCAD.TWO.Segment","aux":true,"edge":74,"points":[[1162,[1163,-176.44037103403136],[1164,-317.2539538143128]],[1165,[1166,-174.48040443457532],[1167,-319.787985676768]]]},{"id":1175,"_class":"TCAD.TWO.Segment","aux":true,"edge":76,"points":[[1169,[1170,-174.48040443457532],[1171,-319.787985676768]],[1172,[1173,-177.36431654830434],[1174,-315.5594255713455]]]},{"id":1182,"_class":"TCAD.TWO.Segment","aux":true,"edge":78,"points":[[1176,[1177,-181.9918620183506],[1178,-306.43348157021944]],[1179,[1180,-181.34814915237982],[1181,-308.25302410223765]]]},{"id":1189,"_class":"TCAD.TWO.Segment","aux":true,"edge":80,"points":[[1183,[1184,-181.34814915237982],[1185,-308.25302410223765]],[1186,[1187,-179.81455668401662],[1188,-311.0656528889991]]]},{"id":1196,"_class":"TCAD.TWO.Segment","aux":true,"edge":82,"points":[[1190,[1191,-179.81455668401662],[1192,-311.0656528889991]],[1193,[1194,-181.9918620183506],[1195,-306.43348157021944]]]},{"id":1203,"_class":"TCAD.TWO.Segment","aux":true,"edge":84,"points":[[1197,[1198,-185.11460747614086],[1199,-296.6894838385504]],[1200,[1201,-184.76739830644107],[1202,-298.5880483152473]]]},{"id":1210,"_class":"TCAD.TWO.Segment","aux":true,"edge":86,"points":[[1204,[1205,-184.76739830644107],[1206,-298.5880483152473]],[1207,[1208,-183.69894439028664],[1209,-301.6081795674206]]]},{"id":1217,"_class":"TCAD.TWO.Segment","aux":true,"edge":88,"points":[[1211,[1212,-183.69894439028664],[1213,-301.6081795674206]],[1214,[1215,-185.11460747614086],[1216,-296.6894838385504]]]},{"id":1224,"_class":"TCAD.TWO.Segment","aux":true,"edge":90,"points":[[1218,[1219,-186.65361968327025],[1220,-286.5737301634624]],[1221,[1222,-186.61169057171756],[1223,-288.5033268128508]]]},{"id":1231,"_class":"TCAD.TWO.Segment","aux":true,"edge":92,"points":[[1225,[1226,-186.61169057171756],[1227,-288.5033268128508]],[1228,[1229,-186.03538238106256],[1230,-291.6546210581988]]]},{"id":1238,"_class":"TCAD.TWO.Segment","aux":true,"edge":94,"points":[[1232,[1233,-186.03538238106256],[1234,-291.6546210581988]],[1235,[1236,-186.65361968327025],[1237,-286.5737301634624]]]},{"id":1245,"_class":"TCAD.TWO.Segment","aux":true,"edge":96,"points":[[1239,[1240,-186.56999722459386],[1241,-276.3419151596114]],[1242,[1243,-186.83440800799133],[1244,-278.25376981343675]]]},{"id":1252,"_class":"TCAD.TWO.Segment","aux":true,"edge":98,"points":[[1246,[1247,-186.83440800799133],[1248,-278.25376981343675]],[1249,[1250,-186.76481281142574],[1251,-281.4565721894818]]]},{"id":1259,"_class":"TCAD.TWO.Segment","aux":true,"edge":100,"points":[[1253,[1254,-186.76481281142574],[1255,-281.4565721894818]],[1256,[1257,-186.56999722459386],[1258,-276.3419151596114]]]},{"id":1266,"_class":"TCAD.TWO.Segment","aux":true,"edge":102,"points":[[1260,[1261,-184.86585381433073],[1262,-266.252667109051]],[1263,[1264,-185.42992101504922],[1265,-268.0984540612155]]]},{"id":1273,"_class":"TCAD.TWO.Segment","aux":true,"edge":104,"points":[[1267,[1268,-185.42992101504922],[1269,-268.0984540612155]],[1270,[1271,-185.86879796147372],[1272,-271.2718077410349]]]},{"id":1280,"_class":"TCAD.TWO.Segment","aux":true,"edge":106,"points":[[1274,[1275,-185.86879796147372],[1276,-271.2718077410349]],[1277,[1278,-184.86585381433073],[1279,-266.252667109051]]]},{"id":1287,"_class":"TCAD.TWO.Segment","aux":true,"edge":108,"points":[[1281,[1282,-181.58426486797975],[1283,-256.5610106471486]],[1284,[1285,-182.43373063136903],[1286,-258.2940741764191]]]},{"id":1294,"_class":"TCAD.TWO.Segment","aux":true,"edge":110,"points":[[1288,[1289,-182.43373063136903],[1290,-258.2940741764191]],[1291,[1292,-183.3699862842126],[1293,-261.35776670402527]]]},{"id":1301,"_class":"TCAD.TWO.Segment","aux":true,"edge":112,"points":[[1295,[1296,-183.3699862842126],[1297,-261.35776670402527]],[1298,[1299,-181.58426486797975],[1300,-256.5610106471486]]]},{"id":1308,"_class":"TCAD.TWO.Segment","aux":true,"edge":114,"points":[[1302,[1303,-176.80817869053936],[1304,-247.5119205374264]],[1305,[1306,-177.92157117890073],[1307,-249.08845421814587]]]},{"id":1315,"_class":"TCAD.TWO.Segment","aux":true,"edge":116,"points":[[1309,[1310,-177.92157117890073],[1311,-249.08845421814587]],[1312,[1313,-179.3315399235013],[1314,-251.96504502850303]]]},{"id":1322,"_class":"TCAD.TWO.Segment","aux":true,"edge":118,"points":[[1316,[1317,-179.3315399235013],[1318,-251.96504502850303]],[1319,[1320,-176.80817869053936],[1321,-247.5119205374264]]]},{"id":1329,"_class":"TCAD.TWO.Segment","aux":true,"edge":120,"points":[[1323,[1324,-199.52633139024357],[1325,105.99235078457345]],[1326,[1327,-195.81654775637261],[1328,100.38192696448344]]]},{"id":1336,"_class":"TCAD.TWO.Segment","aux":true,"edge":122,"points":[[1330,[1331,-195.81654775637261],[1332,100.38192696448344]],[1333,[1334,-195.41416831449038],[1335,99.96285749788738]]]},{"id":1343,"_class":"TCAD.TWO.Segment","aux":true,"edge":124,"points":[[1337,[1338,-195.41416831449038],[1339,99.96285749788738]],[1340,[1341,-199.52633139024357],[1342,105.99235078457345]]]},{"id":1350,"_class":"TCAD.TWO.Segment","aux":true,"edge":126,"points":[[1344,[1345,-206.74167768777465],[1346,118.83699711877475]],[1347,[1348,-203.9679416929228],[1349,112.70953935972136]]]},{"id":1357,"_class":"TCAD.TWO.Segment","aux":true,"edge":128,"points":[[1351,[1352,-203.9679416929228],[1353,112.70953935972136]],[1354,[1355,-203.59991146204723],[1356,112.1529555323074]]]},{"id":1364,"_class":"TCAD.TWO.Segment","aux":true,"edge":130,"points":[[1358,[1359,-203.59991146204723],[1360,112.1529555323074]],[1361,[1362,-206.74167768777465],[1363,118.83699711877475]]]},{"id":1371,"_class":"TCAD.TWO.Segment","aux":true,"edge":132,"points":[[1365,[1366,-211.83016381958026],[1367,132.6628233336642]],[1368,[1369,-210.06258683256036],[1370,126.17321460454002]]]},{"id":1378,"_class":"TCAD.TWO.Segment","aux":true,"edge":134,"points":[[1372,[1373,-210.06258683256036],[1374,126.17321460454002]],[1375,[1376,-209.7874174967478],[1377,125.56533826558501]]]},{"id":1385,"_class":"TCAD.TWO.Segment","aux":true,"edge":136,"points":[[1379,[1380,-209.7874174967478],[1381,125.56533826558501]],[1382,[1383,-211.83016381958026],[1384,132.6628233336642]]]},{"id":1392,"_class":"TCAD.TWO.Segment","aux":true,"edge":138,"points":[[1386,[1387,-214.66316877134335],[1388,147.1203557849574]],[1389,[1390,-213.94642960789847],[1391,140.43263309803072]]]},{"id":1399,"_class":"TCAD.TWO.Segment","aux":true,"edge":140,"points":[[1393,[1394,-213.94642960789847],[1395,140.43263309803072]],[1396,[1397,-213.77107658712956],[1398,139.78882946027298]]]},{"id":1406,"_class":"TCAD.TWO.Segment","aux":true,"edge":142,"points":[[1400,[1401,-213.77107658712956],[1402,139.78882946027298]],[1403,[1404,-214.66316877134335],[1405,147.1203557849574]]]},{"id":1413,"_class":"TCAD.TWO.Segment","aux":true,"edge":144,"points":[[1407,[1408,-215.16908303852756],[1409,161.84415327050888]],[1410,[1411,-215.5212986207668],[1412,155.127361338742]]]},{"id":1420,"_class":"TCAD.TWO.Segment","aux":true,"edge":146,"points":[[1414,[1415,-215.5212986207668],[1416,155.127361338742]],[1417,[1418,-215.4501942907495],[1419,154.46390374461535]]]},{"id":1427,"_class":"TCAD.TWO.Segment","aux":true,"edge":148,"points":[[1421,[1422,-215.4501942907495],[1423,154.46390374461535]],[1424,[1425,-215.16908303852756],[1426,161.84415327050888]]]},{"id":1434,"_class":"TCAD.TWO.Segment","aux":true,"edge":150,"points":[[1428,[1429,-213.33511869067203],[1430,176.46204424088245]],[1431,[1432,-214.74738610811426],[1433,169.88596255629682]]]},{"id":1441,"_class":"TCAD.TWO.Segment","aux":true,"edge":152,"points":[[1435,[1436,-214.74738610811426],[1437,169.88596255629682]],[1438,[1439,-214.7823277637057],[1440,169.21962113872806]]]},{"id":1448,"_class":"TCAD.TWO.Segment","aux":true,"edge":154,"points":[[1442,[1443,-214.7823277637057],[1444,169.21962113872806]],[1445,[1446,-213.33511869067203],[1447,176.46204424088245]]]},{"id":1455,"_class":"TCAD.TWO.Segment","aux":true,"edge":156,"points":[[1449,[1450,-209.20763261028907],[1451,190.60453413204746]],[1452,[1453,-211.6442541577552],[1454,184.335385471234]]]},{"id":1462,"_class":"TCAD.TWO.Segment","aux":true,"edge":158,"points":[[1456,[1457,-211.6442541577552],[1458,184.335385471234]],[1459,[1460,-211.78435858298565],[1461,183.68300325713744]]]},{"id":1469,"_class":"TCAD.TWO.Segment","aux":true,"edge":160,"points":[[1463,[1464,-211.78435858298565],[1465,183.68300325713744]],[1466,[1467,-209.20763261028907],[1468,190.60453413204746]]]},{"id":1476,"_class":"TCAD.TWO.Segment","aux":true,"edge":162,"points":[[1470,[1471,-202.89095473588415],[1472,203.91414503228458]],[1473,[1474,-206.29034023997258],[1475,198.11039386458984]]]},{"id":1483,"_class":"TCAD.TWO.Segment","aux":true,"edge":164,"points":[[1477,[1478,-206.29034023997258],[1479,198.11039386458984]],[1480,[1481,-206.5320660329977],[1482,197.48846103583213]]]},{"id":1490,"_class":"TCAD.TWO.Segment","aux":true,"edge":166,"points":[[1484,[1485,-206.5320660329977],[1486,197.48846103583213]],[1487,[1488,-202.89095473588415],[1489,203.91414503228458]]]},{"id":1497,"_class":"TCAD.TWO.Segment","aux":true,"edge":168,"points":[[1491,[1492,-194.54475092745736],[1493,216.05445160568848]],[1494,[1495,-198.82097455359153],[1496,210.86279860719284]]]},{"id":1504,"_class":"TCAD.TWO.Segment","aux":true,"edge":170,"points":[[1498,[1499,-198.82097455359153],[1500,210.86279860719284]],[1501,[1502,-199.1582116422664],[1503,210.28703568038364]]]},{"id":1511,"_class":"TCAD.TWO.Segment","aux":true,"edge":172,"points":[[1505,[1506,-199.1582116422664],[1507,210.28703568038364]],[1508,[1509,-194.54475092745736],[1510,216.05445160568848]]]},{"id":1518,"_class":"TCAD.TWO.Segment","aux":true,"edge":174,"points":[[1512,[1513,-184.379987112991],[1514,226.7185848724264]],[1515,[1516,-189.42495930181502],[1517,222.27025879184544]]]},{"id":1525,"_class":"TCAD.TWO.Segment","aux":true,"edge":176,"points":[[1519,[1520,-189.42495930181502],[1521,222.27025879184544]],[1522,[1523,-189.84918338721522],[1524,221.7552192528602]]]},{"id":1532,"_class":"TCAD.TWO.Segment","aux":true,"edge":178,"points":[[1526,[1527,-189.84918338721522],[1528,221.7552192528602]],[1529,[1530,-184.379987112991],[1531,226.7185848724264]]]},{"id":1539,"_class":"TCAD.TWO.Segment","aux":true,"edge":180,"points":[[1533,[1534,-172.65359672964632],[1535,235.63698889679065]],[1536,[1537,-178.3397963630285],[1538,232.04442950329735]]]},{"id":1546,"_class":"TCAD.TWO.Segment","aux":true,"edge":182,"points":[[1540,[1541,-178.3397963630285],[1542,232.04442950329735]],[1543,[1544,-178.8402843870677],[1545,231.6031319406896]]]},{"id":1553,"_class":"TCAD.TWO.Segment","aux":true,"edge":184,"points":[[1547,[1548,-178.8402843870677],[1549,231.6031319406896]],[1550,[1551,-172.65359672964632],[1552,235.63698889679065]]]},{"id":1560,"_class":"TCAD.TWO.Segment","aux":true,"edge":186,"points":[[1554,[1555,-159.66198625012984],[1556,242.58423431817306]],[1557,[1558,-165.84568398613052],[1559,239.93825027586973]]]},{"id":1567,"_class":"TCAD.TWO.Segment","aux":true,"edge":188,"points":[[1561,[1562,-165.84568398613052],[1563,239.93825027586973]],[1564,[1565,-166.40978517692938],[1566,239.58184931168483]]]},{"id":1574,"_class":"TCAD.TWO.Segment","aux":true,"edge":190,"points":[[1568,[1569,-166.40978517692938],[1570,239.58184931168483]],[1571,[1572,-159.66198625012984],[1573,242.58423431817306]]]},{"id":1581,"_class":"TCAD.TWO.Segment","aux":true,"edge":192,"points":[[1575,[1576,-87.85873092574069],[1577,243.56036599344466]],[1578,[1579,-94.0759657597847],[1580,246.1265577956006]]]},{"id":1588,"_class":"TCAD.TWO.Segment","aux":true,"edge":194,"points":[[1582,[1583,-94.0759657597847],[1584,246.1265577956006]],[1585,[1586,-94.72530009714954],[1587,246.28017003496572]]]},{"id":1595,"_class":"TCAD.TWO.Segment","aux":true,"edge":196,"points":[[1589,[1590,-94.72530009714954],[1591,246.28017003496572]],[1592,[1593,-87.85873092574069],[1594,243.56036599344466]]]},{"id":1602,"_class":"TCAD.TWO.Segment","aux":true,"edge":198,"points":[[1596,[1597,-145.73354295417178],[1598,247.38471650027034]],[1599,[1600,-152.25843425515438],[1601,245.75219000931554]]]},{"id":1609,"_class":"TCAD.TWO.Segment","aux":true,"edge":200,"points":[[1603,[1604,-152.25843425515438],[1605,245.75219000931554]],[1606,[1607,-152.8718898989769],[1608,245.48969434514922]]]},{"id":1616,"_class":"TCAD.TWO.Segment","aux":true,"edge":202,"points":[[1610,[1611,-152.8718898989769],[1612,245.48969434514922]],[1613,[1614,-145.73354295417178],[1615,247.38471650027034]]]},{"id":1623,"_class":"TCAD.TWO.Segment","aux":true,"edge":204,"points":[[1617,[1618,-101.91252341270427],[1619,247.98044276780786]],[1620,[1621,-108.45788216795745],[1622,249.5288703774163]]]},{"id":1630,"_class":"TCAD.TWO.Segment","aux":true,"edge":206,"points":[[1624,[1625,-108.45788216795745],[1626,249.5288703774163]],[1627,[1628,-109.12335499908941],[1629,249.57763216878644]]]},{"id":1637,"_class":"TCAD.TWO.Segment","aux":true,"edge":208,"points":[[1631,[1632,-109.12335499908941],[1633,249.57763216878644]],[1634,[1635,-101.91252341270427],[1636,247.98044276780786]]]},{"id":1644,"_class":"TCAD.TWO.Segment","aux":true,"edge":210,"points":[[1638,[1639,-131.22033432517946],[1640,249.91709426712018]],[1641,[1642,-137.9214903475247],[1643,249.33929049097623]]]},{"id":1651,"_class":"TCAD.TWO.Segment","aux":true,"edge":212,"points":[[1645,[1646,-137.9214903475247],[1647,249.33929049097623]],[1648,[1649,-138.56879420445267],[1650,249.17733519618488]]]},{"id":1658,"_class":"TCAD.TWO.Segment","aux":true,"edge":214,"points":[[1652,[1653,-138.56879420445267],[1654,249.17733519618488]],[1655,[1656,-131.22033432517946],[1657,249.91709426712018]]]},{"id":1665,"_class":"TCAD.TWO.Segment","aux":true,"edge":216,"points":[[1659,[1660,-116.48920888540648],[1661,250.11735702856262]],[1662,[1663,-123.19724536469215],[1664,250.60888103976808]]]},{"id":1672,"_class":"TCAD.TWO.Segment","aux":true,"edge":218,"points":[[1666,[1667,-123.19724536469215],[1668,250.60888103976808]],[1669,[1670,-123.86203561786023],[1671,250.5515598376735]]]},{"id":1679,"_class":"TCAD.TWO.Segment","aux":true,"edge":220,"points":[[1673,[1674,-123.86203561786023],[1675,250.5515598376735]],[1676,[1677,-116.48920888540648],[1678,250.11735702856262]]]},{"id":1689,"_class":"TCAD.TWO.Arc","aux":true,"edge":222,"points":[[1680,[1681,255.946878629896],[1682,-145.76094357167156]],[1683,[1684,252.10163324769275],[1685,71.15131239804411]],[1686,[1687,196.3368270908827],[1688,-38.32745196977044]]]},{"id":1700,"_class":"TCAD.TWO.Arc","aux":true,"edge":224,"points":[[1691,[1692,-183.60296592346776],[1693,87.66174623159009]],[1694,[1695,-57.55454096229795],[1696,224.06297544710796]],[1697,[1698,-122.51437135823936],[1699,157.65106605088206]]]},{"id":1711,"_class":"TCAD.TWO.Arc","aux":true,"edge":226,"points":[[1702,[1703,-88.51020843368133],[1704,-140.46311545122035]],[1705,[1706,-102.18982576106004],[1707,18.31440664196805]],[1708,[1709,-175.53398017227008],[1710,-67.98267439986091]]]},{"id":1722,"_class":"TCAD.TWO.Arc","aux":true,"edge":228,"points":[[1713,[1714,-93.05073865718533],[1715,-339.1473904301305]],[1716,[1717,-161.86089236160166],[1718,-230.93728827497424]],[1719,[1720,-122.42898493097368],[1721,-281.845807994961]]]}]},{"name":"sketch","style":{"lineWidth":2,"strokeStyle":"#ffffff","fillStyle":"#000000"},"data":[{"id":824,"_class":"TCAD.TWO.Circle","c":[821,[822,196.3368270908827],[823,-38.32745196977044]],"r":60.35462341678487},{"id":839,"_class":"TCAD.TWO.Circle","c":[836,[837,132.69721678409343],[838,-101.96706227655973]],"r":19.800361524305362},{"id":844,"_class":"TCAD.TWO.Circle","c":[841,[842,132.69721678409343],[843,25.31215833701884]],"r":19.800361524305362},{"id":1728,"_class":"TCAD.TWO.Circle","c":[1725,[1726,286.3368270908827],[1727,-38.32745196977044]],"r":19.800361524305362}]},{"name":"_construction_","style":{"lineWidth":1,"strokeStyle":"#aaaaaa","fillStyle":"#000000"},"data":[{"id":849,"_class":"TCAD.TWO.Circle","c":[846,[847,196.3368270908827],[848,-38.32745196977044]],"r":90},{"id":857,"_class":"TCAD.TWO.Segment","points":[[851,[852,196.33682709088274],[853,132.78406845227903]],[854,[855,196.33682709088274],[856,-220.71977128010505]]]},{"id":864,"_class":"TCAD.TWO.Segment","points":[[858,[859,51.75067758157451],[860,-38.32745196977045]],[861,[862,338.80027616827897],[863,-38.32745196977045]]]},{"id":865,"_class":"TCAD.TWO.EndPoint","location":[865,[866,106.33682709088271],[867,-38.32745196977044]]},{"id":868,"_class":"TCAD.TWO.EndPoint","location":[868,[869,196.3368270908827],[870,51.67254803022956]]},{"id":871,"_class":"TCAD.TWO.EndPoint","location":[871,[872,286.3368270908827],[873,-38.32745196977044]]},{"id":874,"_class":"TCAD.TWO.EndPoint","location":[874,[875,196.33682709088274],[876,-128.32745196977044]]},{"id":877,"_class":"TCAD.TWO.EndPoint","location":[877,[878,259.976437397672],[879,-101.96706227655972]]},{"id":880,"_class":"TCAD.TWO.EndPoint","location":[880,[881,132.69721678409343],[882,-101.96706227655973]]},{"id":883,"_class":"TCAD.TWO.EndPoint","location":[883,[884,259.976437397672],[885,25.31215833701884]]},{"id":886,"_class":"TCAD.TWO.EndPoint","location":[886,[887,132.69721678409343],[888,25.31215833701884]]},{"id":895,"_class":"TCAD.TWO.Segment","points":[[889,[890,304.81959818306],[891,-146.8102230619477]],[892,[893,96.47030360363001],[894,61.539071517482256]]]},{"id":902,"_class":"TCAD.TWO.Segment","points":[[896,[897,78.91914321714893],[898,-155.74513584350424]],[899,[900,306.6329904254398],[901,71.96871136478666]]]}]}],"constraints":[["Vertical",[857]],["perpendicular",[864,857]],["PointOnLine",[846,857]],["PointOnLine",[865,864]],["PointOnArc",[865,849]],["Radius",[849,90]],["PointOnArc",[868,849]],["PointOnLine",[868,857]],["PointOnArc",[871,849]],["PointOnLine",[871,864]],["PointOnArc",[874,849]],["PointOnLine",[874,857]],["Angle",[851,854,892,889,45]],["perpendicular",[902,895]],["PointOnArc",[880,849]],["PointOnLine",[880,902]],["PointOnLine",[886,895]],["PointOnArc",[886,849]],["PointOnArc",[883,849]],["PointOnLine",[883,902]],["PointOnLine",[877,895]],["PointOnArc",[877,849]],["coi",[836,880]],["coi",[841,886]],["coi",[1725,871]],["RR",[839,844]],["RR",[844,1728]]]}');
	  localStorage.setItem("TCAD.projects.sample.sketch.2:0", '{"layers":[{"name":"_dim","style":{"lineWidth":1,"strokeStyle":"#bcffc1","fillStyle":"#00FF00"},"data":[]},{"name":"__bounds__","style":{"lineWidth":2,"strokeStyle":"#fff5c3","fillStyle":"#000000"},"data":[{"id":3,"_class":"TCAD.TWO.Circle","aux":true,"edge":0,"c":[0,[1,-122.59914075460358],[2,157.65429488902262]],"r":92.95651034546636},{"id":8,"_class":"TCAD.TWO.Circle","aux":true,"edge":2,"c":[5,[6,-122.45917974196298],[7,-281.9821285194316]],"r":64.48310377876794}]},{"name":"sketch","style":{"lineWidth":2,"strokeStyle":"#ffffff","fillStyle":"#000000"},"data":[{"id":13,"_class":"TCAD.TWO.Circle","c":[10,[11,-122.59914075460358],[12,157.65429488902262]],"r":42.51842590924937},{"id":18,"_class":"TCAD.TWO.Circle","c":[15,[16,-122.45917974196298],[17,-281.9821285194316]],"r":34.86217749713944}]},{"name":"_construction_","style":{"lineWidth":1,"strokeStyle":"#aaaaaa","fillStyle":"#000000"},"data":[]}],"constraints":[["coi",[10,0]],["coi",[15,5]]]}');
	}

/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(451);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(453)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept(451, function() {
				var newContent = __webpack_require__(451);
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(452)();
	// imports
	
	
	// module
	exports.push([module.id, ".no-selection {\n  user-select: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n}\nbody {\n  background-color: #808080;\n  font: 11px 'Lucida Grande', sans-serif;\n}\niframe {\n  border: 0;\n}\n.main-font {\n  font: 11px 'Lucida Grande', sans-serif;\n}\n.history-selected,\n.history-selected:hover {\n  background-color: #780000;\n}\n.app-tab-view {\n  position: absolute;\n  top: 0;\n  bottom: 21px;\n  width: 100%;\n}\n#tab-switcher {\n  position: absolute;\n  height: 20px;\n  bottom: 0;\n  background-color: #000;\n  width: 100%;\n  border-top: 1px solid #2c2c2c;\n  color: #eee;\n  text-align: center;\n  user-select: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n}\n#tab-switcher .tab {\n  padding: 2px 5px 0 5px;\n  height: 100%;\n  float: left;\n  cursor: pointer;\n  border-right: 1px solid #2c2c2c;\n  color: #aaa;\n}\n#tab-switcher .tab:hover {\n  color: #eee;\n}\n#tab-switcher .tab-selected {\n  background-color: #222;\n  color: #eee;\n}\n.tab .expand:hover {\n  color: green;\n}\n.tab .close:hover {\n  color: red;\n}\n#viewer-container {\n  position: absolute;\n  left: 250px;\n  right: 0;\n  top: 0;\n  bottom: 0;\n}\n#control-bar {\n  position: absolute;\n  left: 250px;\n  right: 0;\n  bottom: 0;\n  height: 20px;\n  background-color: rgba(0, 0, 0, 0.5);\n  color: #ccc;\n}\n#control-bar .left-group {\n  text-align: left;\n  float: left;\n}\n#control-bar .right-group {\n  text-align: right;\n}\n#control-bar .left-group .button {\n  float: left;\n  border-right: 1px solid #2c2c2c;\n}\n#control-bar .right-group .button {\n  float: right;\n  border-left: 1px solid #2c2c2c;\n}\n.button .fa {\n  line-height: 1.5;\n}\n#control-bar .button {\n  padding: 3px 7px 0 5px;\n  height: 100%;\n  vertical-align: baseline;\n  cursor: pointer;\n  user-select: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n}\n#control-bar .button:hover {\n  background-color: #555;\n}\n#control-bar .button-selected {\n  background-color: #666;\n}\n#control-bar .button-selected:hover {\n  background-color: #666;\n}\n#right-panel {\n  position: absolute;\n  height: 100%;\n  background-color: #000;\n  width: 250px;\n}\n.aux-win {\n  color: #fff;\n  background-color: rgba(40, 40, 40, 0.95);\n  border: solid 1px #000;\n  border-radius: 3px;\n}\n.menu {\n  position: absolute;\n  color: #fff;\n  background-color: rgba(40, 40, 40, 0.95);\n  border: solid 1px #000;\n  border-radius: 3px;\n  /* this element can't have neither padding nor margin to be properly positioned as menu */\n}\n.menu-container {\n  padding: 5px 0 5px 0;\n}\n.menu-item {\n  padding: 5px 5px 5px 2px;\n  cursor: pointer;\n  text-transform: capitalize;\n  white-space: nowrap;\n}\n.menu-item .menu-text {\n  padding-right: 5px;\n}\n.menu-item:hover {\n  background-color: #0074D9;\n}\n.menu-flat-bottom {\n  border-radius: 3px 3px 0 0;\n}\n.menu-flat-top {\n  border-radius: 0 0 3px 3px;\n}\n.menu-separator {\n  border-top: solid 1px #777;\n}\n.menu-item .fa {\n  margin-left: -16px;\n  padding-right: 3px;\n}\n.action-disabled {\n  color: #6a6a6a;\n}\n.menu-item.action-disabled {\n  color: #888;\n}\n.menu-item .action-hotkey-info {\n  float: right;\n  padding-left: 15px;\n  color: #888;\n  font-size: 9px;\n  margin-top: 1px;\n}\n.icon16-left {\n  background-position-y: center;\n  background-position-x: 5px;\n  background-repeat: no-repeat;\n  background-size: 16px 16px;\n  padding-left: 25px;\n}\n.message-sink {\n  display: none;\n  position: absolute;\n  max-width: 400px;\n  padding: 2px 5px 2px 5px;\n  color: #fff;\n  background-color: rgba(40, 40, 40, 0.95);\n  border: solid 1px #000;\n  border-radius: 3px;\n  color: #ccc;\n  white-space: nowrap;\n  z-index: 999;\n}\n.action-info > div {\n  padding: 3px 0 3px 0;\n}\n.action-info-hotkey {\n  text-align: right;\n  font-style: italic;\n  color: #888;\n}\n.action-info-hint {\n  font-style: italic;\n  color: #E1A4A4;\n}\n.solid-list .solid-item {\n  background-image: url('../img/3d/solid32.png');\n}\n.solid-list .sketch-item {\n  padding-left: 50px;\n  background-position-x: 30px;\n  background-image: url('../img/3d/sketch32.png');\n}\n.modification-item {\n  word-wrap: break-word;\n  word-break: break-all;\n}\n.modification-button {\n  line-height: 27px;\n  font-size: 1.3em;\n  padding: 0 3px 0 3px;\n}\n.modification-button:hover {\n  color: yellowgreen;\n}\n.modification-button.danger:hover {\n  color: red;\n}\n.modification-button.action-disabled:hover {\n  color: #6a6a6a;\n}\n.modification-right-buttons {\n  display: none;\n}\n.history-selected .modification-right-buttons,\n.modification-item:hover .modification-right-buttons {\n  display: initial;\n}\n", ""]);
	
	// exports


/***/ },
/* 452 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _brepPrimitives = __webpack_require__(382);
	
	var BREPPrimitives = _interopRequireWildcard(_brepPrimitives);
	
	var _brepBuilder = __webpack_require__(360);
	
	var BREPBuilder = _interopRequireWildcard(_brepBuilder);
	
	var _boolean = __webpack_require__(374);
	
	var BREPBool = _interopRequireWildcard(_boolean);
	
	var _brepIo = __webpack_require__(455);
	
	var IO = _interopRequireWildcard(_brepIo);
	
	var _brepValidator = __webpack_require__(375);
	
	var _edge = __webpack_require__(364);
	
	var _loop = __webpack_require__(362);
	
	var _face = __webpack_require__(363);
	
	var _shell = __webpack_require__(361);
	
	var _vertex = __webpack_require__(323);
	
	var _point = __webpack_require__(322);
	
	var _nurbs = __webpack_require__(369);
	
	var _plane = __webpack_require__(371);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	exports.default = {
	  brep: {
	    builder: BREPBuilder,
	    primitives: BREPPrimitives,
	    bool: BREPBool,
	    validator: _brepValidator.BREPValidator,
	    geom: {
	      Point: _point.Point, NurbsCurve: _nurbs.NurbsCurve, Plane: _plane.Plane
	    },
	    topo: {
	      HalfEdge: _edge.HalfEdge, Edge: _edge.Edge, Loop: _loop.Loop, Face: _face.Face, Shell: _shell.Shell, Vertex: _vertex.Vertex
	    },
	    IO: IO
	  }
	};

/***/ },
/* 455 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.toLoops = toLoops;
	function toLoops(shell) {
	
	  var vertices = [];
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = shell.vertices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var v = _step.value;
	
	      vertices.push(v);
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  sortByXYZ(vertices);
	
	  var verticesIndex = new Map();
	  for (var i = 0; i < vertices.length; i++) {
	    verticesIndex.set(vertices[i], i);
	  }
	
	  var faces = shell.faces.map(function (f) {
	    var loops = [];
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	      for (var _iterator2 = f.loops[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	        var l = _step2.value;
	
	        loops.push(l.halfEdges.map(function (e) {
	          return verticesIndex.get(e.vertexA);
	        }));
	      }
	    } catch (err) {
	      _didIteratorError2 = true;
	      _iteratorError2 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion2 && _iterator2.return) {
	          _iterator2.return();
	        }
	      } finally {
	        if (_didIteratorError2) {
	          throw _iteratorError2;
	        }
	      }
	    }
	
	    return loops;
	  });
	  return {
	    format: 'LOOPS',
	    vertices: vertices.map(function (v) {
	      return [v.point.x, v.point.y, v.point.z];
	    }),
	    faces: faces
	  };
	}
	
	function sortByXYZ(vertices) {
	  vertices.sort(function (v1, v2) {
	    var c = v1.point.x - v2.point.x;
	    if (c == 0) {
	      c = v1.point.y - v2.point.y;
	      if (c == 0) {
	        c = v1.point.z - v2.point.z;
	      }
	    }
	    return c;
	  });
	}

/***/ }
/******/ ]);
//# sourceMappingURL=index.bundle.js.map